#!/bin/bash

# This file calls script files in another location (relative to own location) in definitions that makes them accessible as terminal commands

# TODO - move the cheatsheets to a new repository? (link into this repo as submodule).
#   Maybe even rename custom_bashrc into comfy_linux


SCRIPTS_PATH="$CUSTOM_BASHRC_FOLDER/unlimited_script_works"  # name of the scripts folder within this project. Change it if you want, just be aware this could break.
CHEATSHEETS_PATH="$CUSTOM_BASHRC_FOLDER/cheatsheets"  # name of the cheatsheets folder within this project. Change it if you want, just be aware this could break.
CHEATSHEET_PREFIX='howdoi_'

# TODO - remove? Consider if useful. Entire removal requires deletion of related file.
# alias _scripts_loaded_comfirmation='_py_confirm_loaded'  # a call to a script added in just to confirm that the rest of the scripts are reached right 

# Reloads script-files into bash-calls. No need to manually call this, it's done automatically
# --declare_commands (create aliases/functions to call scripts) , --output_commands (list found files and their appropriate calls)
function _reload_scriptfiles () {
    local declare_commands output_commands
    [[ "$@" =~ ^"--declare_commands"$ ]] && declare_commands='true'
    [[ "$@" =~ ^"--output_commands"$ ]] && output_commands='true'

    # loading scripts
    local file_names=$(find "$SCRIPTS_PATH" -type f)
    local file_path
    for file_path in $file_names; do  # Loop through the list of files and create a function for each
        local filename="$(basename "$file_path")"
        local function_name=${filename%.*}  # keep the file name but not the ending suffix

        local extension=$([[ "$filename" = *.* ]] && echo "${filename##*.}" || echo 'generic' )  # gets file-type, or default if there's no dot.
        local prefix=$([[ "$function_name" = _* ]] && echo "_${extension}" || echo "${extension}_")
        local cmd_name="${prefix}${function_name}"

        [ -n "$declare_commands" ] && eval "function $cmd_name () { "$file_path" \"\$@\"; }"  # make script callable with optional args
        [ -n "$output_commands" ] && echo "$cmd_name:$file_path"
    done <<< "$file_names"

    # loading cheatsheets
    local chsh_files=$(find "$CHEATSHEETS_PATH" -type f)
    local chsh_file
    for chsh_file in $chsh_files; do
        local filename="$(basename "$chsh_file")"
        local cmd_name="${CHEATSHEET_PREFIX}${filename}"

        [ -n "$declare_commands" ] && eval "function $cmd_name () { commecho -l < $chsh_file; }"
        [ -n "$output_commands" ] && echo "$cmd_name:$chsh_file"
    done
}
_reload_scriptfiles --declare_commands

# used by "remindme" - lists this file's introduced aliases and functions
function _list_script_calls () {
    local commands=$(_reload_scriptfiles --output_commands)
    local cmds_to_text=()
    local name file  # keep iteration vars from polluting your env
    while IFS=: read -r name file; do 
        local documentation
        if [[ "$file" == *.py ]]; then
            documentation=$(sed -n '/"""/, /"""/{ /"""/! { /"""/! p } }' "$file")  # get the documentation between 2 """ strings
        else  # default (no extension)
            local non_comment_line_number="$(grep -n -m 1 -v '^#' "$file" | cut -d ':' -f 1)"  # get number of first line that doesn't start with '#'
            documentation="$(head -n $((non_comment_line_number - 1)) "$file")"  # get all lines until last-found
        fi

        if [ -n "$documentation" ]; then
            documentation=$(paste -s -d ' ' <<< "$documentation" )  # merge into one line
            documentation=$(sed 's/^#[[:space:]]*//' <<< "$documentation" )  # trim leading sharp-comment if it's there
        fi
        cmds_to_text+=("$name  # $documentation")
    done <<< "$commands"

    local item
    local cmd_list=$(for item in "${cmds_to_text[@]}"; do echo "$item"; done | sort )
    echo "${cmd_list[@]}"
}


# displays all cheatsheet commands
# arg1 (optional): word to search within cheatsheets
function cheatsheets () {
    tree --dirsfirst "$CHEATSHEETS_PATH"
    echo
    yecho "Commands:"
    compgen -c | grep --color=never "^$CHEATSHEET_PREFIX"
    
    # TODO - filter with given word, instead of "howdoi" (delete it)
}

# look for keyword in the cheatsheets
alias howdoi='supergrep -d "$CHEATSHEETS_PATH" -e'  # TODO - make the output prettier by outputting the cheatsheets' command-names rather than the actual files?
# Synonymous to "cheatsheets".
alias list_cheatsheets='cheatsheets'

