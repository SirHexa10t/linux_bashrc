#!/bin/bash

# This file calls script files in another location (relative to own location) in definitions that makes them accessible as terminal commands

SCRIPTS_PATH="$CUSTOM_BASHRC_FOLDER/unlimited_script_works"  # name of the folder within this project. Change it if you want, just be aware this could break.

alias _scripts_loaded_comfirmation='_py_confirm_loaded'  # a call to a script added in just to confirm that the rest of the scripts are reached right 

# Reloads script-files into bash-calls. No need to manually call this, it's done automatically
# --declare_commands (create aliases/functions to call scripts) , --output_commands (list found files and their appropriate calls)
function _reload_scriptfiles () {
    local declare_commands='' output_commands=''
    [[ "$@" =~ ^"--declare_commands"$ ]] && declare_commands='true'
    [[ "$@" =~ ^"--output_commands"$ ]] && output_commands='true'

    local file_names=$(ls "$SCRIPTS_PATH")
    # Loop through the list of files and create a function for each
    while IFS= read -r filename; do
        local function_name=${filename%.*}  # keep the file name but not the ending suffix
        local extension=${filename##*.}  # gets file-type or entire filename if there's no file-type
        [[ "$extension" == "$function_name" ]] && extension='generic'  # to avoid having functions for no-extention files named "fooname_fooname", we'll write "generic" as the file-type
        local cmd_name=$([[ "$function_name" = _* ]] && echo "_${extension}${function_name}" || echo "${extension}_${function_name}" )
        local script_file="${SCRIPTS_PATH}/${filename}"
        if [ -n "$declare_commands" ]; then
            # local alias_content="${cmd_name}='${script_file}'"  &&  alias "$alias_content"  # Define through alias instead of function. Aliases are less dynamic (usage of args) and has env-scope issues.

            eval "function $cmd_name () { "$script_file" \"\$@\"; }"  # function with args
        fi

        [ -n "$output_commands" ] && echo "$cmd_name:$script_file"
    done <<< "$file_names"
}
_reload_scriptfiles --declare_commands

# just like "remindme" - lists this file's introduced aliases and functions
function _list_script_calls () {
    local commands=$(_reload_scriptfiles --output_commands)
    local cmds_to_text=()
    local name file  # keep iteration vars from polluting your env
    while IFS=: read -r name file; do 
        local documentation=''
        if [[ "$file" == *.py ]]; then
            documentation=$(sed -n '/"""/, /"""/{ /"""/! { /"""/! p } }' "$file")  # get the documentation between 2 """ strings
            documentation=$(paste -s -d ' ' <<< "$documentation" )  # merge into one line
        fi

        cmds_to_text+=("$name  # $documentation")
    done <<< "$commands"

    local item
    local cmd_list=$(for item in "${cmds_to_text[@]}"; do echo "$item"; done | sort )
    echo "${cmd_list[@]}"
}
