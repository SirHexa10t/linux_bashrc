#!/bin/bash

# This file calls script files in another location (relative to own location) in definitions that makes them accessible as terminal commands

SCRIPTS_FOLDER='unlimited_script_works'  # name of the folder within this project. Change it if you want, just be aware this could break.
SCRIPTS_PATH="$CUSTOM_BASHRC_FOLDER/$SCRIPTS_FOLDER"  # uses argument from custom_bashrc.

CONFIRMATION_CMD='_py_confirm_loaded'  # a call to a script added in just to confirm that the rest of the scripts are reached right 

SCRIPTS_ALIASES_INITIAL=$(_alias_names)
SCRIPTS_FUNCTIONS_INITIAL=$(_function_names)

# Reloads script-files into bash-calls. No need to manually call this, it's done automatically
# --declare_commands (create aliases/functions to call scripts) , --output_commands (list found files and their appropriate calls)
function _reload_scriptfiles () {
    local declare_commands='' output_commands=''
    [[ "$@" =~ ^"--declare_commands"$ ]] && declare_commands='true'
    [[ "$@" =~ ^"--output_commands"$ ]] && output_commands='true'

    local file_names=$(ls "$SCRIPTS_PATH")
    # Loop through the list of files and create a function for each
    while IFS= read -r filename; do
        local function_name=${filename%.*}  # keep the file name but not the ending suffix
        local extension=${filename##*.}  # gets file-type or entire filename if there's no file-type
        [[ "$extension" == "$function_name" ]] && extension='generic'  # to avoid having functions for no-extention files named "fooname_fooname", we'll write "generic" as the file-type
        local cmd_name=$([[ "$function_name" = _* ]] && echo "_${extension}${function_name}" || echo "${extension}_${function_name}" )
        local script_file="${SCRIPTS_PATH}/${filename}"
        if [ -n "$declare_commands" ]; then
            local alias_content="${cmd_name}='${script_file}'"  &&  alias "$alias_content"  # Define through alias instead of function. Though it's less dynamic that way
            # eval "function ${extension}_${function_name} () { "$script_file"; }"  # define as function instead (keep this option in case it'll be needed, remember to add args-addition support)
            # eval "function ${extension}_${function_name} () { "$script_file" \"\$@\"; }"  # with args
        fi

        [ -n "$output_commands" ] && echo "$cmd_name:$script_file"
    done <<< "$file_names"
}
_reload_scriptfiles --declare_commands

# just like "remindme" - lists this file's introduced aliases and functions
function list_script_calls () {
    local commands=$(_reload_scriptfiles --output_commands)
    declare -A cmds_to_text
    local name file  # keep iteration vars from polluting your env
    while IFS=: read -r name file; do 
        local documentation=''
        if [[ "$file" == *.py ]]; then
            documentation=$(sed -n '/"""/, /"""/{ /"""/! { /"""/! p } }' "$file")  # get the documentation between 2 """ strings
            documentation=$(echo "$documentation" | paste -s -d ' ')  # merge into one line
        fi

        cmds_to_text["$name"]="$name  # $documentation"
    done <<< "$commands"

    local cmd_list=$(for key in "${!cmds_to_text[@]}"; do commecho "${cmds_to_text[$key]}"; done | sort )
    
    becho 'new script-aliases:'
    echo "$cmd_list"
    becho 'new script-functions:'
    echo "$SCRIPTS_FILE_FUNCTIONS"
}

# SCRIPTS_FILE_ALIASES="$(_unique_in_first "$(_alias_names)" "$SCRIPTS_ALIASES_INITIAL")"  # get all current aliases
SCRIPTS_FILE_FUNCTIONS="$(_unique_in_first "$(_function_names)" "$SCRIPTS_FUNCTIONS_INITIAL")"  # get all current functions

# output message only if user isn't root
if [[ $EUID -ne 0 ]]; then
    echo $( $(eval "$CONFIRMATION_CMD") && gecho "Successfully loaded" || recho "Failed loading" )\
    "scripts file \"$SCRIPTS_BASHRC_FILE\". To view added script-call commands, run: $(becho list_script_calls)"
fi
