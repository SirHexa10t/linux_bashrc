#!/bin/bash


#---------------------------------------------------------------------------------------------
#----CUSTOM-----------------------------------------------------------------------------------
#---------------------------------------------------------------------------------------------


# Add everything here (see note below) to own user's .bashrc file (or in /etc/bash.bashrc if you want it to be global), then reset your terminal
# Relevant .bashrc files:
#   /etc/bash.bashrc
#   $HOME/.bashrc

# (note) It's more modular (and arguably easier) to just save this file somewhere and refer to it from bashrc.
# To do that, just paste the following 2 lines (uncommented) at the end of your bashrc. Make sure the filename's correct of-course.
#   CUSTOM_BASHRC_FILE="$HOME/custom_bashrc"
#   if [ -e "$CUSTOM_BASHRC_FILE" ]; then source "$CUSTOM_BASHRC_FILE"; fi

# To apply your bashrc to sudo as well, edit the file: /etc/sudoers , and put the following line in it (without the comment):
# Defaults        env_keep += "BASH_FUNC_*"


# please ignore
#################################################################################
_alias_names_query='alias | grep -E "^alias" | sed "s/^alias \([^=]*\)=.*/\1/"'  # this is needed very early for specific lookup


# Session data
#################################################################################
SUDO_FILE=$(which sudo)
THIS_FILE=$(readlink -f -- "$BASH_SOURCE")
IS_USER_ROOT=$(if [ "$USER" == "root" ]; then echo "true"; else echo "false"; fi)

CUSTOM_ALIASES=$(eval "$_alias_names_query")  # will only be ready by the time this file's reading is done
declare -A CUSTOM_ALIASES_MAP  # use this for lookup (will be filled at the end too)
CUSTOM_FUNCTIONS=$(declare -F | awk '{print $3}')  # will only be ready by the time this file's reading is done
declare -A CUSTOM_FUNCTIONS_MAP  # use this for lookup (will be filled at the end too)


# My settings / constants
#################################################################################
QEMU_VOLUME_UUID='A80899A4089971D4'
LOOKING_GLASS_CLIENT="/usr/local/bin/looking-glass-client"

HISTTIMEFORMAT="%Y-%m-%d_%T  "  # makes "history" command display the time the command ran at


# My binds
#################################################################################
# "\C-" is CTRL, "\e" (or "\M-") is alt. Shift might not be supported, but if it is: "\S-" is Shift (and maybe also backslash and capitalize, like this for Shift-X: "\X").
# Flag -x is "execute".
# A personal rule is that things get executed instead of written explicitly only if the user shouldn't care about the command used (i.e. it always makes sense to use just the shortcut)

# before adding a bind, check whether it's already taken, by running "bind -p". You'd generally be overwriting existing binds, but some of them such as CTRL+M cause problems when you overwrite
# To define it only if the shortcut doesn't exist, run a command like this:   if ! bind -q "\C-w"; then bind '"\C-w": "exit\n"'; fi

if [ "$IS_USER_ROOT" = false ]; then  # no binding keys when running as root.

    # Bash terminal related 
    # =====================

    # CTRL+H : basically "help"
    bind -x '"\C-h": "remindme"$\r$\n'

    # ALT+N : refresh bash terminal
    bind '"\en": "exec bash\n"'  # print this, so the user can rerun this easily for function tests

    # CTRL+W : close terminal. Just like in web-browsers
    # bind '"\C-w": "exit\n"'  # should be defined in the OS for all windows

    # CTRL+SHIFT+I : get system info
    # bind -x '"\C-\I": "echo something"$\r$\n'  # TODO


    # Custom environment 
    # ==================

    # CTRL+X : (let's pretend X is for X-Server...) arrange monitors when the nvidia settings won't keep them arranged
    bind -x '"\C-x": "arrange_monitors"$\r$\n'

fi

# My keyword shortcuts
#################################################################################

# aliases work as "command (re)placements", i.e. they'll replace words that are commands but not args


# Basic functionalitiy override !
# ===============================

# TODO - make sudo reload this file silently
# TODO - colored code (comments one color, function/alias name another color, code (for alias) another color)
# TODO - put aliases and functions in "remindme" (and add screenshot to README). Don't put comments with 2 hashes (##)
# TODO - lookup within "remindme" (maybe just add a flag, but then maybe it should be named something else, like "available_cmds")
# TODO - "whatnow" - tag commands (things like "network" or "visual" or "filesystem") and list the tags for (optional) interactive picking 
# TODO - find all "] &&" and see that they operate fine


# This function is needed early, for safe alias replacements.
# Removed (non-purged) packages are considered not-installed
function _is_pkg_installed () {
    is_pkg_installed=$(dpkg-query -W --showformat='${Status}\n' ${1} 2>&1 | grep "install ok installed")
    if [ "${is_pkg_installed}" == "install ok installed" ]; then return 0; else return 1; fi
}

# Returns true if pacakge is installed, false + user-message if not. Provide package name as arg 1.
function _announce_pkg_installed () {
    if _is_pkg_installed "$1" ; then return 0; else echo "Can't use package '$1', consider installing it."; return 1; fi
} 


# The space at the end makes bash auto-complete the next word as well. 'sudo ' alone makes aliases work in sudo, but not functions.
alias sudo='sudo '

# same trick as in sudo
alias man='man '

# replace apt with nala. Same thing but prettier
# conditional alias - only if package is installed
_announce_pkg_installed 'nala' && alias apt='nala'

# rsync copy instead of cp - recursive by default and shows progress percentage
_announce_pkg_installed 'rsync' && alias cp='rsync -ah --info=progress2'


# Common
# ======

# ----- Lookups / Getting-info

# just shorter grep, case insensitive (i), and no regex involved (F)
alias g='grep -iF --color=auto'

# grep, but catches 3 lines before/after (+6 total) match 
alias g3='grep -iF --color=auto -C 3'

# take ownership of file (add file-name after this command) # TODO - maybe make into a function that prints the chowned files (distinguishing the filenames from $@ is difficult though)
alias claim='sudo chown $USER:$USER'

# grepped history
alias hg='history | grep -iF --color=auto'

# TODO - if you ever find out how to put this in a table without messing up filenames with spaces, fix this 
# Custom ls, like "ll". Add -S to sort by (non-recursive) size
alias lll='becho "Blocks Permissions Hard-Links Owner Group Size Date_Modified Filename" ; ls -tarlushFN --color=always --time-style="+%Y-%m-%d_%T" --group-directories-first'

# reset terminal (includs bashrc reload)
alias anew='exec bash'

# Show current network connections to the server through port 80
alias port80="sudo netstat -tulpn | grep :80"

# get own IP
alias whatsmyip='becho "My private IPs:"; ip addr show | grep inet | grep -v inet6 | awk '\''{print $2}'\'' | cut -d/ -f1  ;  becho "My IPv4:" ; dig @resolver4.opendns.com myip.opendns.com +short '

# get addresses on LAN
alias whatsmynetwork="buecho 'LAN devices:' ; arp -a  ;  buecho 'Connections:' ; netstat -atn"

# Get basic hardware and system list
alias sysinfo_short='echo "For simpler neat hardware specs, run \"neofetch\" or \"screenfetch\""; inxi -bD'

# Get comprehensive system/specs details
alias sysinfo_full='inxi -FxxzJy90'

# open window at current terminal directory
alias gui='xdg-open "$(pwd)"'


# Service/Application handling
# ============================

# run docker desktop
alias run_docker_desktop='systemctl --user start docker-desktop'

# TODO - define "sudocker" - run docker desktop as sudo so that it'll find all containers


# System management
# =================

# upgrade your system.
alias updatengrade='sudo apt update && sudo apt-get full-upgrade -y && sudo apt-get autoremove -y'

# rebuild boot parameters using GRUB
alias rebuild_boot='sudo update-grub'

# rebuild RAMFS to apply changes like in modprobe (blacklisting services)
alias rebuild_ramfs='sudo update-initramfs -u'


# Cheatsheets
# =================

# TODO - command grep. "command_like <expression>"

# One of several "help"/"manual" kind of reminders, to help the user get such info without opening the bashrc files.
alias remindme='echo "Find various cheatsheets by typing commands that start with \"howdoi\" or list bashrc options with command \"list_cmds\""'
# Synonymous to "remindme", one of several.
alias what_commands='remindme'
# Synonymous to "remindme", one of several. P.S. it's mispelled intentionally; don't fix it.
alias i_forgor='remindme'

# Reminders for linux system tools and command options
alias howdoi_linux='echo "
>> Packages
* sudo apt install/remove/purge <package>  # package install/remove/remove-including-configs
* sudo gdebi -n <package.deb>  # probably the best way there is to install a .deb file (the -n is for \"no prompt\")
* sudo dpkg -r <package>  # remove a package installed from a .deb file
* sudo dpkg --purge <package>  # purge a package installed from a .deb file
* dpkg-query --list <package>  # print info related to installed package (autocompletes the name), works for all installations including from .deb
* apt list  # list all packages in followed repositories
*   apt list --installed  # list installed packages
*   dpkg -l  # show all installed packages in table format
>> Messing around with the system itself
* reboot  # reboots the system (gracefully)
* sudo systemctl start sshd  # start ssh service for external access
* udisksctl mount --block-device=/dev/<device-name>  # Mount a device the way nemo would. No need for mkdir (and nemo can dismount it right), no harm in calling while unnecessary, automatically uses LABEL to mount at /media/<username>/
*   udisksctl mount --block-device=/dev/<device-name> 2> /dev/null
>> configurations
* /etc/default/grub  :  boot configurations
* /etc/modprobe.d/blacklist.conf  :  blacklist modules, such as firmware
* /etc/fstab  :  mounting configurations, including for dir /
* sudo nvidia-xconfig  # create new xorg config, used by nvidia driver
>> logs (to tail a logfile in real-time run: \"tail -f <logfile>\", or to get last 100 lines: \"tail -100 <logfile>\" )
* log-file: /var/log/boot.log  :  System boot log
* log-file: /var/log/dmesg  :  log for kernel ring buffer
*   dmesg -k | grep -E \"warn|error\"  # the command dmesg displays kernel logs buffer
* log-file: /var/log/kern.log  :  log for kernel ring buffer
"'

# Reminders for user/groups management
alias howdoi_users='echo "
* groups <username>  # display the groups of a user
* usermod -aG <groupA,groupB,groupC> <username>  # add user to group(s). You can even add to group sudo (makes into superuser in Ubuntu).
* getent group  # list all groups and their user-members
* sudo adduser --disabled-password --gecos "" <username>  # adduser is a useradd wrapper (addused is generally better). The --disabled-password and --gecos options are required for no-prompt; gecos fills thumbnail info (cancels interactive). --no-create-home skips homedir creation. --disabled-password skips password creation and disables password login.
*   sudo adduser <username> --gecos "" --disabled-password && echo "<username>:<password>" | sudo chpasswd  # Add user with password in one line. take care to specify the username twice, as needed here
* sudo deluser --remove-home <username>  # delete user and associate homedir
* su - <username>  # Switch to user. Might require sudo.
"'

# Reminders for the basic gimmicks of bash
alias howdoi_bash_terminal='echo "
>> terminal
* man <command>  # read the manual of the command
*   help  # list built-in Bash commands
* less <file>  # Read file with up/down controls. Newer and more convenient than "more".
* sudo !!  # rerun last command with sudo permissions
* htop  # show real-time processes/resource-usage
* xkill  # after you run this, your mouse cursor would turn into an "x" sign, and the next window youll click would be killed. A bit lazy and silly.
* diff <file1> <file2>  # get the text difference between 2 files
* visudo  # edit the /etc/sudoers file (only if you know what you are doing)
>> bash basic utility commands (can be used in terminal of-course)
* declare -p <variable>  # Note: no use of $. Print the variable to check data / data-type
* # add \"& disown\" after a command to have it run in its own thread so that it wont stop when the terminal closes
* # add \"2> /dev/null\" after a command to throw away warning/error messages it might bring up
* time <command>  # get time measurement for command runtime. No need for quotes or any encapsulation, just prepend \"time\". Example: time ls -l
>> tools (utilities for usage that isnt about managing the OS)
* wget <url>  # download files
* curl <url>  # communicate through HTTP(S)/(S)FTP/SCP - make any request (but if you just want to download something, you should probably use wget)
"'

# common media file operations
alias howdoi_media_and_docs='echo "
* pdftk <file1> <file2> <file3> cat output <merged_name.pdf>  # create a unified pdf file 
* xournal <pdf_filepath>  # edit a pdf file with option to add signatures
* ffmpeg -i <input.mp4> -c copy -an <output.mp4>  # get a video copy without the audio
"'

# Reminders for microsoft-format handling tools
alias howdoi_microsoft='echo "
* lnkinfo <lnk-file>  # display link info
* dos2unix <file>  # convert files from windows to unix encoding
* sudo ntfsfix <device> -v  # run check-disk on NTFS device
* ldmtool  #  Read dynamic disks by running \"sudo ldmtool create all\", and then mounting with \"mount -t ntfs /dev/mapper/<volume_name>\"
"'

# Reminders for android-related tools
alias howdoi_android='echo "
* scrcpy  # run daemon that casts the connected Android device screen onto a window, and shares the clicks within it back to the Android device
* scrcpy -r <filename.mp4>  # save a video recording of your connected android device activity (needs USB-Debug and File-Transfer mode)
"'

# Reminders for docker
alias howdoi_network='echo "
>> Own network info
* ip addr  # display own networking interfaces
* sudo netstat -tulpn  # display active network connections and filter by port number
>> Seeking addresses
* dig \"amazon.com\" +short  # resolve dns address (or addresses, in case content-distribution-networks are involved)
* ping google.com  # ping address
>> Firewall and incoming requests
* UFW config-file: /etc/ufw/ufw.conf  :  to monitor incoming requests, set in it: LOGLEVEL=debug , then run \"sudo ufw reload\" (no-interruption reset; if it wont work run: \"sudo service ufw restart\"), and then \"sudo tail -f /var/log/ufw.log\" to monitor
* ufw allow 21115:21119/tcp  # change firewall rules (by ports or src address) - in this case, allow ports 21115 to 21119 (including) on tcp
* sudo tcpdump -i any -n  # capture traffic on all networks for all ports
* sudo tcpdump -i [interface] -n \"src host [external_IP] and dst port [dst_port]\"  # detailed monitoring
*   detailed monitoring example 1:  sudo tcpdump -i enp5s0 -n \"dst port 21118\"
*   detailed monitoring example 2:  sudo tcpdump -i any -n \"tcp and (dst port 21115 or dst port 21116 or dst port 21117 or dst port 21118 or dst port 21119)\"
*   detailed monitoring example 3:  sudo tcpdump -i any src 46.120.97.16 -nn -c 20  # -nn shows ip addresses and port-num without resolving hostname, -c stops capturing after 20 packets
"'

# Reminders for the basics of systemd
alias howdoi_manage_services='echo "
>> Crontab
* crontab -e  # edit routine-scheduled tasks
>> systemd
* /etc/systemd/system/  :   add/remove .service files here
* sudo systemctl daemon-reload  # rescan and reload service files
* sudo systemctl <start/stop/restart/status> <myservice>.service  # manage the state of the service or check its running-status
* sudo systemctl <enable/disable> example.service  # allow/disallow service to run after boot
* journalctl -u <service_name.service>  # check the logs of a systemd service. Can also specify how to view them; example:   journalctl -u ssh --since \"1 hour ago\" --until now -f
"'

# Reminders for docker
alias howdoi_manage_docker='echo "
>> view (might need to run sudo to find all)
* docker ps -a  # list ALL containers
* docker images -a  # list all images
* docker volume ls  # list all volumes
* sudo docker inspect <container_name_or_id>  # view container details 
>> managing container states
* docker-compose -f <yml_file> up  # Start a conteiner using a yaml/yml file. Use -d to make it run in the background
>> removal
* docker system prune -a  # remove all images/containers/volumes/networks. The flag -a also remove unused images
* docker rmi <image(s)>  # remove images ; to remove all images:   docker rmi $(docker images -a -q)
* docker rm <container_id(s)_or_name(s)>  # remove container(s) ; to force-remofe, add -f ; to remove all stopped containers:   docker rm $(docker ps -a -f status=exited -f status=created -q)
* docker volume rm <volume_name(s)>  # remove volume(s)
* docker run --rm <image_name>  # run an image and remove its container when it exits
"'

# Reminders for vm tools and command options (mostly stuff you can't do through Virtual Machine Manager)
alias howdoi_manage_vm='echo "
* systemctl restart libvirtd  # restart the libvirt daemon vm-manager
* virsh start <name>  # start VM
* virsh domrename <old_name> <new_name>  # rename vm
* virsh edit <name>  # modify the xml of a VM (you can do that in Virtual Machine Manager instead)
* sudo virt-sparsify --in-place -v <diskimg.qcow2>  # compress vm disk file
* virsh list --all  # show VM list
* virsh snapshot-create-as --domain <VM-NAME> --name <SNAPSHOT-NAME>  # create snapshot for a vm (has to be turned off)
* virsh snapshot-list --domain <VM-NAME>  # list snapshots of vm
* virsh snapshot-info/snapshot-revert/snapshot-delete --domain <VM-NAME> --snapshotname <SNAPSHOT-NAME>  # detail/go_back_to/delete snapshot
* qemu-img create -f qcow2 -F qcow2 -b <path_to_src_disk.qcow2> <path_to_output_disk.qcow2>  # snapshot a single disk
"'

# Reminders for the basic gimmicks of tmux terminal
alias howdoi_use_tmux='echo "tmux offers split-panes and sessions for terminals.
>> Good for managing a server:
+tmux terminals persist even after disconnection. They keep running until restart the server or send a closure command.
+tmux windows can be named, listed and looked up.
+tmux can accomodate multiple users on the same terminal simultanously; good for assistance/collaboration and for doing jobs that need a \"lock\" (having a channel where certain jobs run, so people would know if someone elses job is underway and should be allowed to finish first)
>> Quick explanation: tmux has sessions. Each session can have various windows, each window (has a number and name) is a \"screen\" thats visible at the moment and has vertically/horizontally added panes 
+For simplicity you can just have a SINGLE SESSION and manage all your windows there. Its easier to navigate windows, thanks to the green bar listing them at the bottom.
+If a window has only need for a SINGLE TERMINAL (lets say the window is called \"grub_config\"), you can keep it simple and avoid adding extra panes. Add panes to multi-faceted things, like a project which has code, git-management, assets, runtime area etc.
> Sessions:
* tmux  # create a new tmux session
* CTRL+B, D  : leave (detach) current session
* tmux ls  # view all existing tmux sessions (+ info about creation date and number of windows)
* tmux rename-session -t <0/1/2/3/.../past_name> <name>  # rename session (using number/name from \"tmux ls\")
* tmux attach -t <0/1/2/3/.../name>  # connect (attach) to an existing tmux session (using number/name from \"tmux ls\")
* tmux kill-session -t <0/1/2/3/.../name>  # kill specified session
> Windows:
* CTRL+B, <0/1/2/3/...>  : go to window number
* CTRL+B, C  :  create a new window
* CTRL+B, ,  :  rename current window
> Panes:
* CTRL+B, %  :  create a new pane to the right
* CTRL+B, \"  :  create a new pane to the bottom
* CTRL+B, <left/right/up/down>  :  move focus to other pane
* exit  # close pane. If last pane, close window.
TODO - create a script thatll establish tmux workspaces when logging into your user (so youd have things ready for debugging or coding and such)
TODO - create functions that run these commands interactively (like listing, then letting the user pick a number, then go there...)
"'

# TODO - cargo (maven-like manager) cheatsheet. Reference: https://www.youtube.com/watch?v=zF34dRivLOw

# Reminders for some neat time-saving GUI keybind tricks
alias howdoi_shortcut='echo "
* Terminal CTRL+L : clear screen
* Built-in Nemo [space] :  select (click) a file/folder, and press [space] to get a summary/preview; press again to close
* Custom Gnome-Nemo CTRL+SHIT+T :  open Terminal at current Nemo location
* Built-in Gnome CTRL+ALT+T :  open Terminal
* Built-in Gnome(?) CTRL+ALT+[backspace] :  log out of current session (resets your GUI)
* Built-in Debian(?) CTRL+ALT+F1 :  enter TTY mode (terminal without anything graphic to lock/interrupt you)
* Built-in Debian(?) CTRL+ALT+F7 :  exit TTY mode
* Evded installation LCTRL+RCTRL  :  switch mouse and keyboard (and maybe other things) between guest/host. Wont work if you gave the VM your USB device directly.
"'


# function aliases (alternate names)
# ==================================


# Custom
# ======

alias arrange_monitors='nvidia-settings --load-config-only && nvidia-settings --assign CurrentMetaMode="HDMI-0: nvidia-auto-select +1920+1080, DP-0: nvidia-auto-select +1920+0, DP-2: nvidia-auto-select +3840+1080, DP-4: 1920x1080_240 +0+1080"'


# Legacy
# ======

# # Aliases for safe and forced reboots
# alias rebootsafe='sudo shutdown -r now'
# alias rebootforce='sudo shutdown -r -n now'






# My functions
#################################################################################

# TODO - a "checksum" function that gets both file to checksum and the checksum-result file, determines which is which, runs the appropriate checksum on the file and compares with the result file; prints the match result 

# Common commands - just for the use of other functions
# =====================================================

# Attempt to run command. If it fail, run with sudo. Don't provide a multi-part (pipe-inclusive) command.
function _sudo_if_necessary () {
    [ $# -ge 1 ] || { recho "WTF are you expecting me to sudo? Give me a command-string as argument" ; return ; }

    normal_output=$(eval "$@" 2>/dev/null)
    [ $? -ne 0 ] && eval "sudo $@" || echo "$normal_output"
}

function _count_lines () {
    echo "$1" | wc -l
}

# useful for drawings or neat concatenating of tables like so: 'paste <(_pad_end_w_spaces "$(df -h)") <(_pad_end_w_spaces "$(df -hi)") <(_pad_end_w_spaces "$(df -hi)")'
# add spaces to the end of lines so that the block of text would be a rectangle; i.e. end uniformly on the same column. Use like so:  _pad_end_w_spaces "$(lsblk)"  or   lsblk | _pad_end_w_spaces
# DOES NOT work on color-coded text! The color info adds in as extra characters and makes the text look uneven!
function _pad_end_w_spaces() {
    text="$1"  # assume that text is provided as an argument
    if [ -z "$text" ] && ! [ -t 0 ]; then text=$(cat); fi  # if no text given and there's a stream from a pipe, get the stream contents as text
    awk '{hi[NR]=$0; max_len=length($0) > max_len ? length($0) : max_len} END {for (line in hi) { printf "%s%*s\n", hi[line], max_len-length(hi[line]), "" }}' <<< "$text"
}

# TODO - unused, so remove?
# get device name such as "/dev/sda2". You must provide one argument: the UUID of the device.
function _get_dev_name_from_uuid () {
    [ $# -ge 1 ] || { echo "You need to provide UUID as an argument" ; return ; }
    blkid | grep "UUID=\"$1\"" | awk -F: '{print $1}'
}

# adds y/n prompt. Call like this:  if prompt_yn "are you sure you want to do that?"; then echo "alright..."; else echo "then lets call it off" && return ; fi
function _prompt_yn() {   
    response=""
    # keep prompting the user until they provide a valid response
    while [ "$response" != "y" ] && [ "$response" != "n" ]; do
        # prompt the user for a yes/no response
        read -p "$1 [Y/n] " response
        case "$response" in
            y|Y ) return 0 ;;  # if the response is "y", return a boolean value indicating success
            n|N ) return 1 ;;  # if the response is "n", return a boolean value indicating failure
            *) echo "just type y or n" ;;  # if the response is anything else, print an error message and continue prompting
        esac
    done
}

# wait $1 seconds, print a dot for each second passed.
function _wait_n_seconds () {
    printf "Waiting $1 seconds"
    for ((i=0; i<$1; i++))
    do
        printf "."  # Print a dot and flush the output to ensure that it is printed immediately
        sleep 1
    done

    printf "\n" # Print a newline after the dots
}



# Basic functionalities override !
# ================================

# Sources this file if the command is a function from this page.
## I don't know what black magic is involved, but you need both the above sudo alias and this function to support alias interpretation.
function sudo () {
    # needs to be "silent" to avoid screwing up scripts that rely on the output of the sudo'd commands
    # if arg 1 (just arg 1, deal with it) is in the list of this file's functions, source this file. Otherwise, run sudo regularly.
    if [ -n "${CUSTOM_FUNCTIONS_MAP[$1]}" ]; then
        custom_function_cmd="source $THIS_FILE && $@"
        "$SUDO_FILE" bash -c "$custom_function_cmd"
    else
        "$SUDO_FILE" "$@"
    fi
}

# TODO - do about the same for chmod and chown - print the directory/files with the changed data (maybe cancel that, getting the filenames in every case isn't simple)
# add a print of local files after changing directory
function cd () {
    builtin cd "$@" && \
        ls -AF --color=always --group-directories-first 
}

# make mkdir more "reasonable" with a flag that is always nice to have ; -p doesn't print error if dir exists
function mkdir () {
    [[ $* == *-p* ]] && extra_flag="" || extra_flag="-p"  # if flag not present, store it in var 
    /usr/bin/mkdir "$extra_flag" "$@"
}

# make date output in a specific format by default
function date () {
    args=$([ $# == 0 ] && echo "+%Y-%m-%d_%T" || echo "$@")  # if provided 0 args, set the time-format to own preference
    /usr/bin/date "$args"
}


# Basic functionalities
# =====================

# man grep - find word in manual, with a bit of context (lines above/below). $1 is command (to manual), $2 is word to find
function mang () {
    man "$1" | grep -iF --color=auto -C 3 -- "$2"  # the "--" allows you to lookup dashes in your expression
}

# Find processes by substring. Prints error if given no args ; prints everything if given empty string
function find_proc () {
    [ $# -ge 1 ] || { recho "No substring provided to look through with." ; return ; }

    ps -eo pid,ppid,user,%cpu,%mem,stat,start,time,cmd --sort=-%cpu | awk -v search="$1" 'BEGIN{IGNORECASE=1} NR==1 || $0 ~ search {print}' \
    | _color_word --word "$1"  # color the sought term
}

# kill processes by substring; get process-specifications and confirmation prompt
function kill_interactively () {
    [ $# -ge 1 ] || { recho "You need to provide a substring to find (and later kill) processes with." ; return ; }
    
    pids=$(pgrep -i "$1")  # get all PIDs
    [ -z "$pids" ] && becho "no processes found" && return 0;
    pids_commas=$(echo "$pids" | tr '\n' ',' | sed 's/,$//')  # save PIDs with comma-separation (for listing)
    pids_spaces=$(echo "$pids_commas" | tr ',' ' ')  # save PIDs with space-separation (for killing)
    proc_info=$(ps -p "$pids_commas" -o pid,ppid,user,%cpu,%mem,stat,start,time,cmd --sort=-%cpu)

    prompt="$(echo "$proc_info" ; recho "The listed processes will be killed. Are you sure?")"
    if _prompt_yn "$prompt"; then _sudo_if_necessary kill ${pids_spaces} ; else echo "Quitting." && return ; fi

    _wait_n_seconds 2

    pids=$(pgrep -i "$1")  # get all PIDs, again
    [ -z "$pids" ] && becho "Confirmed no new processes with same substring" || recho "Found live processes with the same name you just eliminated"
}


# Maintenance and Update Operations
# =================================

function install_deb_from_url () {
    pkg_name=$(echo "$1" | awk -F/ '{print $NF}')  # get the string after last '/'
    installation_msg="Installed debian (.deb) package: $pkg_name. If you want to remove it, run: 'sudo dpkg -r $pkg_name'"
    wget "$1" && sudo gdebi -n "./$pkg_name" && echo "$installation_msg"  # download and install
    rm "$pkg_name"  # remove .deb file
}

function add_to_path () {
    # check if given arg is already in PATH
    if [[ $PATH == *$1* ]]; then
        echo "$1 is already in PATH!"
        return
    fi
    export PATH=$PATH:$1
	# change the line where "PATH=" appears
    sudo sed -i "/PATH=/c\PATH=$PATH" /etc/environment
    printf "From now on:\n`sudo cat /etc/environment`\n"
}

# don't worry about calling this when the device is already mounted, it won't do harm.
function mount_media_by_uuid () {
    udisksctl mount -b "/dev/disk/by-uuid/$1"  # add -t <mountpoint>  to change mount-location
}

function all_crontabs () {
    cat /etc/passwd | awk -F: '{ print $1; }' \
    | while read user; do
            crontab -u $user -l 2>/dev/null | grep "^[^#*/;]" | awk '{
                    print "'$user': "$0;
            }';
    done
    
    sudo crontab -u root -l 2>/dev/null | grep "^[^#*/;]" | awk '{ print "root: "$0; }';

}


# Archive a file locally into .tar.7z format. Provide filename as arg 1
function archive_tar7z () {
    [ $# -ge 1 ] || { recho "You need to tell me what to archive" ; return 1; }
    [ -e "$1" ] || { recho "This file doesn't exist!" ; return 1; }
    # TODO - get rid of last '/' if it exists
    # TODO - check full addresses' effect
    # TODO - check with sudo
    
    tar -cvzf - "$1" | 7za a -si "$1".tar.7z
}

# finds files that shouldnt be executable and chmods them
function revoke_exe_mod () {
    location=${1:-.}  # use given address, default to current location
    format=${2:-'txt'}  # use given format, default to txt
    files=$(find "$location" -type f -name "*.$format")  # get txt (or specified) files recursively
    while read -r file; do
        # if file is executable
        if [ -x "$file" ]; then
            # revoke exe permission (run as sudo IF necessary)
            _sudo_if_necessary "chmod -x \"$file\"" && echo "file no longer executable: $file"
        fi
    done <<< "$files"
}


# ----- Microsoft handling 

# fix mount as read-only issue caused by Windows leaving some garbage on the disk
function prepare_ntfs_for_writable_mount () {
    lsblk -o UUID,NAME,FSTYPE,LABEL | awk 'NR==1 || $3 == "ntfs"'

    read -p "Choose a UUID to fix (with chkdsk) from the above device-list: " uuid  # Read the user's input
    
    lsblk -o UUID,NAME,FSTYPE,LABEL | awk -v uuid="$uuid" 'NR==1 || $1 == uuid'
    if _prompt_yn "Are you sure this is the right device?"; then echo "Running. Don't touch the device until we're done..."; else echo "Quitting." && return ; fi

    # unmount if necessary
    if findmnt -o UUID | grep "$uuid" > /dev/null; then umount -l "/dev/disk/by-uuid/${uuid}"; fi

    # fix ntfs device
    sudo ntfsfix -b "/dev/disk/by-uuid/$uuid"
}


# TODO
# function reinstall() { : 'performs remove and then install'
#     if [] then;
#     sudo apt remove "$1" -y && sudo apt install "$1" -y
#     fi
#     else
#     echo "package $1 isn't even installed"
# }


# Debug and Check Operations
# ==========================

# Writes data to volume, to check its capacity. Careful not to give this function the wrong path!!!
function check_drive_volume () {
    if [ -z "$1" ]; then echo "You didn't provide a drive-name (run lsblk if you're not sure. Should be like '/dev/sdg' ). Aborting." && return 1 ; fi
    
    if _prompt_yn "Your data on $1 is about to be destroyed. Are you sure?"; then echo "Running. Don't remove the device."; else echo "Aborting." && return 1 ; fi
    sudo f3probe --destructive --time-ops "$1"
}



# Info: Stats
# ===========

# get comprehensive overview of devices/volumes
function devs() {
    # df results (mounted volumes)
    df_results=$(df -h -x tmpfs --output=source,fstype,itotal,ipcent,size,pcent,file,target)
    df_title=$(echo "$df_results" | head -n1)
    df_content=$(echo "$df_results" | tail -n+2 | sort -k1,1)
    df_results=$(echo -e "${df_title}\n${df_content}" | _pad_end_w_spaces)  # reattaching (now the contents are sorted), and ending lines neatly

    # device names (used as identifiers)
    df_devices=$(echo "$df_content" | awk 'NR>1 {print $1}')
    lsblk_devices=$(lsblk -o PATH | tail -n+2 | sort)

    # lsblk minus df results
    # ----------------------
    unmounted_devices=$(comm -23 <(echo "$lsblk_devices") <(echo "$df_devices"))  # devices in lsblk but not df
    lsblk_unmounted=$(lsblk -d $(paste -sd ' ' <<< "$unmounted_devices") -o PATH,MODE,FSTYPE,SIZE,LABEL,TYPE,PTTYPE,MODEL,STATE --sort PATH) 
    
    # df results + extra data for same entries
    # ----------------------------------------
    lsblk_complementary_to_df=$(lsblk -d $(paste -sd ' ' <<< "$df_devices") -o MODE,LABEL,TYPE,PTTYPE,MODEL,STATE,PATH --sort PATH)  # same devices as in df, different columns
    # map the extra data in lsblk to "PATH", which is the same as lsblk's "Filesystem"
    declare -A lsblk_hashmap
    while read -r line; do
        key="${line##* }"
        value="${line% *}"
        lsblk_hashmap["$key"]="$value"
    done <<< "$lsblk_complementary_to_df"
    lsblk_hashmap['Filesystem']=${lsblk_hashmap['PATH']}
    
    # place the maps right after the df results
    df_and_lsblk=()
    while IFS= read -r line || [[ -n "$line" ]]; do
        dev_name=$(echo $line | awk '{print $1}')
        modified_line="$line ${lsblk_hashmap[$dev_name]}"
        df_and_lsblk+=("$modified_line")
    done <<< "$df_results"
    
    
    # print results
    becho 'mounted volumes:'  # results from df with extra details on the same entries from lsblk
    for i in "${df_and_lsblk[@]}"; do echo "$i" ; done

    becho 'non-mounted volumes:'
    echo "$lsblk_unmounted"

    becho 'identifiers and metadata:'
    lsblk -a -o NAME,MOUNTPOINT,LABEL,UUID,PTUUID,PARTUUID,SERIAL | awk 'NR==1 || ($1 !~ "loop[0-9]")'
}


# list password-owning users with uid >= 1000. Specify uid limit with --max_uid <number>  ; only count users with home-dir with --require_home 
function list_human_users() {
    # defaults
    max_uid_filter=''  # no extra filtering
    require_home='false'
    while [[ $# -gt 0 ]]; do
    	case "$1" in
            '--max_uid')
    			max_uid_filter="&& \$3 <= $2"
    			shift 2
    			continue
    		;;
            '--require_home')
    			require_home='true'
    			shift 1
    			continue
    		;;
            *)
                recho "${FUNCNAME[0]} doesn't know how to handle arg: '$1'"
    			shift
    		;;
        esac
    done

    users=$(getent passwd | awk -F: '$3 >= 1000 '"$max_uid_filter"' {print $1}')  # get all users with uid >= 1000, maybe with a limit (because uid increments by 1)
    for user in $users; do      
      if [ "$require_home" == 'false'  ] || [ -d "/home/$user" ]; then  # if homedir isn't required, or if it is and it does exist
          echo $user
      fi
    done
    echo "root"  # always assume root might be humanly-used somewhere
}


# get a list of users and their resource-usage stats. Flags are --gpu : display gpu data too  ;  --not_sudo : don't ask for sudo password for checking other users' @HOME dir size
function resources_used () {
    maybe_sudo=$([[ " $* " =~ " --not_sudo " ]] && echo "" || echo "_sudo_if_necessary")  # if flagged, run regularly as non-superuser. If not, try inputting password in case it's necessary

    thread_count=$(nproc)
    bottleneck_threshold=$(echo "scale=3; 100/$thread_count" | bc -l)

    # human-users lookup    
    human_users=$(list_human_users --max_uid 2000)
    declare -A h_users && for user in $human_users; do h_users[$user]='1'; done  # same, as hashset

    current_users=$(ps -eo user= | sort | uniq)  # all current users running on the system
    declare -A c_users && for user in $current_users; do c_users[$user]='1'; done  # same, as hashset

    all_users=$(echo -e "$current_users\n$human_users" | sort | uniq)  # all users (joined list but kept only unique)
    headers='USER,CPU,RAM,@HOME-size'
    usage_summary=''
    for user in $all_users; do
        # determine if the line would be printed in color
        prnt_cmd=$([ -n "${h_users[$user]}" ] && echo "gecho" || echo "echo")  # ternary for choice of command to use
        # CPU usage%, "-" if not in "current_users" (users in process list)
        cpu_usage=$([ -n "${c_users[$user]}" ] && echo $(ps -u $user -o %cpu,%pid | awk '{cpu+=$1} END {printf "%.2f%%\n", cpu/'$thread_count'}') || echo "-")  # user's CPU usage. Divided by num of threads because a ps line with 100% is just 100% single-thread, not 100% on all cores
        # RAM usage%, "-" if not in "current_users" (users in process list)
        mem_usage=$([ -n "${c_users[$user]}" ] && echo $(ps -u $user -o %mem= | awk '{mem+=$1} END {print mem"%"}') || echo "-")  # user's RAM usage
        # Disk usage of user's home-dir. "-" if home-dir doesn't exist
        disk_usage=$([ -d "/home/$user" ] && echo $($maybe_sudo du -sh "/home/$user" | cut -f1) || echo "-")  # specify home-dir disk usage (if applicable)

        current_user_usage=$($prnt_cmd "$user\t$cpu_usage\t$mem_usage\t$disk_usage")  # data display format, including the optional coloring
        usage_summary="$usage_summary\n$current_user_usage"
    done

    # get cpu stat directly from /proc/stat , without the rounding errors in "top" ; line from https://stackoverflow.com/questions/9229333/how-to-get-overall-cpu-usage-e-g-57-on-linux
    total_cpu_usage=$(awk '{u=$2+$4; t=$2+$4+$5; if (NR==1){u1=u; t1=t;} else print ($2+$4-u1) * 100 / (t-t1) "%"; }' <(grep 'cpu ' /proc/stat) <(sleep 1;grep 'cpu ' /proc/stat))
        # total_cpu_usage=$(cat <(grep 'cpu ' /proc/stat) <(sleep 1 && grep 'cpu ' /proc/stat) | awk -v RS="" '{print ($13-$2+$15-$4)*100/($13-$2+$15-$4+$16-$5)}')  # also works
    total_ram_usage=$(free -h | awk '/^Mem:/ {print $3 "(+" $6 " buff/cache) / " $2}')
    total_disk_usage=$(df -h / --output=used,size,iused,itotal | tail -n+2 | awk '{ print $1 " / " $2 " ("$3 " / " $4" inodes)"}')

    echo "Computing units count: $(becho $thread_count)"
    echo "If your overall CPU usage reaches $(becho $bottleneck_threshold%), your CPU is possibly bottlenecked on a single thread."

    echo "$(uecho 'Resources currently taken by users:') *verified human users are colored **results are subject to slight shifts over runtime, partially due to this very script's running."
    echo -e "$usage_summary" | column -t -s $'\t' -N "$headers"

    echo "$(uecho 'Total CPU usage:') $total_cpu_usage"
    echo "$(uecho 'Total RAM usage:') $total_ram_usage"
    echo "$(uecho 'Total Disk usage:') $total_disk_usage  *For '/' only. Run devs function to see more."  
    # TODO - check if there is a GPU at all, and support AMD (or Intel) drivers (need to detect)
    [[ " $* " =~ " --gpu " ]] && ( uecho "GPU utilization info:" ; nvidia-smi -q -d MEMORY,COMPUTE,UTILIZATION ) # if flag --gpu is specified
    
}


# search network activity by port (number) or substring
function network_search () {
    if [ -z "$1" ]; then echo "You didn't provide anything to filter by. Aborting." && return 1 ; fi
    
    if [[ $1 =~ ^[0-9]+$ ]]; then  # numerical - filter as a port number
        sudo netstat -tulpn | grep ":$1"
    else  # non-numerical, look-up as a substring
        sudo netstat | grep -iF --color=auto "$1"
    fi
}

# Reports all local files size and inner-files count. Sortable by size with "-s"
function explore () {
    location=${1:-.}  # use given address, default to current location
    location=$(readlink -f "$location")  # use absolute path (and use no '/' at the end)

    folders=""
    files=""
    total_files=0  # Files (recursive) counter. Can technically just recount current dir, but the results might not be cached

    filenames=$(find "$location" -maxdepth 1 -type f,d,l)  # get files (files, dirs, links) in given dir
    filenames=$(echo "$filenames" | grep -vw "^$location$")  # throw out the given location (exact match from line start to end)

    [ -z "${filenames}" ] && return 1  # nothing to iterate over

    while IFS= read -r filename; do
        size=$(du -sh "$filename" | cut -f1)  # determine size (same command for files/folders)
        inodes=$(du -s --inodes "$filename" | cut -f1)
        count=$(find "$filename" -type f,l | wc -l)  # count files and links found. It's just '1' for a file, but the code's shorter this way
        total_files=$(($total_files + $count))

        # handle as dir or file
        if [ -d "$filename" ]; then folders+="$size\t$count\t$inodes\t$filename/\n";
        else files+="$size\t$count\t$inodes\t$filename\n";
        fi
    done <<< "$filenames"

    data="${folders[@]}${files[@]}"    
    [[ " $* " =~ " -s " ]] && data=$(echo -e "${data}" | sort -h)  # if flag -s specified, sort ; first datum is size, so that's what we sort by
    echo -e "${data}" | column -t -s $'\t' -N $(becho "total_size,file_count,inodes,name")  # separate nicely with tabs
    echo "current dir total files: $total_files"
    echo "current dir total size: $(du -sh "$location" | cut -f1)"
    echo "current dir inodes use: $(du -s --inodes "$location" | cut -f1)"
}


# Info: Lookup
# ============

# case-insensitive lookup on all files in dir (and subdirs). -d: dir (default is ".") , -e: expression , --allow_text_dumps (optional). or just put <expression> to look locally
function supergrep () {
    [ $# -ge 1 ] || { echo "You must provide at least one argument, for the lookup-expression" ; return ; }
    # we have a text-length limit to skip gibbrish and text-dumps. It's allowed over 4k, since that's the minimum file-path length.
    text_limit_default='5000'
    first_free_arg_is_exp=''
    dir='.' ; exp=''; text_limit="$text_limit_default"; verbose=''  # defaults, and clearing (in case they're set)
    while [[ $# -gt 0 ]]; do
    	case "$1" in
    		'-d'|'--directory')
    			dir="$2"
    			shift 2
    			continue
    		;;
    		'-e'|'--expression')
    			exp="$2"
    			shift 2
    			continue
            ;;
            '-t'|'--text_limit')
                text_limit="$2"
                shift 2
                continue
            ;;
            '-s'|'--text_limit_short')
                text_limit="500"
                shift
                continue
            ;;
            '-m'|'--text_limit_medium')
                text_limit="5000"
                shift
                continue
            ;;
            '-u'|'--text_limit_unlimited')
                text_limit="-1"
                shift
                continue
            ;;
            '-v'|'--verbose')
                verbose='true'
                shift
                continue
            ;;
            '--help')
                echo -e "bashrc function \"${FUNCNAME[0]}\"
Summary: Grep all files and filenames at a location, recursively. Case-insensitive.
example: supergrep 'to do'
example2: supergrep -d /etc/systemd/ -e restart -v -u 
args:
    -d|--directory <dir_path>\t set the search-dir
    -e|--expression <exp>\t set the search term. You can also set it without a flag
    -t|--text_limit <number>\t set the lext-length limit of lines found. Default is $text_limit_default
        -s|--text_limit_short\t set the lext-length limit of lines found to 500. Equivalent to: -t 500
        -m|--text_limit_medium\t set the lext-length limit of lines found to 5000. Equivalent to: -t 5000
        -u|--text_limit_unlimited\t do not set lext-length limit of lines found. Equivalent to: -t -1
    -v|--verbose\t run in debug mode
    --help\t print this message
"
                return
            ;;
    		*)
                if [ -z "$first_arg_used_as_exp" ]; then
                    first_free_arg_is_exp='true'
                    exp=$1
                else
                    recho "${FUNCNAME[0]} doesn't know how to handle arg: '$1'"
                fi
    			shift
    		;;
    	esac
    done

    [ -z "$exp" ] && echo "No expression specified. Use -e <expression> to set it." && return 1
    
    [ -n "$verbose" ] && becho "running on directory: $dir  ;  expression: $exp  ;  including strings up to length: $text_limit"  # print found arguments (if verbose)

    becho "matching filenames:"
    becho "==================="
    _sudo_if_necessary "find \"$dir\" -iname \"*$exp*\"" | _color_word --word "$exp"

    becho "matching file contents:"
    becho "======================="
    all_results=$(_sudo_if_necessary "grep -e \"$exp\" -Inir \"$dir\" --color=never")  # No colors. Coloring is done at this stage because otherwise it'll add to the string's length
    if [ $(expr "$text_limit" + 0) -gt 0 ]; then  # if there's a limit for result length
        [ -n "$verbose" ] && becho "filtering with maximum result length: $text_limit" 
        all_results=$(echo "$all_results" | awk "length(\$0) <= $text_limit")
    fi
    echo "$all_results" | _color_word --word "$exp"  # print with no filtering by length
}



# Interactive launchers/creators
# ==============================

#TODO - offer to choose a vm by number [1-n]. Need to create a function like y_n one that gets a dicitonary as an argument 
function launch_vm_w_lookingglass() {
    valid=0
    while [ $valid -eq 0 ]
    do
        vm_names=$(virsh list --all --name)
        becho "Choose the name of the VM you want to launch:"
        virsh list --all
        becho "============================================"

        read -p "Enter the name of the VM: " vm_name  # Read the user's input
        if echo $(virsh list --all --name) | grep -w -q "$vm_name"; then  # match whole word (case sensitive), quietly
            valid=1
        else
            recho "Invalid VM name"
        fi
    done

    # look up info within the vm's definitions file
    xml_file="/etc/libvirt/qemu/${vm_name}.xml"

    # get the shmem name:
    shmem_name=$(sudo awk -F 'name=' '/shmem/ {gsub("'\''", "", $2); print $2}' "$xml_file" | sed 's/^"\([^"]*\)".*/\1/' | sed 's/>$//')  # extract the string between the quotes, remove the quotes, remove the closing '>'
    lg_file="/dev/shm/$shmem_name"

    # get the vnc port number from xml
    portnum=$(sudo grep -oP "<graphics type=[\"']spice[\"'] port=[\"']\K\d+" "$xml_file")  # works for either single or double quotes
    portnum=${portnum:=5900}  # default if empty

    # Show user the parameters and ask for approval (quit if disapproved)
    becho "Please authorize the following. Note: no two running VMs may have the same looking-glass session-file or VNC-port at the same time"
    if _prompt_yn "VM: $vm_name, looking-glass_name: $shmem_name, VNC-port: $portnum. Launch with these parameters?"; then echo "Starting..."; else echo "Quitting. If the details were off, modify your VM's xml file (easiest through VM Manager)" && return ; fi

    becho "Making sure os-virtual-drive file's volume is mounted"
    mount_media_by_uuid "$QEMU_VOLUME_UUID"

    becho "Creating looking-glass session file: $lg_file"
    sudo touch "$lg_file" && sudo chown $(whoami):kvm "$lg_file" && sudo chmod 660 "$lg_file"
    [ -f "$lg_file" ] && ls -alF "$lg_file"  # todo - print colored (green?)?
    
    # run the vm (if needed)
    vm_state=$(virsh domstate "$vm_name")
    if [ "$vm_state" == "running" ]; then
        gecho "$vm_name is already running."
    elif [ "$vm_state" == "shut off" ]; then
        virsh start "$vm_name" && gecho "starting $vm_name"
    elif [ "$vm_state" == "paused" ]; then
        virsh resume "$vm_name" && gecho "resuming $vm_name"
    else
        recho "Can't handle VM state: $vm_state"
        if [ "$vm_state" == "blocked" ]; then recho "the VM '$vm_name' is blocked on resource";
        elif [ "$vm_state" == "shutdown" ]; then recho "$vm_name is still shutting down";
        elif [ "$vm_state" == "crashed" ]; then recho "the VM '$vm_name' has crashed";
        elif [ "$vm_state" == "pmsuspended" ]; then recho "the VM '$vm_name' is in a suspended state as a result of power management";
        else recho "Error: VM state isn't defined (fix this function)"
        fi
        return 1
    fi
    
    # run looking glass client
    # experimental -S : Prevent the screensaver from starting  , win:size=1920x1080 : Initial window size at startup (default is 1024x768)
    becho "Starting looking-glass client"
    "$LOOKING_GLASS_CLIENT" -f "$lg_file" -p $portnum -k -S & disown # -k : enable FPS & UPS display  ; -S : prevent host going to sleep

}

function create_systemd_service () {
    read -p "Choose the name of your service: " service_name  # Read the user's input
    service_name=${service_name%.service}  # remove the '.service' if it's there
    file_name="${service_name}.service"
    service_file="/etc/systemd/system/${file_name}"
    [ -s "$service_file" ] && is_empty='NON-empty file - CONTENTS WILL BE DELETED' || is_empty='empty file'
    if _prompt_yn "You'll modify as sudoer: $service_file ($is_empty). Are you ready?"; then echo "Creating file..."; else echo "Come back when you have everything you need." && return ; fi
    
    # provide a template
    if _prompt_yn "Need a template?"; then
        read -r -d '' initial_str << EOT
[Unit]
# rewrite this (don't worry about spaces)
Description=<Insert purpose here>
; Before=<what this service should preceed, e.g. "network.target">
; After=<what should run before this service, e.g. "somethingelse.service">

# should dependencies be inherited by unit's After/Before/Conflicts/BindsTo/PartOf/Wants directives?
; DefaultDependencies=yes/no  

[Service]
# you may want a different user.
User=root
; WorkingDirectory=<path to run at, maybe a project-dir>
ExecStart=<command that starts the service>

# no: The service should not be restarted. This is the default value.
# on-success: The service should be restarted when it exits successfully.
# on-failure: The service should be restarted when it exits with a non-zero exit code or when it terminates abnormally.
# on-abnormal: The service should be restarted when it terminates abnormally.
# on-abort: The service should be restarted when it is terminated by a signal.
# always: The service should be restarted regardless of the exit code or termination status.
; Restart=no/on-success/on-failure/on-abnormal/on-abort/always

# simple: The service is a simple service that runs a single command or process. This is the default value.
# forking: The service is a forking service that creates a new process group when it starts. This type of service is typically used for programs that fork and background themselves when they start.
# oneshot: The service is a one-shot service that runs a command or script and then exits. This type of service is typically used for tasks that need to be performed once and then stopped.
# dbus: The service is a D-Bus service that exports objects over the D-Bus message bus. This type of service is typically used for services that communicate over D-Bus.
# notify: The service is a notify service that sends a notification when it is ready. This type of service is typically used for services that need to signal their readiness to other services or clients.
; Type=simple/forking/oneshot/dbus/notify


[Install]
# who should automatically start this service. multi-user.target is common, it's the state in which multiple users can log in
; WantedBy=multi-user.target  
EOT
    # offer template adjustment
    if _prompt_yn "Include guiding comments in the template?"; then echo "Leaving in comments."; else initial_str=$(grep -v "^#" <<< "$initial_str") ; fi
    else 
        initial_str='';
    fi

    # insert template into the file (create/clear file if necessary)
    sudo sh -c "echo \"$initial_str\" > \"$service_file\""

    # let the user determine the contents of the service
    sudo nano "$service_file"

    if _prompt_yn "We're done. Want me to rescan, run and enable the service after boot?"; then
        echo 'reloading systemd...'
        sudo systemctl daemon-reload
    
        echo 'enabling after boot...'
        sudo systemctl enable "$file_name"

        echo 'starting service...'
        sudo systemctl start "$file_name"

        _wait_n_seconds '3'

        echo "Here's its status now:"
        sudo systemctl status "$file_name"
    fi

}


# Visuals
# =======
function _repeat_space_n_times () {
    printf "%${1}s" | tr ' ' " "
}
function _underline () {
    char=${2:-'-'}  # determine which char to repeat in underline
    input_string_length=${#1}
    
    line=$(printf "%${input_string_length}s" | tr ' ' "$char")  # Create a line of the specified character with the same length as the input string

    echo "$1"
    echo "$line"
}

# returns the given text with coloration of a word (case-insensitive). You can pipe the text into it.
function _color_word () {
    text='' ; word='' ; color='<=bold=><=red=>'
    while [[ $# -gt 0 ]]; do
    	case "$1" in
    		'-t'|'--text')
    			text="$2"
    			shift 2
    			continue
    		;;
    		'-w'|'--word')
    			word="$2"
    			shift 2
    			continue
            ;;
            '-c'|'--color')
                color="$2"
                shift 2
                continue
            ;;
    		*)
                return  # received undefined argument
    		;;
    	esac
    done

    # If text is not provided via --text, and if standard input (piped data) exists : assign standard input to text
    if [ -z "$text" ] && ! [ -t 0 ]; then text=$(cat); fi

    [ -z "$text" ] && return 1  # no text given
    [ -z "$word" ] && echo "$text" && return # no word

    # insert tags around word, I makes it case-insensitive
    _draw_formatted "$(echo "$text" | sed -e "s/$word/$color&<=reset=>/gI")"
}

# TODO - detect if the terminal is bright instead of dark? If it's white, the colored prints should be darker; so you should remove the "\033[1m" prefix
# echo in color, use like this: _colored_echo "<=uline=><=red=>" "color me"  # recolors red and underlined
function _colored_echo () {
    # apply colors (arg 1) to all lines
    formatted=$( echo -e "${@:2}" | while read -r line; do echo "${1}${line}"; done )
    _draw_formatted "$formatted"
}
# echo in red
function recho () {
    _colored_echo '<=bold=><=red=>' "${@}"
}
# echo in green
function gecho () {
    _colored_echo '<=bold=><=green=>' "${@}"
}
# echo in blue
function becho () {
	_colored_echo '<=bold=><=blue=>' "${@}"
}
# echo in yellow
function yecho () {
	_colored_echo '<=bold=><=yellow=>' "${@}"
}
# underlined echo
function uecho () {
    _colored_echo '<=bold=><=uline=>' "${@}"
}
# underlined echo in red
function ruecho () {
    _colored_echo '<=bold=><=uline=><=red=>' "${@}"
}
# underlined echo in green
function guecho () {
	_colored_echo '<=bold=><=uline=><=green=>' "${@}"
}
# underlined echo in blue
function buecho () {
    _colored_echo '<=bold=><=uline=><=blue=>' "${@}"
}
# underlined echo in yellow
function yuecho () {
    _colored_echo '<=bold=><=uline=><=yellow=>' "${@}"
}

# runs printf with a specific assortment of color names
function _draw_formatted () {
    declare -A colors=(
    # colors
    [<=black=>]='\033[30m' [<=red=>]='\033[31m' [<=green=>]='\033[32m' [<=yellow=>]='\033[33m' [<=blue=>]='\033[34m' [<=purple=>]='\033[35m' [<=cyan=>]='\033[36m' [<=grey=>]='\033[37m'
    # bright colors (work like regulat when stylized bold)
    [<=b_black=>]='\033[90m' [<=b_red=>]='\033[91m' [<=b_green=>]='\033[92m' [<=b_yellow=>]='\033[93m' [<=b_blue=>]='\033[94m' [<=b_purple=>]='\033[95m' [<=b_cyan=>]='\033[96m' [<=b_grey=>]='\033[97m'
    # highlights / markers (can be switched with text color using 7m). If you want to "hide" text as a solid block of color run the same colors for both (i.e. \033[43m\033[33m)
    [<=h_black=>]='\033[40m' [<=h_red=>]='\033[41m' [<=h_green=>]='\033[42m' [<=h_yellow=>]='\033[43m' [<=h_blue=>]='\033[44m' [<=h_purple=>]='\033[45m' [<=h_cyan=>]='\033[46m' [<=h_grey=>]='\033[47m'
    # bright backgrounds (highlights)
    [<=bh_black=>]='\033[100m' [<=bh_red=>]='\033[101m' [<=bh_green=>]='\033[102m' [<=bh_yellow=>]='\033[103m' [<=bh_blue=>]='\033[104m' [<=bh_purple=>]='\033[105m' [<=bh_cyan=>]='\033[106m' [<=bh_grey=>]='\033[107m'
    # stylizing
    [<=bold=>]='\033[1m' [<=dark=>]='\033[2m' [<=italic=>]='\033[3m' [<=uline=>]='\033[4m' [<=flicker=>]='\033[5m' [<=fast_flicker=>]='\033[6m' [<=switch_fg_bg=>]='\033[7m' [<=hidden=>]='\033[8m' [<=crossed=>]='\033[9m'
    # reset
    [<=reset=>]='\033[0m'
    )

    # replace key-names with coloring-values within the text
    # ------------------------------------------------------
    text_to_draw=$1

    # add resets
    reset_key='<=reset=>'
    reset_value="${colors[$reset_key]}"
    reset_value_escaped=$(printf "%q" "$reset_value")  # for sed. It needs pre-reset string.
    regex_tag='<=[a-zA-Z_]+=>'
    regex_ws_tag='<=([0-9]+)WS=>'
    text_to_draw="${text_to_draw//$reset_key/$reset_value}"  # replace reset on its own, because otherwise we'd replace it with 2 consecutive color resets (still works, but isn't right)
    text_to_draw=$(echo "$text_to_draw" | sed -r "s/($regex_tag)/$reset_value_escaped\1/g")  # put reset before each color tag
    text_to_draw=$(echo "$text_to_draw" | sed -r "s/($regex_tag)($reset_value_escaped)($regex_tag)/\1\3/g")  # delete reset in between tags (to avoid canceling-out the prior tag)
    text_to_draw=$(echo "$text_to_draw" | sed -r "s/($regex_tag)($reset_value_escaped)($regex_tag)/\1\3/g")  # doesn't work for 3 consecutive tags, so we just repeat it...
    text_to_draw=$(echo "$text_to_draw" | sed -r "s/($regex_ws_tag)/$reset_value_escaped\1/g")  # put reset before spaces-insert
    text_to_draw=$(echo "$text_to_draw" | sed -r "s/$/&$reset_value_escaped/g")  # add resets at the ends of lines

    # insert whitespaces
    repeated_char=' '
    while [[ "$text_to_draw" =~ '<='([0-9]+)'WS=>' ]]; do  # while there's still a whitespace-tag
        num="${BASH_REMATCH[1]}"
        numtag="<=${num}WS=>"
        repeats=$(printf "%${num}s" | tr " " "$repeated_char")  # create a sequence of <num> spaces
        text_to_draw="${text_to_draw//$numtag/$repeats}"
    done

    # swap-in all the colors (replace keys with values)
    for str in "${!colors[@]}"; do
        text_to_draw="${text_to_draw//$str/${colors[$str]}}"
    done

    echo -e "$text_to_draw"

}

function draw_hentai () {
    HY='<=b_yellow=>'  # Hair Yellow
    HYD='<=yellow=>'  # Hair Yellow Dark
    S='<=reset=>'  # skin
    SD='<=b_red=>'  # Skin Dark
    EW='<=b_grey=>'  # Eyes white
    W='<=grey=>'  # teeth White
    WD=$S  # teeth White Dark
    WS='<=dark=><=b_grey=>'  # White Shirt
    WSD='<=b_black=>'  # White Shirt Dark
    G='<=dark=><=red=>'  # Glove and eyebrows Brown
    GD='<=b_black=>'  # Glove Brown Dark
    D='<=dark=><=b_black=>'  # dark
    
    declare -A SPR # whitespaces that'll reset colors in drawing
    for num in {1..25}; do SPR[$num]="<=${num}WS=>"; done
    declare -A SP # whitespaces. just spaces.
    for num in {1..25}; do SP[$num]="$(_repeat_space_n_times ${num})"; done
    WS_unconventional=''

    # don't try to peek at the drawing here, go run the command in terminal
    read -r -d '' surprise << EOM
${SPR[17]}$HY$HYD$HY$HYD$HY
${SPR[17]}$HY$HYD$HY
${SPR[17]}$HY$HYD$HY
${SPR[15]}$HY$HYD$S$HYD$S$SD$HYD${SP[1]}$SD$HYD$SD$HYD$HY
${SPR[16]}$HY$HYD${SP[1]}${SP[1]}$S$HYD$EW${SP[2]}$HYD$EW$SD${SP[1]}${SP[1]}$HYD$HY
${SPR[16]}$HY$HYD$S${SP[1]}$G$S${SP[1]}$EW$S$SD$HYD$HY
${SPR[17]}$HY$HYD${SP[1]}$EW$S${SP[1]}$SD$HYD$HY
${SPR[20]}$HYD$S$SD$HYD$HY
${SPR[23]}$S$SD$HYD$HY
${SPR[23]}$S$W$D$S$SD${SP[1]}$HYD$HY
${SPR[25]}$S$W$S$SD${SP[3]}$HYD$HY
${SPR[11]}$G$S${SPR[10]}$S$SD${SP[9]}$HY
${SPR[8]}$G$S$SD${SP[1]}${SPR[7]}$S$SD${SP[10]}$HY
${SPR[6]}$G$S$SD$GD$SD${SPR[8]}$WS$SD${SP[1]}$SD$WSD${SP[2]}$HY
${SPR[5]}$G$S$SD$GD${SPR[9]}$WS$WSD${SP[2]}${SP[1]}
${SPR[3]}$G$SD$GD${SPR[11]}$WS$WSD${SP[2]}${SP[1]}${SP[1]}${SP[2]}
$G$GD${SP[1]}${SPR[9]}$WS$WSD${SP[1]}
$G$GD${SPR[8]}$WS$WSD${SPR[8]}$WSD
${SPR[2]}$GD${SPR[8]}$WS$WSD${SPR[7]}$WSD
\x59\x4f\x55\x20\x57\x45\x52\x45\x20\x45\x58\x50\x45\x43\x54\x49\x4e\x47\x20\x4c\x45\x57\x44\x53\x2c\x20\x42\x55\x54\x20\x49\x54\x20\x57\x41\x53\x20\x4d\x45\x2c\x20\x44\x49\x4f\x21
EOM

    _draw_formatted "$surprise"
}

# Provide command as args; it'll run async, while ascii animations would play until the command's thread closes.
# Example: _spinning_wait_for_task sleep 10
function _spinning_wait_for_task {
    local cmd=("$@")
    "${cmd[@]}" &  # Run the command in the background
    local pid=$!  # Get the PID of the background process
    local chars=('\' '|' '/' '-')
    local i=0
    while [ -d /proc/"$pid" ]; do
        i=$(( (i+1) % 4 ))
        printf "\r%s Running: %s" "${chars[$i]}" "${cmd[*]}"
        sleep 0.1
    done
}




# Finishing touches (parsing this file and announcing that we're done to user)
#################################################################################

CUSTOM_ALIASES=$( comm -23 <( eval "$_alias_names_query" | sort) <( echo "$CUSTOM_ALIASES" | sort) )  # keep list of (only) aliases that were added between now and the start of the file
for ali in $CUSTOM_ALIASES; do CUSTOM_ALIASES_MAP[$ali]='1'; done  # fill a lookup hashmap (wanted hashset, but that's the closest I can get)
CUSTOM_FUNCTIONS=$( comm -23 <( declare -F | awk '{print $3}' | sort) <( echo "$CUSTOM_FUNCTIONS" | sort) )  # keep list of (only) functions that were added between now and the start of the file
for func in $CUSTOM_FUNCTIONS; do CUSTOM_FUNCTIONS_MAP[$func]='1'; done  # fill a lookup hashmap (wanted hashset, but that's the closest I can get)

# if user is root (sudo running), be quiet
if [ "$IS_USER_ROOT" = false ]; then echo "Finished loading \"$THIS_FILE\" for: \"`readlink -f $0`\""; fi
