#!/bin/bash


#---------------------------------------------------------------------------------------------
#----CUSTOM-----------------------------------------------------------------------------------
#---------------------------------------------------------------------------------------------


# Add everything here (see note below) to own user's .bashrc file (or in /etc/bash.bashrc if you want it to be global), then reset your terminal
# Relevant .bashrc files:
#   /etc/bash.bashrc
#   $HOME/.bashrc

# (note) It's more modular (and arguably easier) to just save this file somewhere and refer to it from bashrc.
# To do that, just paste the following 2 lines (uncommented) at the end of your bashrc. Make sure the filename's correct of-course.
#   CUSTOM_BASHRC_FILE="$HOME/custom_bashrc"
#   if [ -e "$CUSTOM_BASHRC_FILE" ]; then source "$CUSTOM_BASHRC_FILE"; fi

# To apply your bashrc to sudo as well, edit the file: /etc/sudoers , and put the following line in it (without the comment):
# Defaults        env_keep += "BASH_FUNC_*"


# please ignore - stuff that's needed early in this file; not meant for the user 
#################################################################################
_alias_names_query='alias | grep -E "^alias" | sed "s/^alias \([^=]*\)=.*/\1/"'  # this is needed very early (and very late) for lookup of existing aliases
_function_names_query='declare -F | awk '\''{print $3}'\'  # not as complex as aliases, but if aliases are here, so should this be.

# uses a later variable definition to determine if the script runs for user: "root"
function _is_user_root () { if [ "$IS_USER_ROOT" = true ]; then return 0; else return 1; fi  }

# For dependencies on packages, especially in aliases.
# Removed (non-purged) packages are considered not-installed
function _is_pkg_installed () {
    is_pkg_installed=$(dpkg-query -W --showformat='${Status}\n' ${1} 2>&1 | grep "install ok installed")
    if [ "${is_pkg_installed}" == "install ok installed" ]; then return 0; else return 1; fi
}

# Returns true if pacakge is installed, false + user-message if not.
# arg 1: package name
function _announce_pkg_installed () {
    if _is_pkg_installed "$1" ; then return 0; else echo "Can't use package '$1', consider installing it."; return 1; fi
} 


# Session data
#################################################################################
SUDO_FILE=$(which sudo)
THIS_FILE=$(readlink -f -- "$BASH_SOURCE")
THIS_FOLDER=$(dirname "$THIS_FILE")
TESTS_FILE="$THIS_FOLDER/run_tests.sh"  # Will run at the end of the sourcing of this file, for convenient debugging. Put whatever you want in such a file and change the address if you will.
SCRIPTS_BASHRC_FILE="$THIS_FOLDER/script_calls_bashrc"  # optional extention file
IS_USER_ROOT=$(if [ "$USER" = "root" ]; then echo "true"; else echo "false"; fi)
IS_FIRST_SOURCING=$([ ! -v CUSTOM_ALIASES_INITIAL ] && echo 'true' || echo 'false')

if [ "$IS_FIRST_SOURCING" = true ]; then  # only do if not defined already (can happen if you source this file again), in which case, previous iteration's values are the right ones
    CUSTOM_ALIASES_INITIAL=$(eval "$_alias_names_query")
    CUSTOM_FUNCTIONS_INITIAL=$(eval "$_function_names_query")
fi

# My settings / constants (customize this to your needs/liking)
#################################################################################
QEMU_VOLUME_UUID='A80899A4089971D4'
LOOKING_GLASS_CLIENT="/usr/local/bin/looking-glass-client"

HISTTIMEFORMAT="%Y-%m-%d_%T  "  # makes "history" command display the time the command ran at


# My binds
#################################################################################
# "\C-" is CTRL, "\e" (or "\M-") is alt. Shift might not be supported, but if it is: "\S-" is Shift (and maybe also backslash and capitalize, like this for Shift-X: "\X").
# Flag -x is "execute".
# A personal rule is that things get executed instead of written explicitly only if the user shouldn't care about the command used (i.e. it always makes sense to use just the shortcut)

# before adding a bind, check whether it's already taken, by running "bind -p". You'd generally be overwriting existing binds, but some of them such as CTRL+M cause problems when you overwrite
# To define it only if the shortcut doesn't exist, run a command like this:   if ! bind -q "\C-w"; then bind '"\C-w": "exit\n"'; fi

if ! _is_user_root; then  # no binding keys when running as root.
    # Bash terminal related 
    # =====================

    # CTRL+H : basically "help"
    bind -x '"\C-h": "remindme"$\r$\n'

    # print this, so the user can rerun this easily for function tests
    # ALT+N : refresh bash terminal
    bind '"\en": "exec bash\n"'

    # CTRL+Z : undo the regular CTRL+Z ; resume background-process UI 
    # bind -x '"\C-z": "fg"$\r$\n'

    # CTRL+W : close terminal. Just like in web-browsers
    # bind '"\C-w": "exit\n"'  # should be defined in the OS for all windows

    # CTRL+SHIFT+I : get system info
    # bind -x '"\C-\I": "echo something"$\r$\n'  # TODO


    # Custom environment 
    # ==================

    # CTRL+X : (let's pretend X is for X-Server...) arrange monitors when the nvidia settings won't keep them arranged
    bind -x '"\C-x": "arrange_monitors"$\r$\n'

fi

# My keyword shortcuts
#################################################################################

# aliases work as "command (re)placements", i.e. they'll replace words that are commands but not args


# Basic functionalitiy override !
# ===============================

# TODO - add remindme's screenshot to README
# TODO - lookup (grep) within "remindme"
# TODO - "whatnow" - tag commands (things like "network" or "visual" or "filesystem") and list the tags for (optional) interactive picking 
# TODO - find all "] &&" and see that they operate fine

# TODO - find places in code that print line-by-line and speed them up by buffering and printing everything at-once (noticably faster), unless those are in a (potentially) long processes




# The space at the end makes bash auto-complete the next word as well. 'sudo ' alone makes aliases work in sudo, but not functions.
alias sudo='sudo '

# same trick as in sudo
alias man='man '

# replace apt with nala. Same thing but prettier
# conditional alias - only if package is installed
_announce_pkg_installed 'nala' && alias apt='nala'

# rsync copy instead of cp - recursive by default and shows progress percentage
_announce_pkg_installed 'rsync' && alias cp='rsync -ah --info=progress2'


# Common
# ======

# ----- Lookups / Getting-info

# grep, case insensitive (i), and no regex involved (F)
alias g='grep -iF --color=auto'

# grep, catches 3 lines before/after (+6 total) match, case insensitive (i), and no regex involved (F)
alias g3='grep -iF --color=auto -C 3'

# TODO - maybe make into a function that prints the chowned files (distinguishing the filenames from $@ is difficult though)
# take ownership of file (add file-name after this command) 
alias claim='sudo chown $USER:$USER'

# history grep
alias hg='history | grep -iF --color=auto'

# TODO - if you ever find out how to put this in a table without messing up filenames with spaces, fix this 
# Custom ls, like "ll". Add -S to sort by (non-recursive) size
alias lll='becho "Blocks Permissions Hard-Links Owner Group Size Date_Modified Filename" ; ls -tarlushFN --color=always --time-style="+%Y-%m-%d_%T" --group-directories-first'

# reset terminal (includs bashrc reload)
alias anew='exec bash'

# Show current network connections to the server through port 80
alias port80="sudo netstat -tulpn | grep :80"

# get own IP
alias whatsmyip='becho "My private IPs:"; ip addr show | grep inet | grep -v inet6 | awk '\''{print $2}'\'' | cut -d/ -f1  ;  becho "My IPv4:" ; dig @resolver4.opendns.com myip.opendns.com +short '

# get addresses on LAN
alias whatsmynetwork="buecho 'LAN devices:' ; arp -a  ;  buecho 'Connections:' ; netstat -atn"

# Get basic hardware and system list
alias sysinfo_short='echo "For simpler neat hardware specs, run \"neofetch\" or \"screenfetch\""; inxi -bD'

# Get comprehensive system/specs details
alias sysinfo_full='inxi -FxxzJy90'

# Get metadata of a specified audio/video/image file
alias media_metadata='ffprobe -v error -show_entries stream=width,height,r_frame_rate,nb_frames,codec_name,channels,bit_rate,duration -show_entries format=filename,size -hide_banner -pretty -print_format json'


# open window at current terminal directory
alias gui='xdg-open "$(pwd)"'


# Service/Application handling
# ============================

# run docker desktop
alias run_docker_desktop='systemctl --user start docker-desktop'

# TODO - define "sudocker" - run docker desktop as sudo so that it'll find all containers


# System management
# =================

# upgrade your system.
alias updatengrade='sudo apt update && sudo apt-get full-upgrade -y && sudo apt-get autoremove -y'

# rebuild boot parameters using GRUB
alias rebuild_boot='sudo update-grub'

# rebuild RAMFS to apply changes like in modprobe (blacklisting services)
alias rebuild_ramfs='sudo update-initramfs -u'


# function aliases (alternate names)
# ==================================

# Synonymous to "remindme" with extra information (less useful to user).
alias list_cmds='remindme --show_hidden --include_line_num'
# Synonymous to "remindme".
alias what_commands='remindme'
## Mispelled intentionally; don't fix it.
# Synonymous to "remindme".
alias i_forgor='remindme'
# Synonymous to "find_proc". psg is short for "ps grep"
alias psg='find_proc'


# Cheatsheets
# =================

# Reminders for linux system tools and command options
alias howdoi_linux='commecho "
>> Packages
* sudo apt install/remove/purge <package>  # package install/remove/remove-including-configs
* sudo gdebi -n <package.deb>  # probably the best way there is to install a .deb file (the -n is for \"no prompt\")
* sudo dpkg -r <package>  # remove a package installed from a .deb file
* sudo dpkg --purge <package>  # purge a package installed from a .deb file
* dpkg-query --list <package>  # print info related to installed package (autocompletes the name), works for all installations including from .deb
* apt list  # list all packages in followed repositories
*   apt list --installed  # list installed packages
*   dpkg -l  # show all installed packages in table format
>> Messing around with the system itself
* reboot  # reboots the system (gracefully)
* sudo systemctl start sshd  # start ssh service for external access
* udisksctl mount --block-device=/dev/<device-name>  # Mount a device the way nemo would. No need for mkdir (and nemo can dismount it right), no harm in calling while unnecessary, automatically uses LABEL to mount at /media/<username>/
*   udisksctl mount --block-device=/dev/<device-name> 2> /dev/null
>> configurations
* /etc/default/grub  :  boot configurations
* /etc/modprobe.d/blacklist.conf  :  blacklist modules, such as firmware
* /etc/fstab  :  mounting configurations, including for dir /
* /etc/environment  :  OS environment variables
*   printenv  # print (all) current environment variables 
* sudo nvidia-xconfig  # create new xorg config, used by nvidia driver
>> logs (to tail a logfile in real-time run: \"tail -f <logfile>\", or to get last 100 lines: \"tail -100 <logfile>\" )
* log-file: /var/log/boot.log  :  System boot log
* log-file: /var/log/dmesg  :  log for kernel ring buffer
*   dmesg -k | grep -E \"warn|error\"  # the command dmesg displays kernel logs buffer
* log-file: /var/log/kern.log  :  log for kernel ring buffer
"'

# Reminders for user/groups management
alias howdoi_users='commecho "
* groups <username>  # display the groups of a user
* usermod -aG <groupA,groupB,groupC> <username>  # add user to group(s). You can even add to group sudo (makes into superuser in Ubuntu).
* getent group  # list all groups and their user-members
* sudo adduser --disabled-password --gecos "" <username>  # adduser is a useradd wrapper (addused is generally better). The --disabled-password and --gecos options are required for no-prompt; gecos fills thumbnail info (cancels interactive). --no-create-home skips homedir creation. --disabled-password skips password creation and disables password login.
*   sudo adduser <username> --gecos "" --disabled-password && echo "<username>:<password>" | sudo chpasswd  # Add user with password in one line. take care to specify the username twice, as needed here
* sudo deluser --remove-home <username>  # delete user and associate homedir
* su - <username>  # Switch to user. Might require sudo.
"'

# Reminders for the basic gimmicks of bash
alias howdoi_bash_terminal='commecho "
>> terminal
* apt search <term>  # look for substring in known packages. As usual, nala can also be used
* man <command>  # read the manual of the command
*   help  # list built-in Bash commands
* cd  # write no directory to return to home-dir. Equivalent to cd ~
*   cd -  # go back to previous directory
* less <file>  # Read file with up/down controls. Newer and more convenient than "more".
* sudo !!  # rerun last command with sudo permissions
* htop  # show real-time processes/resource-usage
* xkill  # after you run this, your mouse cursor would turn into an "x" sign, and the next window youll click would be killed. A bit lazy and silly.
* diff <file1> <file2>  # get the text difference between 2 files
* visudo  # edit the /etc/sudoers file (only if you know what you are doing)
>> bash basic utility commands (can be used in terminal of-course)
+ \"\$my_var\" is the value of variable my_var, \"\$1\" is the first argument in current scope (and so on), \"\$@\" is all arguments in current scope, \"\$#\" is the number of args, \"\$\$\" is current PID, \"\$?\" is the return code of last operation, \$(<cmd here>) is used to run commands within commands (can also use \`<cmd here>\`)
* declare -p <variable>  # Note: no use of $. Print the variable to check data / data-type
+ add \"& disown\" after a command to have it run in its own thread so that it wont stop when the terminal closes
+ add \"2> /dev/null\" after a command to throw away warning/error messages it might bring up
* time <command>  # get time measurement for command runtime. No need for quotes or any encapsulation, just prepend \"time\". Example: time ls -l
* extra_dist=\$(( (a > b) ? (a - b) : 0 ))  # example for ternary in bash (use the \"&&\",\"||\" ternary instead when you have a condition in \"[]\"). The double-parentheses mean you dont need \"$\" to reference variables and that the math operations get evaluated
* espeak <text>  # read-out (audio) the given text. A bit of a gimmick, sounds very robotic
>> tools (utilities for usage that isnt about managing the OS)
* wget <url>  # download files
* curl <url>  # communicate through HTTP(S)/(S)FTP/SCP - make any request (but if you just want to download something, you should probably use wget)
>> shortcuts
* Terminal CTRL+L : clear screen
* Terminal CTRL+Z : send to background (leave any interactive UI for a while). Resume by running: fg
"'

# common media file operations
alias howdoi_media_and_docs='commecho "
* pdftk <file1> <file2> <file3> cat output <merged_name.pdf>  # create a unified pdf file 
* xournal <pdf_filepath>  # edit a pdf file with option to add signatures
* ffmpeg  # general media (audio / video) handling package, you can find some usages in this bashrc file
"'

# Reminders for microsoft-format handling tools
alias howdoi_microsoft='commecho "
* lnkinfo <lnk-file>  # display link info
* dos2unix <file>  # convert files from windows to unix encoding
* sudo ntfsfix <device> -v  # run check-disk on NTFS device
* ldmtool  #  Read dynamic disks by running \"sudo ldmtool create all\", and then mounting with \"mount -t ntfs /dev/mapper/<volume_name>\"
"'

# Snippets and tricks for Chromium-based browsers
alias howdoi_chromium='commecho "
* chrome://flags/#hardware-media-key-handling  # Advanced operation flags. Specifically media-key-handline - disable this to get rid of the banner that appears when you change volume
* document.getElementsByTagName("video")[0].playbackRate = 4  # change youtube playback speed (example here: x4)
"'


# Reminders for android-related tools
alias howdoi_android='commecho "
* scrcpy  # run daemon that casts the connected Android device screen onto a window, and shares the clicks within it back to the Android device
* scrcpy -r <filename.mp4>  # save a video recording of your connected android device activity (needs USB-Debug and File-Transfer mode)
"'

# Reminders for network management
alias howdoi_network='commecho "
>> Own network info
* ip addr  # display own networking interfaces
* sudo netstat -tulpn  # display active network connections and filter by port number
>> Seeking addresses
* dig \"amazon.com\" +short  # resolve dns address (or addresses, in case content-distribution-networks are involved)
* ping google.com  # ping address
>> Firewall and incoming requests
* UFW config-file: /etc/ufw/ufw.conf  :  to monitor incoming requests, set in it: LOGLEVEL=debug , then run \"sudo ufw reload\" (no-interruption reset; if it wont work run: \"sudo service ufw restart\"), and then \"sudo tail -f /var/log/ufw.log\" to monitor
* ufw allow 21115:21119/tcp  # change firewall rules (by ports or src address) - in this case, allow ports 21115 to 21119 (including) on tcp
* sudo tcpdump -i any -n  # capture traffic on all networks for all ports
* sudo tcpdump -i [interface] -n \"src host [external_IP] and dst port [dst_port]\"  # detailed monitoring
*   detailed monitoring example 1:  sudo tcpdump -i enp5s0 -n \"dst port 21118\"
*   detailed monitoring example 2:  sudo tcpdump -i any -n \"tcp and (dst port 21115 or dst port 21116 or dst port 21117 or dst port 21118 or dst port 21119)\"
*   detailed monitoring example 3:  sudo tcpdump -i any src 46.120.97.16 -nn -c 20  # -nn shows ip addresses and port-num without resolving hostname, -c stops capturing after 20 packets
"'

# Reminders for the basics of systemd
alias howdoi_manage_services='commecho "
>> Crontab
* crontab -e  # edit routine-scheduled tasks
>> systemd
* /etc/systemd/system/  :   add/remove .service files here
* sudo systemctl daemon-reload  # rescan and reload service files
* sudo systemctl <start/stop/restart/status> <myservice>.service  # manage the state of the service or check its running-status
* sudo systemctl <enable/disable> example.service  # allow/disallow service to run after boot
* journalctl -u <service_name.service>  # check the logs of a systemd service. Can also specify how to view them; example:   journalctl -u ssh --since \"1 hour ago\" --until now -f
"'

# Reminders for docker
alias howdoi_manage_docker='commecho "
>> view (might need to run sudo to find all)
* docker ps -a  # list ALL containers
* docker images -a  # list all images
* docker volume ls  # list all volumes
* sudo docker inspect <container_name_or_id>  # view container details 
>> managing container states
* docker-compose -f <yml_file> up  # Start a conteiner using a yaml/yml file. Use -d to make it run in the background
>> removal
* docker system prune -a  # remove all images/containers/volumes/networks. The flag -a also remove unused images
* docker rmi <image(s)>  # remove images ; to remove all images:   docker rmi \$(docker images -a -q)
* docker rm <container_id(s)_or_name(s)>  # remove container(s) ; to force-remofe, add -f ; to remove all stopped containers:   docker rm \$(docker ps -a -f status=exited -f status=created -q)
* docker volume rm <volume_name(s)>  # remove volume(s)
* docker run --rm <image_name>  # run an image and remove its container when it exits
"'

# Reminders for vm tools and command options (mostly stuff you can't do through Virtual Machine Manager)
alias howdoi_manage_vm='commecho "
* systemctl restart libvirtd  # restart the libvirt daemon vm-manager
* virsh start <name>  # start VM
* virsh domrename <old_name> <new_name>  # rename vm
* virsh edit <name>  # modify the xml of a VM (you can do that in Virtual Machine Manager instead)
* sudo virt-sparsify --in-place -v <diskimg.qcow2>  # compress vm disk file
* virsh list --all  # show VM list
* virsh snapshot-create-as --domain <VM-NAME> --name <SNAPSHOT-NAME>  # create snapshot for a vm (has to be turned off)
* virsh snapshot-list --domain <VM-NAME>  # list snapshots of vm
* virsh snapshot-info/snapshot-revert/snapshot-delete --domain <VM-NAME> --snapshotname <SNAPSHOT-NAME>  # detail/go_back_to/delete snapshot
* qemu-img create -f qcow2 -F qcow2 -b <path_to_src_disk.qcow2> <path_to_output_disk.qcow2>  # snapshot a single disk
"'

# Reminders for the basic gimmicks of tmux terminal
alias howdoi_use_tmux='commecho "tmux offers split-panes and sessions for terminals.
>> Good for managing a server:
+ tmux terminals persist even after disconnection. They keep running until restart the server or send a closure command.
+ tmux windows can be named, listed and looked up.
+ tmux can accomodate multiple users on the same terminal simultanously; good for assistance/collaboration and for doing jobs that need a \"lock\" (having a channel where certain jobs run, so people would know if someone elses job is underway and should be allowed to finish first)
>> Quick explanation: tmux has sessions. Each session can have various windows, each window (has a number and name) is a \"screen\" thats visible at the moment and has vertically/horizontally added panes 
+ For simplicity you can just have a SINGLE SESSION and manage all your windows there. Its easier to navigate windows, thanks to the green bar listing them at the bottom.
+ If a window has only need for a SINGLE TERMINAL (lets say the window is called \"grub_config\"), you can keep it simple and avoid adding extra panes. Add panes to multi-faceted things, like a project which has code, git-management, assets, runtime area etc.
> Sessions:
* tmux  # create a new tmux session
* CTRL+B, D  : leave (detach) current session
* tmux ls  # view all existing tmux sessions (+ info about creation date and number of windows)
* tmux rename-session -t <0/1/2/3/.../past_name> <name>  # rename session (using number/name from \"tmux ls\")
* tmux attach -t <0/1/2/3/.../name>  # connect (attach) to an existing tmux session (using number/name from \"tmux ls\")
* tmux kill-session -t <0/1/2/3/.../name>  # kill specified session
> Windows:
* CTRL+B, <0/1/2/3/...>  : go to window number
* CTRL+B, C  :  create a new window
* CTRL+B, ,  :  rename current window
> Panes:
* CTRL+B, %  :  create a new pane to the right
* CTRL+B, \"  :  create a new pane to the bottom
* CTRL+B, <left/right/up/down>  :  move focus to other pane
* exit  # close pane. If last pane, close window.
"'
# TODO - create a script thatll establish tmux workspaces when logging into your user (so youd have things ready for debugging or coding and such)
# TODO - create functions that run these commands interactively (like listing, then letting the user pick a number, then go there...)

# TODO - cargo (maven-like manager) cheatsheet. Reference: https://www.youtube.com/watch?v=zF34dRivLOw

# Reminders for ascii-related commands and handling
alias howdoi_ascii='commecho "
+ Create ASCII writings in this site: http://patorjk.com/software/taag/
* figlet <text>  # write ASCII styled text, different fonts are also supported
* banner <text>  # write ASCII styled text
* toilet <text>  # write ASCII styled text, different fonts and styles are also supported
* jp2a --output=<output.txt> --colors <input.png>  # convert image to ASCII
* ascii-image-converter <input.png>  # convert image to ASCII
* <text_output_command> | lolcat  # rainbow-color text
* <text_output_command> | pv -qL 200  # write text progressively (like being typed, or (if fast) etched by a laser engraver). Try testing with neofetch. Try adding pipe to lolcat.
"'


# Reminders for some neat time-saving GUI keybind tricks
alias howdoi_shortcut='commecho "
* Built-in Nemo [space] :  select (click) a file/folder, and press [space] to get a summary/preview; press again to close
* Custom Gnome-Nemo CTRL+SHIT+T :  open Terminal at current Nemo location
* Built-in Gnome CTRL+ALT+T :  open Terminal
* Built-in Gnome(?) CTRL+ALT+[backspace] :  log out of current session (resets your GUI)
* Built-in Debian(?) CTRL+ALT+F1 :  enter TTY mode (terminal without anything graphic to lock/interrupt you)
* Built-in Debian(?) CTRL+ALT+F7 :  exit TTY mode
* Evded installation LCTRL+RCTRL  :  switch mouse and keyboard (and maybe other things) between guest/host. Wont work if you gave the VM your USB device directly.
"'


# Custom
# ======

# Ad-Hoc screen layout rearrangement (sometimes they get messed up; maybe it's an Nvidia-Linux problem)
alias arrange_monitors='nvidia-settings --load-config-only && nvidia-settings --assign CurrentMetaMode="HDMI-0: nvidia-auto-select +1920+1080, DP-0: nvidia-auto-select +1920+0, DP-2: nvidia-auto-select +3840+1080, DP-4: 1920x1080_240 +0+1080"'


# Legacy
# ======

# # Aliases for safe and forced reboots
# alias rebootsafe='sudo shutdown -r now'
# alias rebootforce='sudo shutdown -r -n now'






# My functions
#################################################################################

# TODO - a "checksum" function that gets both file to checksum and the checksum-result file, determines which is which, runs the appropriate checksum on the file and compares with the result file; prints the match result 

# Common operations - just for the use of functions
# =================================================

# attempt to run command given command (args) - if it fails, run with sudo
function _sudo_if_necessary () {
    [ $# -ge 1 ] || { recho "WTF are you expecting me to sudo? Give me a command-string as argument" ; return ; }

    normal_output=$(eval "$@" 2>/dev/null)
    [ $? -ne 0 ] && eval "sudo $@" || echo "$normal_output"
}

# useful for drawings or neat concatenating of tables like so: 'paste <(_pad_end_w_spaces "$(df -h)") <(_pad_end_w_spaces "$(df -hi)") <(_pad_end_w_spaces "$(df -hi)")'
# Append spaces to text lines for a rectangular look; i.e. end uniformly on the same column.
# Also works with pipes. Could be problematic for table formatting if color is involved (colors are extra unseen chars)
function _pad_end_w_spaces() {
    text="$1"  # assume that text is provided as an argument
    if [ -z "$text" ] && ! [ -t 0 ]; then text=$(cat); fi  # if no text given and there's a stream from a pipe, get the stream contents as text
    awk '{hi[NR]=$0; max_len=length($0) > max_len ? length($0) : max_len} END {for (line in hi) { printf "%s%*s\n", hi[line], max_len-length(hi[line]), "" }}' <<< "$text"
}

# pastes text blocks (given as args) side by side
# --lined (optional before texts: separate with line instead of space) , --glued (optional before texts: no delimiter) , --no_padding (optional before texts: no padding)
function _side_by_side() {
    separator=' ' ; no_padding=''
    [ "$1" = "--lined" ] && separator='|' && shift  # get rid of the flag, so it won't disturb us
    [ "$1" = "--glued" ] && separator='' && shift  # get rid of the flag, so it won't disturb us
    [ "$1" = "--no_padding" ] && no_padding='true' && shift  # get rid of the flag, so it won't disturb us

    
    # prepare to add more lines to texts that are too short
    line_counts=()
    for i in "$@"; do line_counts+=($(echo "$i" | wc -l)); done  # count the number of lines for each
    max_lines=$(max "${line_counts[@]}")

    args=("$@")  # for iteration. can't iterate on the index of $@ - the items start from 1, but the index starts on 0 ("bash") unlike lists that start their index at 1
    paste_texts=()  # the values that need to be pasted
    items_to_interpret=()  # will be made into a string that refers to the values; interpreted into a command
    for i in "${!args[@]}"; do  
        modified_txt_block="${args[i]}"  # actual item
        # add empty lines
        line_diff=$(( max_lines - line_counts[i] ))  # how many lines are "missing"
        [ $line_diff -gt 0 ] && modified_txt_block+=$(echo -e "\n$(yes " " | head -$line_diff)")  # if text is shorter than max, add newlines (add [diff] 1-line spaces below - need an additional newline before those)
        # pad to allow concatenating without messing up the lines
        [ -z "$no_padding" ] && modified_txt_block=$(_pad_end_w_spaces "$modified_txt_block")
        # add to list that we'll reference in the command
        paste_texts+=("$modified_txt_block")  # data list
        items_to_interpret+=('<(echo "${paste_texts['$i']}")')  # pointers to data
    done
    
    eval "paste -d '$separator' ${items_to_interpret[@]}"
}


# TODO - unused, so remove?
# get device name such as "/dev/sda2". You must provide one argument: the UUID of the device.
function _get_dev_name_from_uuid () {
    [ $# -ge 1 ] || { echo "You need to provide UUID as an argument" ; return ; }
    blkid | grep "UUID=\"$1\"" | awk -F: '{print $1}'
}

# adds y/n prompt. Call like this:  if prompt_yn "<prompt q>?"; then echo "<starting-process msg>"; else echo "<cancellation msg>" && return ; fi
function _prompt_yn() {   
    response=""
    # keep prompting the user until they provide a valid response
    while [ "$response" != "y" ] && [ "$response" != "n" ]; do
        # prompt the user for a yes/no response
        read -p "$1 [Y/n] " response
        case "$response" in
            y|Y ) return 0 ;;  # if the response is "y", return a boolean value indicating success
            n|N ) return 1 ;;  # if the response is "n", return a boolean value indicating failure
            *) echo "just type y or n" ;;  # if the response is anything else, print an error message and continue prompting
        esac
    done
}

# turn a list into a hashmap; you need to evaluate the output (can't return a hashmap directly)
# call like this: eval $(_hashmap_instructions --hm_name 'my_hashmap' --list "${my_list_var[@]}")
function _hashmap_instructions () {
    hashmap_name='' ; the_list=''
    while [[ $# -gt 0 ]]; do
    	case "$1" in
            '--hm_name')
    			hashmap_name="$2"
    			shift 2
    			continue
    		;;
            '--list')  # MUST come last!
                shift 1
    			the_list="$@"
                while [ "$#" -gt 0 ]; do shift; done  # no more args, shift them all.
    			continue
    		;;
            *)
                recho "${FUNCNAME[0]} doesn't know how to handle arg: '$1'"
    			shift
    		;;
        esac
    done

    [ -z "$hashmap_name" ] && recho "no name provided for your hashmap" && return 1
    [ -z "$the_list" ] && recho "no list provided" && return 1

    hasmap_builder="declare -A $hashmap_name=("
    for item in $the_list; do hasmap_builder+=" [$item]='1'"; done 
    hasmap_builder+=")"
    
    # "return" the hashmap-creation string that needs to be evaluated
    echo "$hasmap_builder"
}

# gets variable name, evaluates it and returns hashmap-creation-string for same varname with suffix _map or _MAP
# call like this: eval $(_hashmap_this_var 'list_name')
function _hashmap_this_var () {
    [ "$#" -eq 1 ] || { recho "You need to provide variable-name as an argument" ; return ; }  # TODO - check this file for all places where "ge 1" was used, maybe mistakenly instead of "eq 1"
    
    # uses the '=' to avoid screwing up a substring in the declaration prior to var-name
    eval $(declare -p "$1" | sed "s/${1}=/new_list=/")  # get list declaration and declare it for a name we know locally

    [[ ${new_list[@]} == "" ]] && return 1  # list is empty (variable was initialized as empty string) - nothing to do


    hm_suffix=$([[ "${1}" == "${1^^}" ]] && echo "MAP" || echo "map")  # if completely capitalized, suffix is _MAP, otherwise it's _map
    _hashmap_instructions --hm_name "${1}_${hm_suffix}" --list "${new_list[@]}"
}

# List the items unique to the first list. Better in runtime than comm -23, thanks to hashmap usage
function _unique_in_first () {
    filter_me="$1"
    blacklist="${@:2}"
    eval $(_hashmap_this_var 'blacklist')  # create hashmap: blacklist_map

    for item in $filter_me; do [ -n "${blacklist_map[$item]}" ] || echo "$item"; done  # print if unique to first
}


# Basic functionalities override !
# ================================

## I don't know what black magic is involved, but you need both the above sudo alias and this function to support alias interpretation.
# Sources this file if the command is a function from this page.
function sudo () {
    # needs to be "silent" to avoid screwing up scripts that rely on the output of the sudo'd commands
    # if arg 1 (only arg 1 supported, deal with it) is in the list of this file's functions, source this file. Otherwise, run sudo regularly.
    if [ -n "${CUSTOM_FUNCTIONS_MAP[$1]}" ]; then
        custom_function_cmd="source $THIS_FILE && $@"
        "$SUDO_FILE" bash -c "$custom_function_cmd"
    else
        "$SUDO_FILE" "$@"
    fi
}

# TODO - do about the same for chmod and chown - print the directory/files with the changed data (maybe cancel that, getting the filenames in every case isn't simple)
# add a print of local files after changing directory
function cd () {
    builtin cd "$@" && \
        ls -AF --color=always --group-directories-first 
}

# make mkdir more "reasonable" with a flag that is always nice to have ; -p doesn't print error if dir exists
function mkdir () {
    [[ $* == *-p* ]] && extra_flag="" || extra_flag="-p"  # if flag not present, store it in var 
    /usr/bin/mkdir "$extra_flag" "$@"
}

# make date output in a specific format by default
function date () {
    args=$([ $# == 0 ] && echo "+%Y-%m-%d_%T" || echo "$@")  # if provided 0 args, set the time-format to own preference
    /usr/bin/date "$args"
}


# Basic functionalities
# =====================

function max () {
    max=$1
    for n in "$@"; do (( $(echo "$n > $max" | bc -l) )) && max=$n ; done
    echo $max
}

# TODO - command grep. "command_like <expression>"
# list custom commands.
# --show_hidden (list inner-workings commands) ; --sort (sort alphabetically) ; --include_line_num
function remindme () {
    # declare -p CUSTOM_FUNCTIONS
    show_hidden='' ; include_line_num='' ; sort=''
    while [[ $# -gt 0 ]]; do
    	case "$1" in
            '--show_hidden')
    			show_hidden='true'
    			shift 1
    			continue
    		;;
            '--include_line_num')
    			include_line_num='true'
    			shift 1
    			continue
    		;;
            '--sort')
    			sort='true'
    			shift 1
    			continue
    		;;
            *)
                recho "${FUNCNAME[0]} doesn't know how to handle arg: '$1'"
    			shift
    		;;
        esac
    done

    unoriginal=('sudo' 'man' 'cd' 'mkdir' 'cp' 'date' 'apt')  # list of overwritten shell commands 
    eval $(_hashmap_this_var 'unoriginal')  # create hashmap: unoriginal_map

    declare -A line_to_cmd  # map of line number to respective command definition (name and comment)

    # TODO - list key binds too
    # TODO - if not "sort", print categories by finding the line above "# =="
    # TODO - once tags are added, (color-)mark some commands as "useful"; specifically those you can use often


    function get_commands_by_expression {
        expression_template="$1"
        num_of_rows_above="$2"
        cmd_names="${@:3}"  # args 3 and onwards

        [ -z "$cmd_names" ] && recho 'No commands given to search!' && return

        while read -r name; do
            if [ -z "$show_hidden" ] && [[ "${name:0:1}" == '_' ]]; then continue; fi  # if not showing hidden functions and current function starts with '_', skip it
            if [ -n "${unoriginal_map[$name]}" ]; then continue; fi  # if it's an override of a known command (user already knows what it does), don't mention it - skip

            # we already have the names, we need the documentation. And maybe also line number.
            expression=$(echo "$expression_template" | sed "s/<name>/$name/")
            line_num=$( grep -nE "$expression" "$THIS_FILE" | cut -d: -f1 )  # get line number
            matched=$(grep -B "$num_of_rows_above" -E "$expression" "$THIS_FILE")  # match declaration and some rows above for documentation
            matched=$(echo "$matched" | grep -E '^#[^#]' |  grep -vE '^#[[:space:]]*TODO' )  # keep only comments, but not if they start with "##" (those are for the maintaining of the function rather than understanding how it works) and not if # is followed up by TODO
            matched=$(echo "${matched}"| paste -s -d ' ')  # unify all results into one row (if any). Separate with space
            line_to_cmd["$line_num"]="$name  $matched"
        done <<< "$cmd_names"
    }

    # aliases
    get_commands_by_expression "^\s*alias\s+<name>=" 1 "$CUSTOM_ALIASES"

    # functions
    get_commands_by_expression "^\s*function\s+<name>\s*\(\)\s*{" 2 "$CUSTOM_FUNCTIONS"

    cmd_list=$(for key in "${!line_to_cmd[@]}"; do commecho "$key ${line_to_cmd[$key]}"; done )  # include line-number for possible sorting
    [ -n "$sort" ] && cmd_list=$(echo "$cmd_list" | sort -k2) || cmd_list=$(echo "$cmd_list" | sort -n -k1) # If user specified alphabetical sorting, sort by command name. Otherwise sort by line num
    [ -z "$include_line_num" ] && cmd_list=$(echo "$cmd_list" | cut -d" " -f2-)  # if flag not specified, remove line numbers


    echo "$(becho The following commands were overridden, but retain their original functionality:)  $(printf "%s, " "${unoriginal[@]}" | sed 's/, $//')"
    echo "$cmd_list"
}

# man grep - find word in manual, with a bit of context (lines above/below).
# arg 1: man's target, arg 2: word to find
function mang () {
    man "$1" | grep -iF --color=auto -C 3 -- "$2"  # the "--" allows you to lookup dashes in your expression
}

# Find processes by substring. Print error if given no args ; print everything if given empty string
function find_proc () {
    [ $# -ge 1 ] || { recho "No substring provided to look through with." ; return ; }

    ps -eo pid,ppid,user,%cpu,%mem,stat,start,time,cmd --sort=-%cpu | awk -v search="$1" 'BEGIN{IGNORECASE=1} NR==1 || $0 ~ search {print}' \
    | color_word --word "$1"  # color the sought term
}

# kill processes by substring, with a confirmation prompt that specifies what's being killed
function kill_interactively () {
    [ $# -ge 1 ] || { recho "You need to provide a substring to find (and later kill) processes with." ; return ; }
    
    pids=$(pgrep -i "$1")  # get all PIDs
    [ -z "$pids" ] && becho "no processes found" && return 0;
    pids_commas=$(echo "$pids" | tr '\n' ',' | sed 's/,$//')  # save PIDs with comma-separation (for listing)
    pids_spaces=$(echo "$pids_commas" | tr ',' ' ')  # save PIDs with space-separation (for killing)
    proc_info=$(ps -p "$pids_commas" -o pid,ppid,user,%cpu,%mem,stat,start,time,cmd --sort=-%cpu)

    prompt="$(echo "$proc_info" ; recho "The listed processes will be killed. Are you sure?")"
    if _prompt_yn "$prompt"; then _sudo_if_necessary kill ${pids_spaces} ; else echo "Quitting." && return ; fi

    _wait_n_seconds 2

    pids=$(pgrep -i "$1")  # get all PIDs, again
    [ -z "$pids" ] && becho "Confirmed no new processes with same substring" || recho "Found live processes with the same name you just eliminated"
}


# Maintenance and Update Operations
# =================================

# install from given (deb file's) URL
function install_deb_from_url () {
    pkg_name=$(echo "$1" | awk -F/ '{print $NF}')  # get the string after last '/'
    installation_msg="Installed debian (.deb) package: $pkg_name. If you want to remove it, run: 'sudo dpkg -r $pkg_name'"
    wget "$1" && sudo gdebi -n "./$pkg_name" && echo "$installation_msg"  # download and install
    rm "$pkg_name"  # remove .deb file
}

# Permanently append a string to PATH.
# Add directories like "/home/<you>/.local/bin"
function add_to_path () {
    # check if given arg is already in PATH
    if [[ $PATH == *$1* ]]; then
        echo "$1 is already in PATH!"
        return
    fi
    export PATH=$PATH:$1
	# change the line where "PATH=" appears
    sudo sed -i "/PATH=/c\PATH=$PATH" /etc/environment
    printf "From now on:\n`sudo cat /etc/environment`\n"
}

# Mounts, and handles mount-dir. Safe to run when unnecessary, it'll just throw an error.
# arg 1: uuid of device
function mount_media_by_uuid () {
    udisksctl mount -b "/dev/disk/by-uuid/$1"  # add -t <mountpoint>  to change mount-location
}


# Find iommu groups that deal with given word. Useful for passing devices onto VMs.
# arg 1: device substring (example: "usb", or "nvidia", or "SATA") (optional; if not specified, you get all IOMMUs)
function iommu_find () {
    iommu_group_prefix='IOMMU Group '

    # arg 1: accepted files. Example: /sys/kernel/iommu_groups/*/devices/*
    function _stringify_iommu_files () {
        for file in $1; do
            iommu_group=$(echo "$file" | awk -F'/' '{print $(NF-2)}')
            device_num=$(basename "$file")
            device_string=$(lspci -nns "$device_num" | sed 's/^[[:alnum:]:.]* //')  # get the device description, but drop the initial number
            echo "${iommu_group_prefix}$iommu_group: device $device_num : $device_string"
        done
    }

    all_iommu_devices=$(_stringify_iommu_files '/sys/kernel/iommu_groups/*/devices/*' | sort -V)

    lookup="$1"
    if [ -z "$lookup" ]; then
        recho "You didn't specify a device substring/word to look-up (Example: \"USB\"). So here are all IOMMUs/devices and connected USB peripherals:"
        echo "$all_iommu_devices"
        lsusb
        return 0 
    fi

    # if you reach here, term search was specified
    group_texts=()
    iommu_groupnums=$(grep -i "$lookup" <<< "$all_iommu_devices" | sed "s/^${iommu_group_prefix}\([0-9]\+\):.*$/\1/" | sort -V | uniq)
    for num in $iommu_groupnums; do
        group_texts+=("$(_stringify_iommu_files "/sys/kernel/iommu_groups/$num/devices/*" | sort -V | color_word "$lookup")")
    done

    becho "IOMMU devices:"
    printf "%s\n" "${group_texts[@]}"

    becho "USB peripherals:"
    lsusb | grep -iF --color=auto "$lookup"

    # To add a device by IOMMU device number (xxxx:xx:xx.x), go to VM Manager, and add "PCI Host Device" with the same number 
}


# TODO - optimize, maybe use list_human_users() ?
# list crontabs of all users
function all_crontabs () {
    cat /etc/passwd | awk -F: '{ print $1; }' \
    | while read user; do
            crontab -u $user -l 2>/dev/null | grep "^[^#*/;]" | awk '{
                    print "'$user': "$0;
            }';
    done
    
    sudo crontab -u root -l 2>/dev/null | grep "^[^#*/;]" | awk '{ print "root: "$0; }';

}


# finds files that shouldnt be executable and chmods them
function revoke_exe_mod () {
    location=${1:-.}  # use given address, default to current location
    format=${2:-'txt'}  # use given format, default to txt
    files=$(find "$location" -type f -name "*.$format")  # get txt (or specified) files recursively
    while read -r file; do
        # if file is executable
        if [ -x "$file" ]; then
            # revoke exe permission (run as sudo IF necessary)
            _sudo_if_necessary "chmod -x \"$file\"" && echo "file no longer executable: $file"
        fi
    done <<< "$files"
}



# File handline (media and data)
# ==============================


# Archive files into .tar.7z format. You can specify any file / file-path, the archive would still be saved to current working directory.
# -o/--overwrite (optional: replace old 7z archive instead of adding another one) ; -p/--password <pass> (optional: encrypt with password) ; all the rest are file-names
function archive_tar7z () {
    # anything unspecified as option/flag is file to archive
    filenames=() ; overwrite='' ; password=''
    while [[ $# -gt 0 ]]; do
    	case "$1" in
    		'-o'|'--overwrite')
    			overwrite='true'
    			shift 1
    			continue
    		;;
    		'-p'|'--password')
    			password="$2"
    			shift 2
    			continue
            ;;
    		*)
                filenames+=("$1")
                shift 1
    		;;
    	esac
    done

    [ -n "$filenames" ] || { recho "You need to specify files (or folders) to archive" ; return 1; }

    # note: don't try running multiple in async; tar and 7z already run multi-threaded
    for f in "${filenames[@]}"; do
        # archive without including whole directory leading to the file
        full_path="$(realpath "$f")"  # get full path
        folderpath="$(dirname "$full_path")"
        filename="$(basename "$full_path")"
        archive_name="${filename}.tar.7z"

        # determine if the archiving will be done with encryption (password-protected)
        optional_encryption=''
        if [ -n "$password" ]; then  # entering an empty string as password doesn't (and shouldn't) count as password
            becho "writing $archive_name with password encryption"
            optional_encryption="-p$password"
            archive_name=$(echo "$archive_name" | sed 's/.tar.7z$/_encrypted.tar.7z/')  # add "_encrypted" to file suffix name. You can't mix encrypted and unencrypted, so they shouldn't be named the same way
        fi

        # if similarly-named archive exists (involves overwrite-flag)
        if [ -e "$archive_name" ]; then
            already_exists_msg=$(recho "archive \"$archive_name\" already exists")
            if [ -n "$overwrite" ]; then 
                echo "$already_exists_msg. Removing it."
                rm "$archive_name"
            else
                echo "$already_exists_msg. Creating archive with current date."
                archive_name=$(echo "$archive_name" | sed "s/.tar.7z$/_$(date +%Y-%m-%d).tar.7z/")  # add "_<today>" to file suffix name to avoid mixing with old archive
                [ -e "$archive_name" ] && rm "$archive_name" && recho "deleted an existing archive with the same name-date"  # if even the dated archive exists, delete it
            fi

        fi
        
        tar -C "$folderpath" -cvzf - "$filename" | 7za a -si "$archive_name" "$optional_encryption"
    done
    
}

# arg 1: media_file
function media_remove_audio () {
    output="${1%.*}_noaudio.${1##*.}"  # add "_noaudio" before the file's .<format>
    ffmpeg -i "$1" -c copy -an "$output"
}

# usage: -v/--video <video_file>  -a/--audio <audio_file>
function media_merge_audio_video () {
    video_file='' ; audio_file=''
    while [[ $# -gt 0 ]]; do
    	case "$1" in
    		'-v'|'--video')
    			video_file="$2"
    			shift 2
    			continue
    		;;
    		'-a'|'--audio')
    			audio_file="$2"
    			shift 2
    			continue
            ;;
    		*)
                recho "${FUNCNAME[0]} doesn't know how to handle arg: '$1'"
                return 1
    		;;
    	esac
    done

    [ -z "$video_file" ] && recho "no video file specified" && return 1
    [ -z "$audio_file" ] && recho "no audio file specified" && return 1

    output="${video_file%.*}_replaced_audio.${video_file##*.}"  # add "_replaced_audio" before the video file's .<format>

    ffmpeg -i "$video_file" -i "$audio_file" -c:v copy -c:a libvorbis "$output"
}

# compare between media files
# all args are media-file paths
function media_compare () {
    md_results=()
    for i in "$@"; do md_results+=("$(media_metadata "$i")"); done
    _side_by_side --lined "${md_results[@]}" 
}

# TODO - create a function that uses youtube-dl and other website downloaders; have it accept any download-link. 


# ----- Microsoft handling 

# fix device-mountable-as-read-only issue, caused by Windows leaving some garbage on the disk
function prepare_ntfs_for_writable_mount () {
    lsblk -o UUID,NAME,FSTYPE,LABEL | awk 'NR==1 || $3 == "ntfs"'

    read -p "Choose a UUID to fix (with chkdsk) from the above device-list: " uuid  # Read the user's input
    
    lsblk -o UUID,NAME,FSTYPE,LABEL | awk -v uuid="$uuid" 'NR==1 || $1 == uuid'
    if _prompt_yn "Are you sure this is the right device?"; then echo "Running. Don't touch the device until we're done..."; else echo "Quitting." && return ; fi

    # unmount if necessary
    if findmnt -o UUID | grep "$uuid" > /dev/null; then umount -l "/dev/disk/by-uuid/${uuid}"; fi

    # fix ntfs device
    sudo ntfsfix -b "/dev/disk/by-uuid/$uuid"
}


# TODO
# function reinstall() { : 'performs remove and then install'
#     if [] then;
#     sudo apt remove "$1" -y && sudo apt install "$1" -y
#     fi
#     else
#     echo "package $1 isn't even installed"
# }


# Debug and Check Operations
# ==========================

# Writes data to volume, to check its capacity. Careful: DESTRUCTIVE!!!
function test_drive_volume () {
    if [ -z "$1" ]; then echo "You didn't provide a drive-name (run lsblk if you're not sure. Should be like '/dev/sdg' ). Aborting." && return 1 ; fi
    
    if _prompt_yn "Your data on $1 is about to be destroyed. Are you sure?"; then echo "Running. Don't remove the device."; else echo "Aborting." && return 1 ; fi
    sudo f3probe --destructive --time-ops "$1"
}



# Info: Stats
# ===========

# get comprehensive overview of devices/volumes
function devs() {
    # df results (mounted volumes)
    df_results=$(df -h -x tmpfs --output=source,fstype,itotal,ipcent,size,pcent,file,target)
    df_title=$(echo "$df_results" | head -n1)
    df_content=$(echo "$df_results" | tail -n+2 | sort -k1,1)
    df_results=$(echo -e "${df_title}\n${df_content}" | _pad_end_w_spaces)  # reattaching (now the contents are sorted), and ending lines neatly

    # device names (used as identifiers)
    df_devices=$(echo "$df_content" | awk 'NR>1 {print $1}')
    lsblk_devices=$(lsblk -o PATH | tail -n+2 | sort)

    # lsblk minus df results
    # ----------------------
    unmounted_devices=$(comm -23 <(echo "$lsblk_devices") <(echo "$df_devices"))  # devices in lsblk but not df
    lsblk_unmounted=$(lsblk -d $(paste -sd ' ' <<< "$unmounted_devices") -o PATH,MODE,FSTYPE,SIZE,LABEL,TYPE,PTTYPE,MODEL,STATE --sort PATH) 
    
    # df results + extra data for same entries
    # ----------------------------------------
    lsblk_complementary_to_df=$(lsblk -d $(paste -sd ' ' <<< "$df_devices") -o MODE,LABEL,TYPE,PTTYPE,MODEL,STATE,PATH --sort PATH)  # same devices as in df, different columns
    # map the extra data in lsblk to "PATH", which is the same as lsblk's "Filesystem"
    declare -A lsblk_hashmap
    while read -r line; do
        key="${line##* }"
        value="${line% *}"
        lsblk_hashmap["$key"]="$value"
    done <<< "$lsblk_complementary_to_df"
    lsblk_hashmap['Filesystem']=${lsblk_hashmap['PATH']}
    
    # place the maps right after the df results
    df_and_lsblk=()
    while IFS= read -r line || [[ -n "$line" ]]; do
        dev_name=$(echo $line | awk '{print $1}')
        modified_line="$line ${lsblk_hashmap[$dev_name]}"
        df_and_lsblk+=("$modified_line")
    done <<< "$df_results"
    
    
    # print results
    becho 'mounted volumes:'  # results from df with extra details on the same entries from lsblk
    for i in "${df_and_lsblk[@]}"; do echo "$i" ; done

    becho 'non-mounted volumes:'
    echo "$lsblk_unmounted"

    becho 'identifiers and metadata:'
    lsblk -a -o NAME,MOUNTPOINT,LABEL,UUID,PTUUID,PARTUUID,SERIAL | awk 'NR==1 || ($1 !~ "loop[0-9]")'
}


# list password-owning users with uid >= 1000.
# --max_uid <number> (listed users' uid limit)  ; --require_home (only list users with home-dir) 
function list_human_users() {
    # defaults
    max_uid_filter=''  # no extra filtering
    require_home='false'
    while [[ $# -gt 0 ]]; do
    	case "$1" in
            '--max_uid')
    			max_uid_filter="&& \$3 <= $2"
    			shift 2
    			continue
    		;;
            '--require_home')
    			require_home='true'
    			shift 1
    			continue
    		;;
            *)
                recho "${FUNCNAME[0]} doesn't know how to handle arg: '$1'"
    			shift
    		;;
        esac
    done

    users=$(getent passwd | awk -F: '$3 >= 1000 '"$max_uid_filter"' {print $1}')  # get all users with uid >= 1000, maybe with a limit (because uid increments by 1)
    for user in $users; do      
      if [ "$require_home" == 'false'  ] || [ -d "/home/$user" ]; then  # if homedir isn't required, or if it is and it does exist
          echo $user
      fi
    done
    echo "root"  # always assume root might be humanly-used somewhere
}


# list users and their various resources usage.
# --gpu (also display gpu data) ; --not_sudo (don't try to get restricted data as root)
function resources_used () {
    maybe_sudo=$([[ "$@" =~ ^"--not_sudo"$ ]] && echo "" || echo "_sudo_if_necessary")  # if flagged, run regularly as non-superuser. If not, try inputting password in case it's necessary

    thread_count=$(nproc)
    bottleneck_threshold=$(echo "scale=3; 100/$thread_count" | bc -l)

    # human-users lookup    
    human_users=$(list_human_users --max_uid 2000)
    eval $(_hashmap_this_var 'human_users')  # create hashmap: human_users_map

    current_users=$(ps -eo user= | sort | uniq)  # all current users running on the system
    eval $(_hashmap_this_var 'current_users')  # create hashmap: current_users_map

    all_users=$(echo -e "$current_users\n$human_users" | sort | uniq)  # all users (joined list but kept only unique)
    headers='USER,CPU,RAM,@HOME-size'
    usage_summary=''
    for user in $all_users; do
        # determine if the line would be printed in color
        prnt_cmd=$([ -n "${human_users_map[$user]}" ] && echo "gecho" || echo "echo")  # ternary for choice of command to use
        # CPU usage%, "-" if not in "current_users" (users in process list)
        cpu_usage=$([ -n "${current_users_map[$user]}" ] && echo $(ps -u $user -o %cpu,%pid | awk '{cpu+=$1} END {printf "%.2f%%\n", cpu/'$thread_count'}') || echo "-")  # user's CPU usage. Divided by num of threads because a ps line with 100% is just 100% single-thread, not 100% on all cores
        # RAM usage%, "-" if not in "current_users" (users in process list)
        mem_usage=$([ -n "${current_users_map[$user]}" ] && echo $(ps -u $user -o %mem= | awk '{mem+=$1} END {print mem"%"}') || echo "-")  # user's RAM usage
        # Disk usage of user's home-dir. "-" if home-dir doesn't exist
        disk_usage=$([ -d "/home/$user" ] && echo $($maybe_sudo du -sh "/home/$user" | cut -f1) || echo "-")  # specify home-dir disk usage (if applicable)

        current_user_usage=$($prnt_cmd "$user\t$cpu_usage\t$mem_usage\t$disk_usage")  # data display format, including the optional coloring
        usage_summary="$usage_summary\n$current_user_usage"
    done

    # get cpu stat directly from /proc/stat , without the rounding errors in "top" ; line from https://stackoverflow.com/questions/9229333/how-to-get-overall-cpu-usage-e-g-57-on-linux
    total_cpu_usage=$(awk '{u=$2+$4; t=$2+$4+$5; if (NR==1){u1=u; t1=t;} else print ($2+$4-u1) * 100 / (t-t1) "%"; }' <(grep 'cpu ' /proc/stat) <(sleep 1;grep 'cpu ' /proc/stat))
        # total_cpu_usage=$(cat <(grep 'cpu ' /proc/stat) <(sleep 1 && grep 'cpu ' /proc/stat) | awk -v RS="" '{print ($13-$2+$15-$4)*100/($13-$2+$15-$4+$16-$5)}')  # also works
    total_ram_usage=$(free -h | awk '/^Mem:/ {print $3 "(+" $6 " buff/cache) / " $2}')
    total_disk_usage=$(df -h / --output=used,size,iused,itotal | tail -n+2 | awk '{ print $1 " / " $2 " ("$3 " / " $4" inodes)"}')

    echo "Computing units count: $(becho $thread_count)"
    echo "If your overall CPU usage reaches $(becho $bottleneck_threshold%), your CPU is possibly bottlenecked on a single thread."

    echo "$(uecho 'Resources currently taken by users:') *verified human users are colored **results are subject to slight shifts over runtime, partially due to this very script's running."
    echo -e "$usage_summary" | column -t -s $'\t' -N "$headers"

    echo "$(uecho 'Total CPU usage:') $total_cpu_usage"
    echo "$(uecho 'Total RAM usage:') $total_ram_usage"
    echo "$(uecho 'Total Disk usage:') $total_disk_usage  *For '/' only. Run devs function to see more."  
    # TODO - check if there is a GPU at all, and support AMD (or Intel) drivers (need to detect)
    [[ "$@" =~ ^"--gpu"$ ]] && ( uecho "GPU utilization info:" ; nvidia-smi -q -d MEMORY,COMPUTE,UTILIZATION ) # if flag --gpu is specified
    
}


# search network activity by port (specify number) or substring
function network_search () {
    if [ -z "$1" ]; then echo "You didn't provide anything to filter by. Aborting." && return 1 ; fi
    
    if [[ $1 =~ ^[0-9]+$ ]]; then  # numerical - filter as a port number
        sudo netstat -tulpn | grep ":$1"
    else  # non-numerical, look-up as a substring
        sudo netstat | grep -iF --color=auto "$1"
    fi
}

# get local files size and inner-files count
# arg1: dir to explore , -s (optional: sort by size)
function explore () {
    location=${1:-.}  # use given address, default to current location
    location=$(readlink -f "$location")  # use absolute path (and use no '/' at the end)

    folders=""
    files=""
    total_files=0  # Files (recursive) counter. Can technically just recount current dir, but the results might not be cached

    filenames=$(find "$location" -maxdepth 1 -type f,d,l)  # get files (files, dirs, links) in given dir
    filenames=$(echo "$filenames" | grep -vw "^$location$")  # throw out the given location (exact match from line start to end)

    [ -z "${filenames}" ] && return 1  # nothing to iterate over

    while IFS= read -r filename; do
        size=$(du -sh "$filename" | cut -f1)  # determine size (same command for files/folders)
        inodes=$(du -s --inodes "$filename" | cut -f1)
        count=$(find "$filename" -type f,l | wc -l)  # count files and links found. It's just '1' for a file, but the code's shorter this way
        total_files=$(($total_files + $count))

        # handle as dir or file
        if [ -d "$filename" ]; then folders+="$size\t$count\t$inodes\t$filename/\n";
        else files+="$size\t$count\t$inodes\t$filename\n";
        fi
    done <<< "$filenames"

    data="${folders[@]}${files[@]}"    
    [[ "$@" =~ ^"-s"$ ]] && data=$(echo -e "${data}" | sort -h)  # if flag -s specified, sort ; first datum is size, so that's what we sort by
    echo -e "${data}" | column -t -s $'\t' -N $(becho "total_size,file_count,inodes,name")  # separate nicely with tabs
    echo "current dir total files: $total_files"
    echo "current dir total size: $(du -sh "$location" | cut -f1)"
    echo "current dir inodes use: $(du -s --inodes "$location" | cut -f1)"
}


# Info: Lookup
# ============

# case-insensitive lookup on all files in dir (and subdirs).
# -d <dir> (specify lookup start, default is ".") ; -e <expression> (looked-up expression/substring) ; --text_limit <limit> (how long the results may be, default is maximum: 5000) ; --text_limit_short (same as --text_limit 500) ; --text_limit_medium (same as --text_limit 5000) / --text_limit_unlimited (unlimited response length)
function supergrep () {
    [ $# -ge 1 ] || { echo "You must provide at least one argument, for the lookup-expression" ; return ; }
    # we have a text-length limit to skip gibbrish and text-dumps. It's allowed over 4k, since that's the minimum file-path length.
    text_limit_default='5000'
    first_free_arg_is_exp=''
    dir='.' ; exp=''; text_limit="$text_limit_default"; verbose=''  # defaults, and clearing (in case they're set)
    while [[ $# -gt 0 ]]; do
    	case "$1" in
    		'-d'|'--directory')
    			dir="$2"
    			shift 2
    			continue
    		;;
    		'-e'|'--expression')
    			exp="$2"
    			shift 2
    			continue
            ;;
            '-t'|'--text_limit')
                text_limit="$2"
                shift 2
                continue
            ;;
            '-s'|'--text_limit_short')
                text_limit="500"
                shift
                continue
            ;;
            '-m'|'--text_limit_medium')
                text_limit="5000"
                shift
                continue
            ;;
            '-u'|'--text_limit_unlimited')
                text_limit="-1"
                shift
                continue
            ;;
            '-v'|'--verbose')
                verbose='true'
                shift
                continue
            ;;
            '--help')
                echo -e "bashrc function \"${FUNCNAME[0]}\"
Summary: Grep all files and filenames at a location, recursively. Case-insensitive.
example: supergrep 'to do'
example2: supergrep -d /etc/systemd/ -e restart -v -u 
args:
    -d|--directory <dir_path>\t set the search-dir
    -e|--expression <exp>\t set the search term. You can also set it without a flag
    -t|--text_limit <number>\t set the lext-length limit of lines found. Default is $text_limit_default
        -s|--text_limit_short\t set the lext-length limit of lines found to 500. Equivalent to: -t 500
        -m|--text_limit_medium\t set the lext-length limit of lines found to 5000. Equivalent to: -t 5000
        -u|--text_limit_unlimited\t do not set lext-length limit of lines found. Equivalent to: -t -1
    -v|--verbose\t run in debug mode
    --help\t print this message
"
                return
            ;;
    		*)
                if [ -z "$first_arg_used_as_exp" ]; then
                    first_free_arg_is_exp='true'
                    exp=$1
                else
                    recho "${FUNCNAME[0]} doesn't know how to handle arg: '$1'"
                fi
    			shift
    		;;
    	esac
    done

    [ -z "$exp" ] && echo "No expression specified. Use -e <expression> to set it." && return 1
    
    [ -n "$verbose" ] && becho "running on directory: $dir  ;  expression: $exp  ;  including strings up to length: $text_limit"  # print found arguments (if verbose)

    becho "matching filenames:"
    becho "==================="
    _sudo_if_necessary "find \"$dir\" -iname \"*$exp*\"" | color_word --word "$exp"

    becho "matching file contents:"
    becho "======================="
    all_results=$(_sudo_if_necessary "grep -e \"$exp\" -Inir \"$dir\" --color=never")  # No colors. Coloring is done at this stage because otherwise it'll add to the string's length
    if [ $(expr "$text_limit" + 0) -gt 0 ]; then  # if there's a limit for result length
        [ -n "$verbose" ] && becho "filtering with maximum result length: $text_limit" 
        all_results=$(echo "$all_results" | awk "length(\$0) <= $text_limit")
    fi
    echo "$all_results" | color_word --word "$exp"  # print with no filtering by length
}



# Interactive launchers/creators
# ==============================

#TODO - offer to choose a vm by number [1-n]. Need to create a function like y_n one that gets a dicitonary as an argument 
# interactively launch looking-glass session and VM (if not running). 
function launch_vm_w_lookingglass() {
    valid=0
    while [ $valid -eq 0 ]
    do
        vm_names=$(virsh list --all --name)
        becho "Choose the name of the VM you want to launch:"
        virsh list --all
        becho "============================================"

        read -p "Enter the name of the VM: " vm_name  # Read the user's input
        if echo $(virsh list --all --name) | grep -w -q "$vm_name"; then  # match whole word (case sensitive), quietly
            valid=1
        else
            recho "Invalid VM name"
        fi
    done

    # look up info within the vm's definitions file
    xml_file="/etc/libvirt/qemu/${vm_name}.xml"

    # get the shmem name:
    shmem_name=$(sudo awk -F 'name=' '/shmem/ {gsub("'\''", "", $2); print $2}' "$xml_file" | sed 's/^"\([^"]*\)".*/\1/' | sed 's/>$//')  # extract the string between the quotes, remove the quotes, remove the closing '>'
    lg_file="/dev/shm/$shmem_name"

    # get the vnc port number from xml
    portnum=$(sudo grep -oP "<graphics type=[\"']spice[\"'] port=[\"']\K\d+" "$xml_file")  # works for either single or double quotes
    portnum=${portnum:=5900}  # default if empty

    # Show user the parameters and ask for approval (quit if disapproved)
    becho "Please authorize the following. Note: no two running VMs may have the same looking-glass session-file or VNC-port at the same time"
    if _prompt_yn "$(becho "VM:") $vm_name, $(becho "looking-glass_name:") $shmem_name, $(becho "VNC-port:") $portnum. Launch with these parameters?"; then echo "Starting..."; else echo "Quitting. If the details were off, modify your VM's xml file (easiest through VM Manager)" && return ; fi

    becho "Making sure os-virtual-drive file's volume is mounted"
    mount_media_by_uuid "$QEMU_VOLUME_UUID"

    becho "Creating looking-glass session file: $lg_file"
    sudo touch "$lg_file" && sudo chown $(whoami):kvm "$lg_file" && sudo chmod 660 "$lg_file"
    [ -f "$lg_file" ] && ls -alF "$lg_file"  # todo - print colored (green?)?
    
    # run the vm (if needed)
    vm_state=$(virsh domstate "$vm_name")
    if [ "$vm_state" == "running" ]; then
        gecho "$vm_name is already running."
    elif [ "$vm_state" == "shut off" ]; then
        virsh start "$vm_name" && gecho "starting $vm_name"
    elif [ "$vm_state" == "paused" ]; then
        virsh resume "$vm_name" && gecho "resuming $vm_name"
    else
        recho "Can't handle VM state: $vm_state"
        if [ "$vm_state" == "blocked" ]; then recho "the VM '$vm_name' is blocked on resource";
        elif [ "$vm_state" == "shutdown" ]; then recho "$vm_name is still shutting down";
        elif [ "$vm_state" == "crashed" ]; then recho "the VM '$vm_name' has crashed";
        elif [ "$vm_state" == "pmsuspended" ]; then recho "the VM '$vm_name' is in a suspended state as a result of power management";
        else recho "Error: VM state isn't defined (fix this function)"
        fi
        return 1
    fi
    
    # run looking glass client
    # experimental -S : Prevent the screensaver from starting  , win:size=1920x1080 : Initial window size at startup (default is 1024x768)
    becho "Starting looking-glass client"
    "$LOOKING_GLASS_CLIENT" -f "$lg_file" -p $portnum -k -S & disown # -k : enable FPS & UPS display  ; -S : prevent host going to sleep

}

# interactively create a new systemd service (using templates)
# arg 1: (optional) service name
function create_systemd_service () {
    if [ -n "$1" ]; then
        service_name="$1"
    else
        read -p "Choose the name of your service: " service_name  # Read the user's input
    fi
    service_name=${service_name%.service}  # remove the '.service' if it's there
    file_name="${service_name}.service"
    service_file="/etc/systemd/system/${file_name}"
    [ -s "$service_file" ] && is_empty='NON-empty file - CONTENTS WILL BE DELETED' || is_empty='empty file'
    if _prompt_yn "You'll modify as sudoer: $service_file ($is_empty). Are you ready?"; then echo "Creating file..."; else echo "Come back when you have everything you need." && return ; fi
    
    # provide a template
    initial_str=''
    _prompt_yn "Need a template?" && read -r -d '' initial_str << EOT
[Unit]
# rewrite this (don't worry about spaces)
Description=<Insert purpose here>
; Before=<what this service should preceed, e.g. "network.target">
; After=<what should run before this service, e.g. "somethingelse.service">

# should dependencies be inherited by unit's After/Before/Conflicts/BindsTo/PartOf/Wants directives?
; DefaultDependencies=yes/no  

[Service]
# you may want a different user.
User=root
; WorkingDirectory=<path to run at, maybe a project-dir>
ExecStart=<command that starts the service>

# no: The service should not be restarted. This is the default value.
# on-success: The service should be restarted when it exits successfully.
# on-failure: The service should be restarted when it exits with a non-zero exit code or when it terminates abnormally.
# on-abnormal: The service should be restarted when it terminates abnormally.
# on-abort: The service should be restarted when it is terminated by a signal.
# always: The service should be restarted regardless of the exit code or termination status.
; Restart=no/on-success/on-failure/on-abnormal/on-abort/always

# simple: The service is a simple service that runs a single command or process. This is the default value.
# forking: The service is a forking service that creates a new process group when it starts. This type of service is typically used for programs that fork and background themselves when they start.
# oneshot: The service is a one-shot service that runs a command or script and then exits. This type of service is typically used for tasks that need to be performed once and then stopped.
# dbus: The service is a D-Bus service that exports objects over the D-Bus message bus. This type of service is typically used for services that communicate over D-Bus.
# notify: The service is a notify service that sends a notification when it is ready. This type of service is typically used for services that need to signal their readiness to other services or clients.
; Type=simple/forking/oneshot/dbus/notify


[Install]
# who should automatically start this service. multi-user.target is common, it's the state in which multiple users can log in
; WantedBy=multi-user.target  
EOT
    # offer template adjustment
    if [ -n "$initial_str" ] && _prompt_yn "Include guiding comments in the template?"; then echo "Leaving in comments."; else initial_str=$(grep -v "^#" <<< "$initial_str") ; fi

    # insert template into the file (create/clear file if necessary)
    sudo sh -c "echo \"$initial_str\" > \"$service_file\""

    # let the user determine the contents of the service
    sudo nano "$service_file"

    if _prompt_yn "We're done. Want me to reload, enable and start the service?"; then
        becho 'reloading systemd...'
        sudo systemctl daemon-reload  # rescan services
    
        becho 'enabling after boot...'
        sudo systemctl enable "$file_name"  # enable after boot
    
        becho 'starting service...'
        sudo systemctl start "$file_name"

        _wait_n_seconds '3'

        becho "Here's its status now:"
        sudo systemctl status "$file_name"
    fi

}


# Visuals
# =======

# get current row-index of cursor
function _get_cursor_row () {
    echo -en "\033[6n" # send the control sequence to query cursor position
    read -sdR CURPOS # read cursor position from input buffer

    # Extract the row number from the cursor position
    echo "$CURPOS" | sed -rn 's/^.*\[(.*)\;.*$/\1/p'
}

# get <arg 1> spaces
function _repeat_space_n_times () {
    for (( i = 0; i < "$1"; ++i )); do echo -n " "; done
}

# create a block of whitespace
# arg 1: height (number of rows), arg 2: width (number of columns)
function _repeat_whitespace_rows () {
    (($1 <= 0)) && return
    (($2 <= 0)) && return
    
    whitespace_line=$(_repeat_space_n_times "$2")
    for (( i=1; i<=$1; i++ )); do
        echo "$whitespace_line"
    done
}

# print string with a similarly-lengthed line
# arg 1: string , arg 2 (optional): line-char (default is '-')
function _underline () {
    char=${2:-'-'}  # determine which char to repeat in underline
    input_string_length=${#1}
    
    line=$(printf "%${input_string_length}s" | tr ' ' "$char")  # Create a line of the specified character with the same length as the input string

    echo "$1"
    echo "$line"
}

# colors a specified substring within given text, like grep without line filtering
# -t/--text <text> (specify text to color, if it's not piped-in) ; -w/--word <word> (substring to color, no option needed if it's the only arg and text is piped-in) ; -c/--color <color-string> (see available colors in "_draw_formatted", default is red)
function color_word () {
    text='' ; word='' ; color='<=bold=><=red=>'
    if [ $# -eq 1 ] && ! [ -t 0 ]; then  # only 1 arg + streamed input. Given arg is the word to color.
        word="$1"
    else  # "regular" case
        while [[ $# -gt 0 ]]; do
        	case "$1" in
        		'-t'|'--text')
        			text="$2"
        			shift 2
        			continue
        		;;
        		'-w'|'--word')
        			word="$2"
        			shift 2
        			continue
                ;;
                '-c'|'--color')
                    color="$2"
                    shift 2
                    continue
                ;;
        		*)
                    return  # received undefined argument
        		;;
        	esac
        done
    fi

    # If text is not provided via --text, and if standard input (piped data) exists : assign standard input to text
    if [ -z "$text" ] && ! [ -t 0 ]; then text=$(cat); fi

    [ -z "$text" ] && return 1  # no text given
    [ -z "$word" ] && echo "$text" && return # no word

    # insert tags around word, I makes it case-insensitive
    _draw_formatted "$(echo "$text" | sed -e "s/$word/$color&<=reset=>/gI")"
}

# TODO - detect if the terminal is bright instead of dark? If it's white, the colored prints should be darker; so you should remove the "\033[1m" prefix
# recolors all lines with specified color
# arg 1: color (ee available colors in "_draw_formatted") , arg 2: text to color
function _colored_echo () {
    # apply colors (arg 1) to all lines
    formatted=$( echo "${@:2}" | while IFS= read -r line; do echo "${1}${line}"; done )
    _draw_formatted "$formatted"  # automatically puts the color reset at the ends of the lines
}
# comment-colorized echo
function commecho () {
    bullet_point_color='<=green=>'
    double_cat_line_color=$(_tag_persist '<=bold=><=blue=>')
    single_cat_line_color=$(_tag_persist '<=blue=>')
    plus_line_color=$(_tag_persist '<=uline=><=yellow=>')
    sharp_comment_color=$(_tag_persist '<=yellow=>')
    colon_comment_color=$(_tag_persist '<=yellow=>')
    angled_brackets_color='<=bold=><=red=>'
    
    reset='<=reset=>'
    formatted="$@"  # get all of the input
    formatted=$(echo "$formatted" | sed -E "s/(<[^>]+>)/$angled_brackets_color\1$reset/g")  # recolor within '< >' (user-choice) but not in lines that get entirely colored  <- needs to run first, to not modify the color tags
    formatted=$(echo "$formatted" | sed "s/^* /${bullet_point_color}*${reset} /g")  # replace beginning '* ' with a colored asterisk and space  (bullet-points)
    formatted=$(echo "$formatted" | sed "s/^>>.*$/${double_cat_line_color}&/g")  # recolor lines beginning '>>'  (topics)
    formatted=$(echo "$formatted" | sed "s/^>.*$/${single_cat_line_color}&/g")  # recolor lines beginning '>'  (sub-topics)
    formatted=$(echo "$formatted" | sed "s/^+.*$/${plus_line_color}&/g")  # recolor lines beginning '+'  (notes)
    formatted=$(echo "$formatted" | sed "s/  #.*$/${sharp_comment_color}&/g")  # recolor after '  #'  (code-comments)
    formatted=$(echo "$formatted" | sed "s/  :.*$/${colon_comment_color}&/g")  # recolor after '  :'  (item-comments)
     _draw_formatted "$formatted"  # automatically puts the color reset at the ends of the lines
}
# echo in red
function recho () {
    _colored_echo '<=bold=><=red=>' "${@}"
}
# echo in green
function gecho () {
    _colored_echo '<=bold=><=green=>' "${@}"
}
# echo in dark green
function dagecho () {
    _colored_echo '<=green=>' "${@}"
}
# echo in blue
function becho () {
	_colored_echo '<=bold=><=blue=>' "${@}"
}
# echo in yellow
function yecho () {
	_colored_echo '<=bold=><=yellow=>' "${@}"
}
# underlined echo
function uecho () {
    _colored_echo '<=bold=><=uline=>' "${@}"
}
# underlined echo in red
function ruecho () {
    _colored_echo '<=bold=><=uline=><=red=>' "${@}"
}
# underlined echo in green
function guecho () {
	_colored_echo '<=bold=><=uline=><=green=>' "${@}"
}
# underlined echo in blue
function buecho () {
    _colored_echo '<=bold=><=uline=><=blue=>' "${@}"
}
# underlined echo in yellow
function yuecho () {
    _colored_echo '<=bold=><=uline=><=yellow=>' "${@}"
}

# make given tag persistant
function _tag_persist () {
    echo "<=persist${@}this=>"
}
# recolors text by replacing color tags with their appropriate color-codes
# arg 1: text
function _draw_formatted () {
    declare -A colors=(
    # colors
    [<=black=>]='\033[30m' [<=red=>]='\033[31m' [<=green=>]='\033[32m' [<=yellow=>]='\033[33m' [<=blue=>]='\033[34m' [<=purple=>]='\033[35m' [<=cyan=>]='\033[36m' [<=grey=>]='\033[37m'
    # bright colors (work like regulat when stylized bold)
    [<=b_black=>]='\033[90m' [<=b_red=>]='\033[91m' [<=b_green=>]='\033[92m' [<=b_yellow=>]='\033[93m' [<=b_blue=>]='\033[94m' [<=b_purple=>]='\033[95m' [<=b_cyan=>]='\033[96m' [<=b_grey=>]='\033[97m'
    # highlights / markers (can be switched with text color using 7m). If you want to "hide" text as a solid block of color run the same colors for both (i.e. \033[43m\033[33m)
    [<=h_black=>]='\033[40m' [<=h_red=>]='\033[41m' [<=h_green=>]='\033[42m' [<=h_yellow=>]='\033[43m' [<=h_blue=>]='\033[44m' [<=h_purple=>]='\033[45m' [<=h_cyan=>]='\033[46m' [<=h_grey=>]='\033[47m'
    # bright backgrounds (highlights)
    [<=bh_black=>]='\033[100m' [<=bh_red=>]='\033[101m' [<=bh_green=>]='\033[102m' [<=bh_yellow=>]='\033[103m' [<=bh_blue=>]='\033[104m' [<=bh_purple=>]='\033[105m' [<=bh_cyan=>]='\033[106m' [<=bh_grey=>]='\033[107m'
    # stylizing
    [<=bold=>]='\033[1m' [<=dark=>]='\033[2m' [<=italic=>]='\033[3m' [<=uline=>]='\033[4m' [<=flicker=>]='\033[5m' [<=fast_flicker=>]='\033[6m' [<=switch_fg_bg=>]='\033[7m' [<=hidden=>]='\033[8m' [<=crossed=>]='\033[9m'
    # reset
    [<=reset=>]='\033[0m'
    )

    # basic preparations
    text_to_draw="$1"
    reset_key='<=reset=>'

    # apply persistance by tags
    # -------------------------
    # persistence means that a specified color-tag needs to return by default (after other specified colors are reset) for the rest of the line
    persist_tag_open='<=persist'
    persist_tag_close='this=>'
    # If there's use of persistence, handle it line-by-line. If not, skip it (save time)
    [[ "$text_to_draw" =~ ($persist_tag_open)(.*)($persist_tag_close) ]] && text_to_draw=$(
        echo "$text_to_draw" | while IFS= read -r line; do  # read current text line by line (without losing the leading/trailing spaces)
            if [[ "$line" =~ (.*)($persist_tag_open)(.*)($persist_tag_close)(.*) ]]; then  # each line can have up to 1 persisting color-tag
                part_to_leave_alone="${BASH_REMATCH[1]}"
                tag_to_persist="${BASH_REMATCH[3]}"  # get the tag that's necessary to persist
                part_to_modify="${BASH_REMATCH[5]}"
                modified="$(echo "$part_to_modify" | sed "s/$reset_key/${reset_key}${tag_to_persist}/g")"  # attach the persisting tag after each reset tag
                echo "${part_to_leave_alone}${tag_to_persist}${modified}"  # we place back the cleaned tag and modified line, skipping the opening/closing tag, they're no longer needed.
            else
                echo "$line"
            fi
        done
    )

    # add resets
    # ----------
    reset_value="${colors[$reset_key]}"
    reset_value_escaped=$(printf "%q" "$reset_value")  # for sed. It needs pre-reset string.
    regex_tag='<=[a-zA-Z_]+=>'
    regex_ws_tag='<=([0-9]+)WS=>'
    text_to_draw="${text_to_draw//$reset_key/$reset_value}"  # replace reset on its own, because otherwise we'd replace it with 2 consecutive color resets (still works, but isn't right)
    text_to_draw=$(echo "$text_to_draw" | sed -r "s/($regex_tag)/$reset_value_escaped\1/g")  # put reset before each color tag
    text_to_draw=$(echo "$text_to_draw" | sed -r "s/($regex_tag)($reset_value_escaped)($regex_tag)/\1\3/g")  # delete reset in between tags (to avoid canceling-out the prior tag)
    text_to_draw=$(echo "$text_to_draw" | sed -r "s/($regex_tag)($reset_value_escaped)($regex_tag)/\1\3/g")  # doesn't work for 3 consecutive tags, so we just repeat it...
    text_to_draw=$(echo "$text_to_draw" | sed -r "s/($regex_ws_tag)/$reset_value_escaped\1/g")  # put reset before spaces-insert
    text_to_draw=$(echo "$text_to_draw" | sed -r "s/$/&$reset_value_escaped/g")  # add resets at the ends of lines

    # insert whitespaces
    # ------------------
    repeated_char=' '
    while [[ "$text_to_draw" =~ '<='([0-9]+)'WS=>' ]]; do  # while there's still a whitespace-tag
        num="${BASH_REMATCH[1]}"
        numtag="<=${num}WS=>"
        repeats=$(printf "%${num}s" | tr " " "$repeated_char")  # create a sequence of <num> spaces
        text_to_draw="${text_to_draw//$numtag/$repeats}"
    done

    # swap-in all the colors (replace keys with values)
    # -------------------------------------------------
    for str in "${!colors[@]}"; do
        text_to_draw="${text_to_draw//$str/${colors[$str]}}"
    done

    echo -e "$text_to_draw"

}

# the best function in this entire collection
function draw_hentai () {
    HY='<=b_yellow=>'  # Hair Yellow
    HYD='<=yellow=>'  # Hair Yellow Dark
    S='<=reset=>'  # skin
    SD='<=b_red=>'  # Skin Dark
    EW='<=b_grey=>'  # Eyes white
    W='<=grey=>'  # teeth White
    WD=$S  # teeth White Dark
    WS='<=dark=><=b_grey=>'  # White Shirt
    WSD='<=b_black=>'  # White Shirt Dark
    G='<=dark=><=red=>'  # Glove and eyebrows Brown
    GD='<=b_black=>'  # Glove Brown Dark
    D='<=dark=><=b_black=>'  # dark
    
    declare -A SPR # whitespaces that'll reset colors in drawing
    for num in {1..25}; do SPR[$num]="<=${num}WS=>"; done
    declare -A SP # whitespaces. just spaces.
    for num in {1..25}; do SP[$num]="$(_repeat_space_n_times ${num})"; done
    WS_unconventional='⠀'

    # don't try to peek at the drawing here, go run the command in terminal
    read -r -d '' surprise << EOM
${SPR[17]}$HY⠰⡘⡸⢏$HYD⠼⠋$HY⡀⣱$HYD⢏⣾⣿⣿⣿⣿⣿⣿⣿⣧⠻⣿⣿⣷⣦$HY⡪⡳⠹⣷⣀⣀
${SPR[17]}$HY⢀⣽⣿⡶⣢⢸$HYD⡇⡏⣾⣿⠹⣿⣆⢻⣿⣇⢿⣿⣷⡙⠿⣿⣿⣿⣮$HY⠢⣽⡯⡑⠂
${SPR[17]}$HY⢘⣷⡱$HYD⣾⡟⠊⠧⠈⠟⢿⣧⢙⠻⣇⠙⢿⣎⢛⡻⠿⠦⠐⠩⠭⣭⣷⡜$HY⢷⡌⠄
${SPR[15]}$HY⠢⠴⣾⣛$HYD⢱⣿⡑$S⡀$HYD⡀⠄$S⢸$SD⢧$HYD⠹⠸⠁⣈${SP[1]}⣰$SD⠌⣥$HYD⡈⢙⣿⠻⢛$SD⠭$HYD⠻⣿⡄$HY⡸⣧
${SPR[16]}$HY⠠⢪⣇$HYD${SP[1]}⣇⢳${SP[1]}$S⣇⢻⡄$HYD⠆⡁$EW${SP[2]}$HYD⠁$EW⣀$SD${SP[1]}⢾⣿⣿⣶${SP[1]}⣰⢁⡛⠇$HYD⢿⣿$HY⢸⡇
${SPR[16]}$HY⠁⢸⢻$HYD⡰$S${SP[1]}$G⠈⠐$S⠩⠸⣄${SP[1]}⠢⣀$EW⠃$S⣀⣴⣿⣷⣮$SD⢻⣿⢠⡟⠠⢛⡘$HYD⢸⡏$HY⡞⠤
${SPR[17]}$HY⢀⡌$HYD${SP[1]}⡴⣆$EW⠠$S${SP[1]}⣠⣷⣵⣿⣿⣿⣿⣿⣿⣿⣿$SD⣿⣿⣿⡿⠒⢅$HYD⣴⣿⠃$HY⢎⢩⡄⡀
${SPR[20]}$HYD⠃⠿$S⢸⣿⡇⢙⠿⠛⣻⣿⣿⣿⡿⣿⡇$SD⣿⣿⣿⡇$HYD⠰⣾⣿⣿$HY⢸⠈⠃⠉⠁
${SPR[23]}$S⢿⣿⡶⠬⡾⠿⣛⣛⢛⢰⣿⡇$SD⣿⣿⣿⡇⢧$HYD⡉⠻⢿$HY⠂⢃
${SPR[23]}$S⠈⢻⣿⣆$W⠋⠉$D⣀⣀⠂$S⣾⣿$SD⢸⣿⣿⠛${SP[1]}⠸⠁⠆$HYD⣾⣦$HY⡲⡒⠂
${SPR[25]}$S⠙⢿⣇$W⠘⠻⢕$S⣴⣿⡏$SD⣾⠟⣡⠆⠄${SP[3]}$HYD⠹⠟⠃$HY⢈⠷⡀
${SPR[11]}$G⣀⣀⣠$S⢠⡀${SPR[10]}$S⠈⢻⣟⠫⢍⣰⡿$SD⢐⣥⣾⠟${SP[9]}$HY⢠⠈
${SPR[8]}$G⣠⠠⠴⠦$S⣻⣿⠌$SD⣴${SP[1]}⣐⣺⣿⠷${SPR[7]}$S⠛⠿⠟$SD⣩⣴⣿⠿⠁${SP[10]}$HY⢸⡆
${SPR[6]}$G⣀⡌⢦⡙$S⠰⠿⠟$SD⢁⢡$GD⣾$SD⠸⣿⠏${SPR[8]}$WS⢤⣶⣆$SD⠇⣼⠟⠁${SP[1]}$SD⢀⣀⣀⡤⠤⣤$WSD⣶⣶⠆${SP[2]}$HY⠸⠇
${SPR[5]}$G⣼⢻⡟⣪$S⡘⠿$SD⠉⣸$GD⡿⠘⠋${SPR[9]}$WS⡄⠦⠠⡀$WSD⠹⡄${SP[2]}⠴⣾⠿⠙⠉⠁${SP[1]}⢹⣿⡇
${SPR[3]}$G⣠⣰⣿⠄$SD⠘⣿⠍$GD⢰⢣⡿⠃${SPR[11]}$WS⢇⢠⢀$WSD${SP[2]}⠁⣄${SP[1]}⢀⣰⡀⢀⠤⡆⠠${SP[1]}⠃${SP[2]}⢀⣴⣶⣿⢿⣿⣿⣿⡶⠖⠒⠢
$G⣀⣿⠟$GD⣴⣿⣿⣦⡣⠡${SP[1]}⠛${SPR[9]}$WS⣀⣠⣭⣭⣵⣮⡙⢾⣷⡆$WSD⠐⣿⣷⣾⣿⣿⣗⡤⡴⠐${SP[1]}⣠⣴⣿⣿⣿⣿⡿⠟⠋
$G⣼⡟$GD⣸⣿⣿⠋⠁${SPR[8]}$WS⣀⣬⣶⣾⣿⣿⣿⣿⣿⣿⣿⡿⡊⢋⣉⣬⣬$WSD⡰⣿⣿⡟⠋⢁⣠⣶⣿⣿⣿⣿⣿⣿⠫⠃${SPR[8]}$WSD⣀⣤⣾⣿
${SPR[2]}$GD⠈⠉${SPR[8]}$WS⢀⣴⢇⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠏⢠⣾⣿⣿⣿⣿⣿⣎$WSD⠻⣿⣿⣿⣿⣿⣿⣿⣿⡿⠿⠇${SPR[7]}$WSD⢀⣤⣾⣿⣿⣿⢿
\x59\x4f\x55\x20\x57\x45\x52\x45\x20\x45\x58\x50\x45\x43\x54\x49\x4e\x47\x20\x4c\x45\x57\x44\x53\x2c\x20\x42\x55\x54\x20\x49\x54\x20\x57\x41\x53\x20\x4d\x45\x2c\x20\x44\x49\x4f\x21
EOM

    _draw_formatted "$surprise"
}


# wait <arg 1> seconds, print a dot for each second passed.
function _wait_n_seconds () {
    printf "Waiting $1 seconds"
    for ((i=0; i<$1; i++))
    do
        printf "."  # Print a dot and flush the output to ensure that it is printed immediately
        sleep 1
    done

    printf "\n" # Print a newline after the dots
}


# Provide command as args; it'll run async, while ascii animations would play until the command's thread closes.
# Example: _spinning_wait_for_task sleep 10
function _spinning_wait_for_task () {
    local cmd=("$@")
    "${cmd[@]}" &  # Run the command in the background
    local pid=$!  # Get the PID of the background process
    local chars=('\' '|' '/' '-')
    local i=0
    while [ -d /proc/"$pid" ]; do
        i=$(( (i+1) % 4 ))
        printf "\r%s Running: %s" "${chars[$i]}" "${cmd[*]}"
        sleep 0.1
    done
}


# short "LET'S GO" animation. -v : verbose (debugging)
function animate_lets_go () {
    # Define the animation frames as an array of strings
frame1="    
⠀⢀⣤⡤⣄⠀
⣴⢿⢿⢳⢛⠂
⠿⣘⢱⣦⡤⠃
⣦⣿⡏⠉⢢⠀
⠈⣷⣞⣟⡅⠀
"
frame2="
⠀⣠⣴⠖⣦⠀
⣾⢻⠻⠻⠩⡁
⠻⣮⣸⣿⠶⠁
⣶⣟⠀⢀⣵⣦
⠛⠁⠉⠁⠙⠁
"

banner=" 
    ####      *########  ##########  ##  #######*      #########   ,####n###  
   ,###       ##r          a##     ##n ###/         ,####         ####    ###)
   ###       #######(     ###         /#####,      ,###/  o####  ####     ####
  ##b       *###         ###             d####     ####    *### .###,    #### 
 ######### ,########    ###          #######/      #####_####/   ####_#####   
"

    # there are spaces here, in case your IDE doesn't show you that easily

    # draw runner "spreading" the banner by having it revealed behind him, than runner "disappears" into an invisible wall
    # how it's done:
    # runner is "pushed" by an ever-extending banner from 1 to full length
    # once banner is full length, runner is "pushed" by an extra invisible window of spaces
    # the invisible wall appears after the [full width of the banner + invisible window] , so that the window would keep pushing the runner past it 

    # ----------- Define sprites, and terminal limits -----------
    is_verbose=''
    [[ "$@" =~ ^"-v"$ ]] && is_verbose='true'

    terminal_width=$(tput cols)
    terminal_height=$(tput lines)
    banner_width=$(sed -n '2p' <<< "$banner" | wc -c)  # width of banner, going by 2nd line
    runner_width=$(sed -n '2p' <<< "$frame1" | wc -c)  # width of runner, going by 2nd line of the first frame
    sprite_height=$(($(echo "$banner" | wc -l)-1))  # same for all sprites involved

    runner_frames=("$frame1" "$frame2")
    runner_frames_count="${#runner_frames[@]}"

    # check that the screen is wide enough
    necessary_terminal_width=$((banner_width + runner_width))
    if ((necessary_terminal_width > terminal_width)); then recho "Cancelled animation-playing; your terminal needs to be wider." ; return 1 ; fi
    # check that the screen is high enough
    necessary_terminal_height=$sprite_height
    if ((necessary_terminal_height > terminal_height)); then recho "Cancelled animation-playing; your terminal needs to be higher." ; return 1 ; fi
    # make sure that there's vertical space for the ascii animation
    if [ -n "$is_verbose" ]; then
        clear  # make more room for the extra prints
    else
        # make the necessary room needed for the animation
        for ((el=1; el<=$necessary_terminal_height; el++)); do echo ; done  # put new lines below
        tput cuu $necessary_terminal_height  # go back up, to make future use of added lines
    fi


    # ----------- Define iteration variables -----------
    progress_speed=3  # positions moved in each iteration (minimum 1)
    total_run=$terminal_width  # $(( banner_width + window_width ))  # the total run distance (not drawing beyond that). Runner starts fading at $((total_run - runner_width))
    iter_time=0.035  # iteration time in seconds
    min_key_input_time=0.003  # minimum time to listen to user input

    exit_key=''  # save the pressed key that stopped the animation

    # ----------- Animation iteration -----------
   
    echo -ne "\033[s"  # Save cursor position

    # arg 1: n (width to reveal) , arg 2: text-block to partially reveal
    function _reveal_first_n_cols () {
        [ "$1" -le 0 ] && return  # negative or 0 width wanted. Return nothing.
        max_width=$(sed -n '2p' <<< "$2" | wc -c)  # width of sprite, going by 2nd line
        
        if [ "$1" -lt "$max_width" ]; then echo "$2" | awk '{print substr($0, 1, n)}' n=$1;  # partially reveal the text
        else echo "$2";  # revealing-width is too big, just echo back everything
        fi
    }

    # d is total distance progressed
    for ((d=1, runner_i=0; d<=$total_run; d+="$progress_speed" , runner_i++ , runner_i%=runner_frames_count)); do
        time_start=$(date +%s.%N)

        window_dist=$((d - banner_width))  # extra distance of runner past banner, minimum is 0 (starts counting up once banner is full)
        runner_width_still_visible=$((total_run - d))  # how much of the runner gets drawn (drawn fully until reaching the wall).

        banner_sprite=$(_reveal_first_n_cols "$d" "$banner")
        extra_dist_sprite=$(_repeat_whitespace_rows "$sprite_height" "$window_dist")
        cut_back_runner_sprite=$(_reveal_first_n_cols "$runner_width_still_visible" "${runner_frames[$runner_i]}")  # runner disappears into an invisible wall, by drawing less of it as it runs further away
        _side_by_side --glued --no_padding "$(gecho "$banner_sprite")" "$extra_dist_sprite" "$cut_back_runner_sprite"
        
        [ -n "$is_verbose" ] || echo -ne "\033[u"  # Restore cursor position (but not if you're debugging - you need to see each frame)

        # TODO - shorten iteration time (optimize)
        # wait for the rest of the iteration
        time_remaining=$( echo "$time_start + $iter_time - $(date +%s.%N)" | bc )
        key_press_wait=$(max "$time_remaining" "$min_key_input_time")
        read -t "$key_press_wait" -N 1 exit_key && break

        [ -n "$is_verbose" ] && echo "banner_width: $banner_width , runner_width: $runner_width , total_run: $total_run"
        [ -n "$is_verbose" ] && echo "iteration took $( echo "$(date +%s.%N) - $time_start" | bc )'s , key_press_wait: ${key_press_wait}s , distance-window width: $window_dist , distance ran: $d , distance remaining: $runner_width_still_visible"
        

    done

    # dim the banner (and progress the cursor) by pasting over it at-once
    echo -ne "\033[u"  # Restore cursor position
    banner_final=$(dagecho "$banner")  # recolored banner
    space_window_final=$( _repeat_whitespace_rows "$sprite_height" $(($total_run - $banner_width)) )
    _side_by_side "$banner_final" "$space_window_final"
    if [ -z "$exit_key" ]; then  # if the user didn't terminate manually; there's time to do more animations
        # draw over again
        echo -ne "\033[u"  # Restore cursor position
        erase_final=$( _repeat_whitespace_rows "$sprite_height" "$total_run" )  # TODO - replace with the ascii title of tmux window, if provided
        echo -e "$erase_final" | pv -qL 200  # erase line by line
        echo -ne "\033[u"  # Restore cursor position  # TODO - make this conditional; only if used only whitespaces (deleted the banner), go back.
    fi

}



# Finishing touches (parsing this file and announcing that we're done to user)
#################################################################################

if [ "$IS_FIRST_SOURCING" = true ]; then
    CUSTOM_ALIASES="$(_unique_in_first "$( eval "$_alias_names_query")" "$CUSTOM_ALIASES_INITIAL")" # keep list of (only) aliases that were added between now and the start of the file
    eval $(_hashmap_this_var 'CUSTOM_ALIASES')  # create hashmap: CUSTOM_FUNCTIONS_MAP
    CUSTOM_FUNCTIONS="$(_unique_in_first "$( eval "$_function_names_query")" "$CUSTOM_FUNCTIONS_INITIAL")"  # keep list of (only) functions that were added between now and the start of the file
    eval $(_hashmap_this_var 'CUSTOM_FUNCTIONS')  # create hashmap: CUSTOM_FUNCTIONS_MAP

    # source commands that call scripts in other languages
    [ -e "$SCRIPTS_BASHRC_FILE" ] && source "$SCRIPTS_BASHRC_FILE"  # if the file for it exists, source bashrc functions that bring over to the terminal various external scripts
fi

if ! _is_user_root; then   # if user is root (sudo running), be quiet
    echo "$(gecho "Finished loading") \"$THIS_FILE\" for: \"`readlink -f $0`\". To view added commands, run: $(becho remindme)"  # announce done
    [ -e "$TESTS_FILE" ] && source "$TESTS_FILE"  # run the tests file if it exists and we're not in sudo mode
fi

#  TODO - put as a top pane in tmux window. Needs to be in a different pane because I can't find a way to make it play without interrupting key input or disrupting it and keeping the first char in the input.
# if running in a visible terminal, and not as root
# if [ -t 1 ] && [ "$IS_USER_ROOT" = false ]; then  
#    animate_lets_go
# fi


