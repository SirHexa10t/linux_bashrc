#!/bin/bash


# TODO - lookup (grep) within "remindme"
# TODO - "whatnow" - tag commands (things like "network" or "visual" or "filesystem") and list the tags for (optional) interactive picking 
# TODO - find all "] &&" and see that they operate fine

# TODO - find places in code that print line-by-line and speed them up by buffering and printing everything at-once (noticably faster), unless those are in a (potentially) long processes

# TODO - make function variables "local"? (check if it matters)

# TODO - define this file's constants with capital letters?

# TODO - add a function that backs up personal configurations and files from HOME


#---------------------------------------------------------------------------------------------
#----CUSTOM-----------------------------------------------------------------------------------
#---------------------------------------------------------------------------------------------
# You're welcome to paste this file in your bashrc, but I urge you to source it instead.


## please ignore - stuff that's needed early in this file; not meant for the user 
#################################################################################
function _alias_names () { alias | grep -E "^alias" | sed "s/^alias \([^=]*\)=.*/\1/" ; }  # this is needed very early (and very late) for lookup of existing aliases
function _function_names () { declare -F | awk '{print $3}' ; }  # not as complex as aliases, but if aliases are here, so should this be.

# Returns true if pacakge is installed, false + user-message if not.
# arg 1: package name
function _announce_pkg_installed () { [ -n "$(which "$1")" ] && return 0 || { echo "Can't use package '$1', consider installing it." ; return 1 ; }  } 

# if the file (any kind, including dir) exists, print it, otherwise place an empty string
# arg 1: potential filename
function _filename_or_nothing () { [ -e "$1" ] && echo "$1" || echo '' ; }

# if the file exists, print its contents, otherwise place an empty string
# arg 1: potential filename
function _file_content_or_nothing () { [ -f "$1" ] && cat "$1" || echo '' ; }

# If symlink exists and its target is valid, print the target. Otherwise place an empty string.
# arg 1: symlink file
function _is_valid_symlink () { [[ -L "$1" && -e $(readlink -f "$1") ]]; return $?; }

## Session data
#################################################################################
SUDO_FILE="$(which sudo)"
CUSTOM_BASHRC_FILE="$(readlink -f -- "$BASH_SOURCE")"  # this file
CUSTOM_BASHRC_FOLDER="$(dirname "$CUSTOM_BASHRC_FILE")"  # this file's filder
SCRIPTS_BASHRC_FILE="$CUSTOM_BASHRC_FOLDER/script_calls_bashrc"  # optional extention file
IS_FIRST_SOURCING=$([ ! -v CUSTOM_ALIASES_INITIAL ] && echo 'true' || echo 'false')

if [ "$IS_FIRST_SOURCING" = true ]; then  # only do if not defined already (can happen if you source this file again), in which case, previous iteration's values are the right ones
    CUSTOM_ALIASES_INITIAL=$(_alias_names)
    CUSTOM_FUNCTIONS_INITIAL=$(_function_names)
fi

## My settings / constants (customize this to your needs/liking)
#################################################################################

# Files this script could utilize. Definitions self-erase in case they don't exist, to avoid writing them accidentally
UTILITY_FILES_FOLDER="$CUSTOM_BASHRC_FOLDER/utility_files"
TESTS_FILE="$(_filename_or_nothing "$UTILITY_FILES_FOLDER/run_tests.sh")"  # Convenient debugging; if file exists, automatically runs when this bashrc file finishes loading. The contents (and address) are up to you.
GARBAGE_OUTPUTS="$(_filename_or_nothing "$UTILITY_FILES_FOLDER/outputs.txt")"  # default location to dump data into (if exists)

SUBDIR_MOUNTS_FILE="$(_filename_or_nothing "$HOME/symlink_folder_mounts.sh")"  # if you have various media-drives and choose to have this file, insert mounting/symlinking instructions into it. Search the usage of this keyword to see how it's expected to work.
CREDENTIALS_OPENAI=$(_file_content_or_nothing "$UTILITY_FILES_FOLDER/openai_api_key")  # API key for ChatGPT 3.5 (if file exists)


# env variables that you're expected to customize
CUSTOM_TMPDIR="$(_filename_or_nothing "/temp_cache")"
_is_valid_symlink "$CUSTOM_TMPDIR" && export TMPDIR="$CUSTOM_TMPDIR"  # (possibly) redefines your temp-files directory (buffer for unarchiving, copying large files, etc.) instead of "/tmp"

export HISTTIMEFORMAT="%Y-%m-%d_%T  "  # makes "history" command display the time the command ran at


# Constants for VM functions
QEMU_VOLUME_UUID='A80899A4089971D4'  # the drive that contains VMs' disk data; must be mounted when running a VM
LOOKING_GLASS_CLIENT="/usr/local/bin/looking-glass-client"  # run VM in a window



# ---------- BINDS ----------
#################################################################################
# "\C-" is CTRL, "\e" (or "\M-") is alt. Shift might not be supported, but if it is: "\S-" is Shift (and maybe also backslash and capitalize, like this for Shift-X: "\X").
# Flag -x is "execute".
# A personal rule is that things get executed instead of written explicitly only if the user shouldn't care about the command used (i.e. it always makes sense to use just the shortcut)

# before adding a bind, check whether it's already taken, by running "bind -p". You'd generally be overwriting existing binds, but some of them such as CTRL+M cause problems when you overwrite
# To define it only if the shortcut doesn't exist, run a command like this:   if ! bind -q "\C-w"; then bind '"\C-w": "exit\n"'; fi

if [[ "$EUID" -ne 0 ]]; then  # no binding keys when running as root.
    # Bash terminal related 
    # =====================

    # CTRL+H : basically "help"
    bind -x '"\C-h": "remindme"$\r$\n'

    # print this, so the user can rerun this easily for function tests
    # ALT+N : refresh bash terminal
    bind '"\en": "exec bash\n"'

    # CTRL+Z : undo the regular CTRL+Z ; resume background-process UI 
    # bind -x '"\C-z": "fg"$\r$\n'

    # CTRL+W : close terminal. Just like in web-browsers
    # bind '"\C-w": "exit\n"'  # should be defined in the OS for all windows

    # CTRL+SHIFT+I : get system info
    # bind -x '"\C-\I": "echo something"$\r$\n'  # TODO


    # Custom environment 
    # ==================

    # CTRL+X : (let's pretend X is for X-Server...) arrange monitors when the nvidia settings won't keep them arranged
    bind -x '"\C-x": "arrange_monitors"$\r$\n'

fi

# ---------- ALIASES ----------
#################################################################################

# aliases work as "command (re)placements", i.e. they'll replace words that are commands but not args
# Be aware that including several commands in an alias won't allow you to run all of it under "sudo"


## Basic functionalitiy override !
# ===============================

# The space at the end makes bash auto-complete the next word as well. 'sudo ' alone makes aliases work in sudo, but not functions.
alias sudo='sudo '

# same trick as in sudo - allows checking manual for overriden commands (man the override instead)
alias man='man '

# replace apt with nala. Same thing but prettier
# conditional alias - only if package is installed
[ -n "$(which apt)" ] && _announce_pkg_installed 'nala' && alias apt='nala'

# rsync copy instead of cp - recursive by default and shows progress percentage
_announce_pkg_installed 'rsync' && alias cp='rsync -ah --info=progress2'


# Lookup
# ======

# ----- Lookups / Getting-info

# grep, case insensitive (i), and no regex involved (F)
alias g='grep -iF --color=auto'

# grep, catches 3 lines before/after (+6 total) match, case insensitive (i), and no regex involved (F)
alias g3='grep -iF --color=auto -C 3'

# history grep
alias hg='history | grep -iF --color=auto'



# Service/Application handling
# ============================

# run docker desktop
alias run_docker_desktop='systemctl --user start docker-desktop'

# TODO - define "sudocker" - run docker desktop as sudo so that it'll find all containers


# System management
# =================

# reset terminal (includs bashrc reload)
alias anew='exec bash'

# TODO - figure why the official Nix upgrade is aimed at non-latest version: "nix-channel --update; nix-env -iA nixpkgs.nix nixpkgs.cacert"
# TODO - support more systems
# Upgrade your system. Includes autoremove
alias updatengrade='\
[ -n "$(which apt)" ] && sudo apt update && sudo apt-get full-upgrade -y && sudo apt-get autoremove -y
[ -n "$(which dnf)" ] && sudo dnf check-update && sudo dnf distro-sync -y && sudo dnf autoremove -y
[ -n "$(which nix)" ] && nix-channel --update && nix-env --upgrade
'

# rebuild boot parameters using GRUB
alias rebuild_boot='sudo update-grub'

# rebuild RAMFS to apply changes like in modprobe (blacklisting services)
alias rebuild_ramfs='sudo update-initramfs -u'

# Get basic hardware and system list
alias sysinfo_short='echo "For simpler neat hardware specs, run \"neofetch\" or \"screenfetch\""; inxi -bD'

# Get comprehensive system/specs details
alias sysinfo_full='inxi -FxxzJy90'


# File/filesystem management
# ==========================

# Get metadata of a specified audio/video/image file
alias media_metadata='ffprobe -v error -show_entries stream=width,height,r_frame_rate,nb_frames,codec_name,channels,bit_rate,duration -show_entries format=filename,size -hide_banner -pretty -print_format json'

# open window at current terminal directory
alias gui='xdg-open "$(pwd)"'


# Network management
# ==================

# Show current network connections to the server through port 80
alias port80="sudo netstat -tulpn | grep :80"

## if the dig call fails, you can find external IP like so:  wget -qO- https://ipecho.net/plain ; echo
# get own IP (not including "127.0.0.1")
alias whatsmyip='becho "My private IPs:"; hostname -I | sed "s/ /\n/g"; becho "My IPv4:"; dig @resolver4.opendns.com myip.opendns.com +short '

# get addresses on LAN
alias whatsmynetwork="buecho 'LAN devices:' ; arp -a  ;  buecho 'Connections:' ; netstat -atn"

# get own ISP
alias whosmyisp='curl -s ipinfo.io/org'


# function aliases (alternative names)
# ====================================

# Synonymous to "remindme" with extra information (less useful to user).
alias list_cmds='remindme --show_hidden --include_line_num'
# Synonymous to "remindme".
alias what_commands='remindme'
## Mispelled intentionally; don't fix it.
# Synonymous to "remindme".
alias i_forgor='remindme'
# Synonymous to "find_proc". psg is short for "ps grep"
alias psg='find_proc'
# used to allow running this function on aliases
alias _vars_added_by='_vars_added_by '
# alias to a python script (auto-clicker hold-key)
alias autoclick_hold_100cps='py_clicker --cps 100'
# alias to a python script (auto-clicker toggled)
alias autoclick_toggle_100cps='py_clicker --cps 100 --toggle'


# Cheatsheets
# =================

# TODO - write down flatpak/appimage/snap/(other?) differences
# Reminders for linux system tools and command options
alias howdoi_linux='commecho -l '\''
>> Packages
* dpkg -l  # show all installed packages in table format
>> Messing around with the system itself
* reboot  # reboots the system (gracefully)
* sudo systemctl start sshd  # start ssh service for external access
* udisksctl mount --block-device=/dev/<device-name>  # Mount a device the way nemo would. No need for mkdir (and nemo can dismount it right), no harm in calling while unnecessary, automatically uses LABEL to mount at /media/<username>/
*   udisksctl mount --block-device=/dev/<device-name> 2> /dev/null
>> configurations
* /etc/default/grub  :  boot configurations
* /etc/modprobe.d/blacklist.conf  :  blacklist modules, such as firmware
* /etc/fstab  :  mounting configurations, including for dir /
* /etc/environment  :  OS environment variables
*   printenv  # print (all) current environment variables 
* sudo nvidia-xconfig  # create new xorg config, used by nvidia driver
>> logs (to tail a logfile in real-time run: "tail -f <logfile>", or to get last 100 lines: "tail -100 <logfile>" )
* log-file: /var/log/boot.log  :  System boot log
* log-file: /var/log/dmesg  :  log for kernel ring buffer
*   dmesg -k | grep -E "warn|error"  # the command dmesg displays kernel logs buffer
* log-file: /var/log/kern.log  :  log for kernel ring buffer
'\'

alias howdoi_debian_cinnamon='commecho -l '\''
>> Packages (Debian)
* sudo apt install/remove/purge <package>  # package install/remove/remove-including-configs
* sudo gdebi -n <package.deb>  # probably the best way there is to install a .deb file (the -n is for "no prompt")
* sudo dpkg -r <package>  # remove a package installed from a .deb file
* sudo dpkg --purge <package>  # purge a package installed from a .deb file
* dpkg-query --list <package>  # print info related to installed package (autocompletes the name), works for all installations including from .deb
* apt list  # list all packages in followed repositories
*   apt list --installed  # list installed packages
*   dpkg -l  # show all installed packages in table format
>> configurations (Cinnamon?)
* ~/.config/autostart/  :  location of startup scripts that run for your own user after startup 
>> configurations (nemo)
* ~/Templates/  :  anything you put in this folder will be a new-file template when you right-click in nemo
* ~/.local/share/nemo/scripts/  :  anything you put in this folder will be an executable-script available when you right-click in nemo
'\'

# Reminders for user/groups management
alias howdoi_users='commecho -l '\''
* groups <username>  # display the groups of a user
* usermod -aG <groupA,groupB,groupC> <username>  # add user to group(s). You can even add to group sudo (makes into superuser in Ubuntu).
* getent group  # list all groups and their user-members
* sudo adduser --disabled-password --gecos "" <username>  # adduser is a useradd wrapper (addused is generally better). The --disabled-password and --gecos options are required for no-prompt; gecos fills thumbnail info (cancels interactive). --no-create-home skips homedir creation. --disabled-password skips password creation and disables password login.
*   sudo adduser <username> --gecos "" --disabled-password && echo "<username>:<password>" | sudo chpasswd  # Add user with password in one line. take care to specify the username twice, as needed here
* sudo deluser --remove-home <username>  # delete user and associate homedir
* su - <username>  # Switch to user. Might require sudo.
'\'

# Reminders for the basic gimmicks of bash scripting and terminal usage
alias howdoi_bash_terminal='commecho -l '\''
>> packages and built-in commands
* apt search <term>  # look for substring in known packages. As usual, nala can also be used
* man <command>  # read the manual of the command
*   help  # list built-in Bash commands
* sudo !!  # rerun last command with sudo permissions
>> filesystem
* ln -s <link_name> <target>  # define soft-link. There are 2 symlink types; soft (denoted with -s, which points to a file`s address) and hard (points directly to the data of a file. Editing the data in either "original" or hard-link is the same, and deleting either file alone wouldn`t delete the data since it`s still pointed to)
+   soft links don`t really utilize permissions - they allow everything and rely on the target to determine access. chmodding a symlink would forward the modification to the target. 
*   ln -sr scripts/*.js target/  # create soft-links for all .js files in "scripts/", in "target/" (target/[filename.js] -> scripts/[filename.js]) 
* cd  # write no directory to return to home-dir. Equivalent to cd ~
*   cd -  # go back to previous directory
* less <file>  # Read file with up/down controls. Newer and more convenient than "more".
>> processes
* htop  # show real-time processes/resource-usage
* xkill  # after you run this, your mouse cursor would turn into an "x" sign, and the next window youll click would be killed. A bit lazy and silly.
* visudo  # edit the /etc/sudoers file (only if you know what you are doing)
>> bash basic utility commands (can be used in terminal of-course)
* Use $ to reference variables
*   "$my_var": value of variable my_var
*   "$1": first arg in current scope (and so on for each num accordingly)
*   "$@": all args in current scope as separate items ; "$*": all args in current scope concatenated into a unified string ; "$#": args count
*   "$$": current PID
*   "$?": the return code of last operation (can be used to check if it ran successfully)
    "$(<cmd here>)": run commands within commands (can also be done like so: `<cmd here>`)
* add "& disown" after a command to have it run in its own thread (thats the "&"), and "disown" it so that it wont be tied to current terminal-run process and thus stop when the terminal closes
* Use "<" to redirect a file. Example; to use file-contents as input: "./my_script.sh < input.txt"
* Use "<<" ("here-document") to specify on what word (alone, not as an internal part of line) to stop reading text.
* Use "<<<" ("here-string") to input a string as if it came from a file. For example, when running via while-loop on lines stored in a variable
* add "<0/1/2> > <filename>" after a command to write input(0)/output(1)/error(2) streams to a file. Specify "&" to write both 1 and 2. You can also use numbers 3 to 9, those are free descriptors for you to use as you like.
*   add "2> /dev/null" after a command to throw away warning/error messages it might bring up
* declare -p <variable>  # Note: no use of $. Print the variable to check data / data-type
* time <command>  # get time measurement for command runtime. No need for quotes or any encapsulation, just prepend "time". Example: time ls -l
>> conditions
* The return value of a function (0 is successful, anything else is failure) can be used as a condition
* You can use brackets (spaced) for simple file/string checks, like so: [ -n "$1" ]
*   filesystem:
*       "-d": does directory exist ; "-f": does file exist ; "-L": does symlink exist ; "-e": does exist in filesystem ; "-s": does exist in filesystem and with non-zero size
*       "-r": is file readable by current user ; "-w": is file writable by current user ; "-x": is file executable by current user
*   emptiness/presence check:
*       "-n": is string non-empty (specifying a variable that doesnt exist returns empty string) 
*       "-z": is string empty (opposite of -n)
*       "-v": is var name set and isnt empty. Similar to -n but without the need to add $ to the var-name 
*   comparison:
*       "=": check if equal ; "==": check if equal (bash-specific). Example; is num of args 0: [ $# == 0 ]
*       "-eq": check if equal ; "-ne": check if not equal
*       "-gt": check if greater than ; "-lt": check if less than ; "-ge": greater or equal ; "-le": lesser or equal
* You can use double-brackets (spaced) for complex checks
*       "=~": pattern matching. Example: check if string starts with h: [[ "hello" =~ ^h.*$ ]]
*       operators "&&" and "||": AND and OR within the brackets, no parentheses needed for the conditions
* extra_dist=$(( (a > b) ? (a - b) : 0 ))  # example for ternary in bash (use the "&&", "||" ternary instead when you have a condition in "[]"). The double-parentheses mean you dont need "$" to reference variables and that the math operations get evaluated
>> tools (utilities for usage that isnt about managing the OS)
* wget <url>  # download files
* curl <url>  # communicate through HTTP(S)/(S)FTP/SCP - make any request (but if you just want to download something, you should probably use wget)
* diff <file1> <file2>  # get the text difference between 2 files
* espeak <text>  # read-out (audio) the given text. A bit of a gimmick, sounds very robotic
>> shortcuts
* Terminal CTRL+L : clear screen
* Terminal CTRL+Z : send to background (leave any interactive UI for a while).
*   fg  # return process to foreground (resume the UI of the process). If you have several stuff in the background stack, this pops the last one
'\'

# Reminders for some neat time-saving GUI keybind tricks
alias howdoi_gui_shortcut='commecho -l '\''
* Built-in Nemo [space] :  select (click) a file/folder, and press [space] to get a summary/preview; press again to close
* Custom Gnome-Nemo CTRL+SHIT+T :  open Terminal at current Nemo location
* Built-in Gnome CTRL+ALT+T :  open Terminal
* Built-in Gnome(?) CTRL+ALT+[backspace] :  log out of current session (resets your GUI)
* Built-in Debian(?) CTRL+ALT+F1 :  enter TTY mode (terminal without anything graphic to lock/interrupt you)
* Built-in Debian(?) CTRL+ALT+F7 :  exit TTY mode
* Evdev installation LCTRL+RCTRL  :  switch mouse and keyboard (and maybe other things) between guest/host. Wont work if you gave the VM your USB device directly.
'\'

# common media file operations
alias howdoi_media_and_docs='commecho -l '\''
* pdftk <file1> <file2> <file3> cat output <merged_name.pdf>  # create a unified pdf file 
* xournal <pdf_filepath>  # edit a pdf file with option to add signatures
* ffmpeg  # general media (audio / video) handling package, you can find some usages in this bashrc file
'\'

# Reminders for microsoft-format handling tools
alias howdoi_microsoft='commecho -l '\''
* lnkinfo <lnk-file>  # display link info
* dos2unix <file>  # convert files from windows to unix encoding
* sudo ntfsfix <device> -v  # run check-disk on NTFS device
* ldmtool  #  Read dynamic disks by running "sudo ldmtool create all", and then mounting with "mount -t ntfs /dev/mapper/<volume_name>"
'\'

# Snippets and tricks for Chromium-based browsers
alias howdoi_chromium='commecho -l '\''
* chrome://flags/#hardware-media-key-handling  # Advanced operation flags. Specifically media-key-handline - disable this to get rid of the banner that appears when you change volume
* document.getElementsByTagName("video")[0].playbackRate = 4  # change youtube playback speed (example here: x4)
'\'


# Reminders for android-related tools
alias howdoi_android='commecho -l '\''
* scrcpy  # run daemon that casts the connected Android device screen onto a window, and shares the clicks within it back to the Android device
* scrcpy -r <filename.mp4>  # save a video recording of your connected android device activity (needs USB-Debug and File-Transfer mode)
'\'

# Reminders for network management
alias howdoi_network='commecho -l '\''
>> Own network info
* ip addr  # display own networking interfaces. A modern safer alternative to: ifconfig
* sudo netstat -tulpn  # display active network connections and filter by port number
>> Seeking addresses
* dig "amazon.com" +short  # resolve dns address (or addresses, in case content-distribution-networks are involved)
* ping google.com  # ping address
>> Firewall and incoming requests
* UFW config-file: /etc/ufw/ufw.conf  :  to monitor incoming requests, set in it: LOGLEVEL=debug , then run "sudo ufw reload" (no-interruption reset; if it wont work run: "sudo service ufw restart"), and then "sudo tail -f /var/log/ufw.log" to monitor
* ufw allow 21115:21119/tcp  # change firewall rules (by ports or src address) - in this case, allow ports 21115 to 21119 (including) on tcp
* sudo tcpdump -i any -n  # capture traffic on all networks for all ports
* sudo tcpdump -i [interface] -n "src host [external_IP] and dst port [dst_port]"  # detailed monitoring
*   detailed monitoring example 1:  sudo tcpdump -i enp5s0 -n "dst port 21118"
*   detailed monitoring example 2:  sudo tcpdump -i any -n "tcp and (dst port 21115 or dst port 21116 or dst port 21117 or dst port 21118 or dst port 21119)"
*   detailed monitoring example 3:  sudo tcpdump -i any src 46.120.97.16 -nn -c 20  # -nn shows ip addresses and port-num without resolving hostname, -c stops capturing after 20 packets
'\'

# Reminders for the basics of systemd
alias howdoi_manage_services='commecho -l '\''
>> Crontab
* crontab -e  # edit routine-scheduled tasks
>> systemd
* /etc/systemd/system/  :   add/remove .service files here
* sudo systemctl daemon-reload  # rescan and reload service files
* sudo systemctl <start/stop/restart/status> <myservice>.service  # manage the state of the service or check its running-status
* sudo systemctl <enable/disable> example.service  # allow/disallow service to run after boot
* journalctl -u <service_name.service>  # check the logs of a systemd service. Can also specify how to view them; example:   journalctl -u ssh --since "1 hour ago" --until now -f
'\'

# Reminders for docker
alias howdoi_manage_docker='commecho -l '\''
>> view (might need to run sudo to find all)
* docker ps -a  # list ALL containers
* docker images -a  # list all images
* docker volume ls  # list all volumes
* sudo docker inspect <container_name_or_id>  # view container details 
>> managing container states
* docker-compose -f <yml_file> up  # Start a conteiner using a yaml/yml file. Use -d to make it run in the background
>> removal
* docker system prune -a  # remove all images/containers/volumes/networks. The flag -a also remove unused images
* docker rmi <image(s)>  # remove images ; to remove all images:   docker rmi $(docker images -a -q)
* docker rm <container_id(s)_or_name(s)>  # remove container(s) ; to force-remofe, add -f ; to remove all stopped containers:   docker rm $(docker ps -a -f status=exited -f status=created -q)
* docker volume rm <volume_name(s)>  # remove volume(s)
* docker run --rm <image_name>  # run an image and remove its container when it exits
'\'

# Reminders for vm tools and command options (mostly stuff you can't do through Virtual Machine Manager)
alias howdoi_manage_vm='commecho -l '\''
* systemctl restart libvirtd  # restart the libvirt daemon vm-manager
* virsh start <name>  # start VM
* virsh domrename <old_name> <new_name>  # rename vm
* virsh edit <name>  # modify the xml of a VM (you can do that in Virtual Machine Manager instead)
* sudo virt-sparsify --in-place -v <diskimg.qcow2>  # compress vm disk file
* virsh list --all  # show VM list
* virsh snapshot-create-as --domain <VM-NAME> --name <SNAPSHOT-NAME>  # create snapshot for a vm (has to be turned off)
* virsh snapshot-list --domain <VM-NAME>  # list snapshots of vm
* virsh snapshot-info/snapshot-revert/snapshot-delete --domain <VM-NAME> --snapshotname <SNAPSHOT-NAME>  # detail/go_back_to/delete snapshot
* qemu-img create -f qcow2 -F qcow2 -b <path_to_src_disk.qcow2> <path_to_output_disk.qcow2>  # snapshot a single disk
'\'

# Reminders how to approach sketchy executables
alias howdoi_reverse_engineer='commecho -l '\''
+ disassembly can be done through "IDA" (Interactive DisAssembler), or "Ghidra"
+ you can test-run an executable on: "https://any.run"
* strings <my_executable.exe> | less  # list used strings. See if any URLs are being used.
* objdump -d -Minterl <program_file>  # using Intel syntax, describe the program as a list of assembly instructions
* checksec --file=<file_to_check> --output=json | jq  # check which security features (if any) are active for the specified file, for things like buffer overflow
'\'

# Reminders for the basic gimmicks of tmux terminal
alias howdoi_use_tmux='commecho -l '\''
tmux offers split-panes and sessions for terminals.
>> Good for managing a server:
+ tmux terminals persist even after disconnection. They keep running until restart the server or send a closure command.
+ tmux windows can be named, listed and looked up.
+ tmux can accomodate multiple users on the same terminal simultanously; good for assistance/collaboration and for doing jobs that need a "lock" (having a channel where certain jobs run, so people would know if someone elses job is underway and should be allowed to finish first)
>> Quick explanation: tmux has sessions. Each session can have various windows, each window (has a number and name) is a "screen" thats visible at the moment and has vertically/horizontally added panes 
+ For simplicity you can just have a SINGLE SESSION and manage all your windows there. Its easier to navigate windows, thanks to the green bar listing them at the bottom.
+ If a window has only need for a SINGLE TERMINAL (lets say the window is called "grub_config"), you can keep it simple and avoid adding extra panes. Add panes to multi-faceted things, like a project which has code, git-management, assets, runtime area etc.
> Sessions:
* tmux  # create a new tmux session
* CTRL+B, D  : leave (detach) current session
* tmux ls  # view all existing tmux sessions (+ info about creation date and number of windows)
* tmux rename-session -t <0/1/2/3/.../past_name> <name>  # rename session (using number/name from "tmux ls")
* tmux attach -t <0/1/2/3/.../name>  # connect (attach) to an existing tmux session (using number/name from "tmux ls")
* tmux kill-session -t <0/1/2/3/.../name>  # kill specified session
> Windows:
* CTRL+B, <0/1/2/3/...>  : go to window number
* CTRL+B, C  :  create a new window
* CTRL+B, ,  :  rename current window
> Panes:
* CTRL+B, %  :  create a new pane to the right
* CTRL+B, "  :  create a new pane to the bottom
* CTRL+B, <left/right/up/down>  :  move focus to other pane
* exit  # close pane. If last pane, close window.
'\'
# TODO - create a script thatll establish tmux workspaces when logging into your user (so youd have things ready for debugging or coding and such)
# TODO - create functions that run these commands interactively (like listing, then letting the user pick a number, then go there...)

# TODO - cargo (maven-like manager) cheatsheet. Reference: https://www.youtube.com/watch?v=zF34dRivLOw

# Reminders for ascii-related commands and handling
alias howdoi_ascii='commecho -l '\''
+ Create ASCII writings in this site: http://patorjk.com/software/taag/
* figlet <text>  # write ASCII styled text, different fonts are also supported
* banner <text>  # write ASCII styled text
* toilet <text>  # write ASCII styled text, different fonts and styles are also supported
* jp2a --output=<output.txt> --colors <input.png>  # convert image to ASCII
* ascii-image-converter <input.png>  # convert image to ASCII
* <text_output_command> | lolcat  # rainbow-color text
* <text_output_command> | pv -qL 200  # write text progressively (like being typed, or (if fast) etched by a laser engraver). Try testing with neofetch. Try adding pipe to lolcat.
'\'



# Custom
# ======

# Ad-Hoc screen layout rearrangement (sometimes they get messed up; maybe it's an Nvidia-Linux problem)
alias arrange_monitors='nvidia-settings --load-config-only && nvidia-settings --assign CurrentMetaMode="HDMI-0: nvidia-auto-select +1920+1080, DP-0: nvidia-auto-select +1920+0, DP-2: nvidia-auto-select +3840+1080, DP-4: 1920x1080_240 +0+1080"'





# ---------- FUNCTIONS ----------
#################################################################################

# TODO - a "checksum" function that gets both file to checksum and the checksum-result file, determines which is which, runs the appropriate checksum on the file and compares with the result file; prints the match result 


# Command and mechanics override
# ==============================

# attempt to run command given command (args) - if it fails, run with sudo
function _sudo_if_necessary () {
    [ $# -ge 1 ] || { errcho "WTF are you expecting me to sudo? Give me a command-string as argument" ; return ; }
    (  # can't make the output-catch var local - you'd get no root password prompt. So we put it in its own enclosed env.
        command_output=$(eval "$@" 2>/dev/null)
        [ $? -ne 0 ] && sudo "$@" || echo "$command_output"
    )
}

## I don't know what black magic is involved, but you need both the above sudo alias and this function to support alias interpretation.
# Sources this file if the command is a function from this page.
# Remember: sudo has its own environment. You can perform actions such as file modification, but you can't apply session-env altering commands such as "cd"
function sudo () {
    # if you call directly something like "sudo lll /root", the alias "lll" would translate into several commands (functions) and it'll break because the passed args would only cover first command
    # so call it like this to let the alias translate later: sudo "lll" /root

    # We basically source this file when calling sudo, which is convenient to the user. The "right" way to do so is to put something in the style of the following line (without the comment) in /etc/sudoers :
    # Defaults        env_keep += "BASH_FUNC_*"

    # needs to be "silent" to avoid screwing up scripts that rely on the output of the sudo'd commands
    # if arg 1 (only arg 1 supported, deal with it) is in the list of this file's functions, source this file. Otherwise, run sudo regularly.
    if [ -n "${CUSTOM_FUNCTIONS_MAP[$1]}" ]; then
        local custom_function_cmd="source $CUSTOM_BASHRC_FILE && $@"
        "$SUDO_FILE" $SHELL -c "$custom_function_cmd"
    elif [ -n "${CUSTOM_ALIASES_MAP[$1]}" ]; then
        local custom_function_cmd="source $CUSTOM_BASHRC_FILE && $@"
        "$SUDO_FILE" $SHELL -i -c "$custom_function_cmd"
    else
        "$SUDO_FILE" "$@"
    fi
}

# TODO - do about the same for chmod and chown - print the directory/files with the changed data (maybe cancel that, getting the filenames in every case isn't simple)
# add a print of local files after changing directory
function cd () {
    builtin cd "$@" && \
        ls -AF --color=always --group-directories-first 
}

# make mkdir more "reasonable" with a flag that is always nice to have ; -p doesn't print error if dir exists
function mkdir () {
    local extra_flag="$( [[ "$@" =~ ^"-p"$ ]] && echo '' || echo '-p')"  # if flag not present, store it in var 
    /usr/bin/mkdir "$extra_flag" "$@"
}

# make date output in a specific format by default
function date () {
    local args=$([ $# == 0 ] && echo "+%Y-%m-%d_%T" || echo "$@")  # if provided 0 args, set the time-format to own preference
    /usr/bin/date "$args"
}



# Common basic functionalities
# ============================

# print maximum number among given args
function max () {
    local max=$1 n
    for n in "$@"; do (( $(echo "$n > $max" | bc -l) )) && max=$n ; done
    echo $max
}

# debugger: prints vars that were added by following function call
# arg 1: -s (optional: run the command silently)
function _vars_added_by () {
    local silent
    [ "$1" == '-s' ] && { silent='true' ; shift ; }
    # record vars before and after (but not in local variables, that'd complicate matters)
    local before_file="/tmp/vars_before_running_$1" after_file="/tmp/vars_after_running_$1"  # defined as a constant prior to the "before" measurement, so it's fine
    set -o posix ; set | sort | uniq > "$before_file"
    if [ -n "$silent" ]; then "$@" &> /dev/null ;  # silent running
    else "$@" ;  # regular running
    fi
    set -o posix ; set | sort | uniq > "$after_file"
    
    local found="$(diff "$before_file" "$after_file" | grep "^>")"
    if [ -n "$found" ]; then becho "vars found after running \"$@\":" ; echo "$found" ;
    else dagecho "No new vars found!" ; fi

    rm "$before_file" "$after_file"
}


# Data structure handling
# =======================

# turn a list into a hashmap; you need to evaluate the output (can't return a hashmap directly)
# call like this: eval $(_hashmap_instructions --hm_name 'my_hashmap' --list "${my_list_var[@]}")
function _hashmap_instructions () {
    local hashmap_name='' the_list=''
    while [[ $# -gt 0 ]]; do
    	case "$1" in
            '--hm_name')
    			hashmap_name="$2"
    			shift 2
    			continue
    		;;
            '--list')  # MUST come last!
                shift
    			the_list="$@"
                while [ "$#" -gt 0 ]; do shift; done  # no more args, shift them all.
    			continue
    		;;
            *)
                errcho "${FUNCNAME[0]} doesn't know how to handle arg: '$1'"
    			shift
    		;;
        esac
    done

    [ -z "$hashmap_name" ] && errcho "no name provided for your hashmap" && return 1
    [ -z "$the_list" ] && errcho "no list provided" && return 1

    # TODO - see if you can declare with -g -A (global declaration, no need to evaluate printed reply). The difficulty I had was assigning values to the hashmap (since its name was saved in a var)
    local hasmap_builder="declare -A $hashmap_name=("
    local item
    for item in $the_list; do hasmap_builder+=" [$item]='1'"; done 
    hasmap_builder+=")"
    
    # "return" the hashmap-creation string that needs to be evaluated
    echo "$hasmap_builder"
}

# gets variable name, evaluates it and returns hashmap-creation-string for same varname with suffix _map or _MAP
# call like this: eval $(_hashmap_this_var 'list_name')
function _hashmap_this_var () {
    [ "$#" -eq 1 ] || { errcho "You need to provide variable-name as an argument" ; return ; }  # TODO - check this file for all places where "ge 1" was used, maybe mistakenly instead of "eq 1"
    
    # TODO - it's possible to access the data with "${!1@A}" but only if it's lines of text, rather than list. Find a way to get the data in both cases (current solution does that by using eval and a hacky trick, which isn't optimal)
    local pointed_data="$(eval "echo \${${1}[@]}")"  # madness: pointers (indirect access) in Bash. Echo is there to make sure you don't actually execute the found data
    local hm_suffix=$([[ "${1}" == "${1^^}" ]] && echo "MAP" || echo "map")  # if completely capitalized, suffix is _MAP, otherwise it's _map
    _hashmap_instructions --hm_name "${1}_${hm_suffix}" --list "$pointed_data"
}

# List the items unique to the first list (string variables, not arrays). Better in runtime than comm -23, thanks to hashmap usage
function _unique_in_first () {
    # TODO - make this work on array types?
    local filter_me="$1"
    local blacklist="${@:2}"

    # if there's nothing to filter out, just return the first arg
    [ -z "$blacklist" ] && { echo "${filter_me[@]}" ; return ; }
    
    eval $(_hashmap_this_var 'blacklist')  # create hashmap: blacklist_map
    local item
    for item in $filter_me; do [ -n "${blacklist_map[$item]}" ] || echo "$item"; done  # print if unique to first
}


# Basic user interactivity
# ========================

# adds y/n prompt. Call like this:  if prompt_yn "<prompt q>?"; then echo "<starting-process msg>"; else echo "<cancellation msg>" && return ; fi
function _prompt_yn () {   
    local response=""
    # keep prompting the user until they provide a valid response
    while [ "$response" != "y" ] && [ "$response" != "n" ]; do
        # prompt the user for a yes/no response
        read -p "$1 [Y/n] " response
        case "$response" in
            y|Y ) return 0 ;;  # if the response is "y", return a boolean value indicating success
            n|N ) return 1 ;;  # if the response is "n", return a boolean value indicating failure
            *) echo "just type y or n" ;;  # if the response is anything else, print an error message and continue prompting
        esac
    done
}


# Info display and lookups
# ========================

# TODO - command grep. "command_like <expression>"
# list custom commands.
# --show_hidden (list inner-workings commands) ; --sort (sort alphabetically) ; --include_line_num (print definition line-num)
function remindme () {
    local show_hidden include_line_num sort
    while [[ $# -gt 0 ]]; do
    	case "$1" in
            '--show_hidden')
    			show_hidden='true'
    			shift
    			continue
    		;;
            '--include_line_num')
    			include_line_num='true'
    			shift
    			continue
    		;;
            '--sort')
    			sort='true'
    			shift
    			continue
    		;;
            *)
                errcho "${FUNCNAME[0]} doesn't know how to handle arg: '$1'"
    			shift
    		;;
        esac
    done

    local unoriginal=('sudo' 'man' 'cd' 'mkdir' 'cp' 'date' 'apt')  # list of overwritten shell commands 
    eval $(_hashmap_this_var "unoriginal")  # create hashmap: unoriginal_map

    declare -A line_to_cmd  # map of line number to respective command definition (name and comment)

    # TODO - list key binds too
    # TODO - once tags are added, (color-)mark some commands as "useful"; specifically those you can use often
    # TODO - try running in parallel (async)

    local this_file_text="$(cat "$CUSTOM_BASHRC_FILE")"  # faster than reading the file from disk several times

    function get_commands_by_expression {
        local expression_template="$1"
        local num_of_rows_above="$2"
        local cmd_names="${@:3}"  # args 3 and onwards

        [ -z "$cmd_names" ] && errcho 'No commands given to search!' && return

        local name  # iteration variables
        while read -r name; do
            if [ -z "$show_hidden" ] && [[ "${name:0:1}" == '_' ]]; then continue; fi  # if not showing hidden functions and current function starts with '_', skip it
            if [ -n "${unoriginal_map[$name]}" ]; then continue; fi  # if it's an override of a known command (user already knows what it does), don't mention it - skip

            # we already have the names, we need the documentation. And maybe also line number.
            local expression=$(echo "$expression_template" | sed "s/<name>/$name/")
            local line_num=$( echo "$this_file_text" | grep -nE "$expression" | cut -d: -f1 )  # get line number
            local matched=$( echo "$this_file_text" | grep -B "$num_of_rows_above" -E "$expression" )  # match declaration and some rows above for documentation
            # keep only comments, but not if they start with "##" (those are for the maintaining of the function rather than understanding how it works) and not if # is followed up by TODO or =====
            matched=$(echo "$matched" | grep -E '^#[^#]' |  grep -vE '^#[[:space:]]*TODO' |  grep -vE '^#[[:space:]]*===' )  
            matched=$(echo "${matched}"| paste -s -d ' ')  # unify all results into one row (if any). Separate with space
            line_to_cmd["$line_num"]="$name  $matched"
        done <<< "$cmd_names"
    }

    # aliases
    get_commands_by_expression "^\s*alias\s+<name>=" 1 "$CUSTOM_ALIASES"

    # functions
    get_commands_by_expression "^\s*function\s+<name>\s*\(\)\s*{" 2 "$CUSTOM_FUNCTIONS"

    # categories (comments, not callable)
    if [ -z "$sort" ]; then  # if not sorting by name (so, sorting by line number - categories are relevant)
        local topic_comments="$(echo "$this_file_text" | grep -n -B 1 "^# ===" | sed -E '/^[0-9]+\-# .*/!d')"  # get also one line above the underline matches, and throw away the actual matched (underline) lines
        topic_comments+="$(echo ; echo "$this_file_text" | grep -n -B 1 "^#####" | sed -E '/^[0-9]+\-# .*/!d')"  # add titles (binds/aliases/functions), after a newline
        local number comment  # iteration variables
        while IFS=- read -r number comment; do line_to_cmd["$number"]="$comment" ; done <<< "$topic_comments"
    fi

    local cmd_list=$(for key in "${!line_to_cmd[@]}"; do echo "$key $(commecho "${line_to_cmd[$key]}")"; done )  # include line-number for possible line-num sorting
    [ -n "$sort" ] && cmd_list=$(echo "$cmd_list" | sort -k2) || cmd_list=$(echo "$cmd_list" | sort -n -k1) # If user specified alphabetical sorting, sort by command name. Otherwise sort by line num
    [ -z "$include_line_num" ] && cmd_list=$(echo "$cmd_list" | cut -d" " -f2-)  # if flag not specified, remove line numbers


    echo "$(becho The following commands were overridden, but retain their original functionality:)  $(printf "%s, " "${unoriginal[@]}" | sed 's/, $//')"
    echo "$cmd_list"
}

# Check if you spelled given word correctly. Get definition to make sure, or suggestions if it's misspelled 
function spellcheck () {
    local word="$1"
    [ -z "$word" ] && { errcho "Provide an argument (English word) to spell-check" ; return 1; }

    local corrections="$(aspell -a <<< "$word" | grep '^& ' | sed 's|.*: ||' | sed 's|,||g')"  # corrections are listed after "& ", or just as "*" if there are none (word is correct). Then
    if [ -z "$corrections" ] ; then
        gecho "✔ $(guecho $word)"  # can alternatively use checkmark: ✓
        # list definitions
        local source="https://www.wordnik.com/words/$word"
        echo "Fetching word definition from $source :"
        local definition_page="$(curl -s "$source")"
        # print main definition
        becho "$(echo "$definition_page" | sed -n "s|<meta content='$word: \(.*\)' name='description'>|\1|p")"
        # print other definitions
        local other_defs="$(echo "$definition_page" | grep '<abbr title="partOfSpeech">' | sed -n 's|.*<abbr title="partOfSpeech">\(.*\)</li>|\1|p' | sed 's/<[^>]*>//g')"
        local marked_word
        for marked_word in adverb verb adjective pronoun noun preposition conjunction interjection; do other_defs="$(color_word -t "$other_defs" -w "$marked_word" -c '<=italic=><=yellow=>')" ; done
        echo "$other_defs"
    else
        recho -p "✖ $(ruecho $word)\tDid you mean:"  # can alternatively use fail: ✕
        local marked_corrections=() correction  # also defines iteration var
        for correction in $corrections; do marked_corrections+=("$(py_word2_diff "$word" "$correction")") ; done
        printf '%s , ' "${marked_corrections[@]}" | sed 's/,\s*$/\n/'  # list to string separated by spaced commas
    fi
    
}

# man grep - find word in manual, with a bit of context (lines above/below).
# arg 1: man's target, arg 2: word to find
function mang () {
    man "$1" | grep -iF --color=auto -C 3 -- "$2"  # the "--" allows you to lookup dashes in your expression
}


# Administration - network
# ========================

#  TODO - function/alias that follows used files (and network) through: lsof -p <PID>

# search current device's network activity by port (specify number) or substring
function network_search () {
    # TODO - compare with results from "lsof -i -P" and maybe use that instead
    if [ -z "$1" ]; then echo "You didn't provide anything to filter by. Aborting." && return 1 ; fi
    
    if [[ $1 =~ ^[0-9]+$ ]]; then  # numerical - filter as a port number
        sudo netstat -tulpn | grep ":$1"
    else  # non-numerical, look-up as a substring
        sudo netstat | grep -iF --color=auto "$1"
    fi
}


# Ping various sources, see how fast you reach them.
# Add your own addresses as args if you want them checked too. Note: you might be interested in checking through this site: https://www.cloudping.info/
function multiping () {
    local num_of_pings=3
    # random_lan_device=$(ip neigh | cut -f 1 -d ' ' | grep -v '127.0.0.1' | shuf -n 1)
    local user_choice="$@"
    local big_domains="wikipedia.org youtube.com discord.com google.com cloudflare.com"
    local dns_addresses="8.8.8.8 1.1.1.1"  # google and cloudflare
    local aws_endpoints="$(curl -s "https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/Concepts.RegionsAndAvailabilityZones.html" | sed -n 's|\(rds.[[:alpha:]]\+-[[:alpha:]]\+-[[:digit:]]\+.amazonaws.com\)|\1|p')"

    # color-print number by its "grade" (quality determined by how big it is)
    # arg 1: number to print
    function grade_ping () {
        local num="$1"
        if (( $(echo "$num < 20" | bc -l))); then cecho "$num";
        elif (( $(echo "$num < 100" | bc -l))); then gecho "$num";
        elif (( $(echo "$num < 200" | bc -l))); then yecho "$num";
        elif (( $(echo "$num < 300" | bc -l))); then recho "$num";
        else darecho "$num";
        fi
    }

    (  # The parentheses provide a subshell, so that shell job-control wouldn't bother us
    for address in localhost $user_choice $big_domains $dns_addresses $aws_endpoints; do
        for protocol in 4 6; do
            # ping (async), and average the response time, then print result.
            {
                protocol_name="IPv$protocol"
                failure=''
                ping_results="$(ping "-$protocol" -c "$num_of_pings" "$address" 2> /dev/null)"
                if ! [ $? -eq 0 ]; then
                    [[ "$protocol" == "4" ]] && recho "Failed pinging $address on $protocol_name"  # only print if failed at IPv4
                    failure='true'
                fi 

                # if didn't fail, print the resutls
                [ -z "$failure" ] && echo "$ping_results" \
                 | awk -F 'time=' '{if (NF > 1) {print $2}}' \
                 | awk '{ total += $1 } END { print total/NR }' | echo "$(becho "$address") on $protocol_name, avg ping time: $(grade_ping $(cat)) ms"                
            } &

        done
    done

    wait  # wait for threads to finish (otherwise the prompt won't show back automatically)
    )
}

# find where a shortened link leads to
function link_investigate_shortened () {
    # buffer the replies (for some reason piping doesn't cover all of them)
    local replies="$(curl --head --location "$1")"
    echo "$replies" | grep -iF location
}


# Administration - users
# ======================

# list password-owning users with uid >= 1000.
# --max_uid <number> (listed users' uid limit)  ; --require_home (only list users with home-dir) 
function list_human_users() {
    # defaults
    local require_home max_uid_filter  # no extra filtering
    while [[ $# -gt 0 ]]; do
    	case "$1" in
            '--max_uid')
    			max_uid_filter="&& \$3 <= $2"
    			shift 2
    			continue
    		;;
            '--require_home')
    			require_home='true'
    			shift
    			continue
    		;;
            *)
                errcho "${FUNCNAME[0]} doesn't know how to handle arg: '$1'"
    			shift
    		;;
        esac
    done

    local users=$(getent passwd | awk -F: '$3 >= 1000 '"$max_uid_filter"' {print $1}')  # get all users with uid >= 1000, maybe with a limit (because uid increments by 1)
    local user
    for user in $users; do      
      if [ -z "$require_home" ] || [ -d "/home/$user" ]; then  # if homedir isn't required, or if it is and it does exist
          echo $user
      fi
    done
    echo "root"  # always assume root might be humanly-used somewhere
}

# list users and their various resources usage.
# --gpu (also display gpu data) ; --not_sudo (don't try to get restricted data as root)
function resources_used () {
    local show_gpu not_sudo  # no extra filtering
    while [[ $# -gt 0 ]]; do
    	case "$1" in
            '--gpu')
    			show_gpu="true"
    			shift
    			continue
    		;;
            '--not_sudo')
    			not_sudo='true'
    			shift
    			continue
    		;;
            *)
                errcho "${FUNCNAME[0]} doesn't know how to handle arg: '$1'"
    			shift
    		;;
        esac
    done

    local maybe_sudo=$( [ -n "$not_sudo" ] && echo "" || echo "_sudo_if_necessary")  # if flagged, run regularly as non-superuser. If not, try inputting password in case it's necessary

    local thread_count=$(nproc)
    local bottleneck_threshold=$(echo "scale=3; 100/$thread_count" | bc -l)

    # human-users lookup    
    local human_users=$(list_human_users --max_uid 2000)
    eval $(_hashmap_this_var 'human_users')  # create hashmap: human_users_map

    local current_users=$(ps -eo user= | sort | uniq)  # all current users running on the system
    eval $(_hashmap_this_var 'current_users')  # create hashmap: current_users_map

    local all_users=$(echo -e "$current_users\n$human_users" | sort | uniq)  # all users (joined list but kept only unique)
    local headers='USER,CPU,RAM,@HOME-size'
    local usage_summary user
    for user in $all_users; do
        # determine if the line would be printed in color
        local prnt_cmd=$([ -n "${human_users_map[$user]}" ] && echo "gecho" || echo "echo")  # ternary for choice of command to use
        # CPU usage%, "-" if not in "current_users" (users in process list)
        local cpu_usage=$([ -n "${current_users_map[$user]}" ] && echo $(ps -u $user -o %cpu,%pid | awk '{cpu+=$1} END {printf "%.2f%%\n", cpu/'$thread_count'}') || echo "-")  # user's CPU usage. Divided by num of threads because a ps line with 100% is just 100% single-thread, not 100% on all cores
        # RAM usage%, "-" if not in "current_users" (users in process list)
        local mem_usage=$([ -n "${current_users_map[$user]}" ] && echo $(ps -u $user -o %mem= | awk '{mem+=$1} END {print mem"%"}') || echo "-")  # user's RAM usage
        # Disk usage of user's home-dir. "-" if home-dir doesn't exist
        local disk_usage=$([ -d "/home/$user" ] && echo $($maybe_sudo du -sh "/home/$user" | cut -f1) || echo "-")  # specify home-dir disk usage (if applicable)

        local current_user_usage=$($prnt_cmd "$user\t$cpu_usage\t$mem_usage\t$disk_usage")  # data display format, including the optional coloring
        usage_summary="$usage_summary\n$current_user_usage"
    done

    # get cpu stat directly from /proc/stat , without the rounding errors in "top" ; line from https://stackoverflow.com/questions/9229333/how-to-get-overall-cpu-usage-e-g-57-on-linux
    local total_cpu_usage=$(awk '{u=$2+$4; t=$2+$4+$5; if (NR==1){u1=u; t1=t;} else print ($2+$4-u1) * 100 / (t-t1) "%"; }' <(grep 'cpu ' /proc/stat) <(sleep 1;grep 'cpu ' /proc/stat))
        # total_cpu_usage=$(cat <(grep 'cpu ' /proc/stat) <(sleep 1 && grep 'cpu ' /proc/stat) | awk -v RS="" '{print ($13-$2+$15-$4)*100/($13-$2+$15-$4+$16-$5)}')  # also works
    local total_ram_usage=$(free -h | awk '/^Mem:/ {print $3 "(+" $6 " buff/cache) / " $2}')
    local total_disk_usage=$(df -h / --output=used,size,iused,itotal | tail -n+2 | awk '{ print $1 " / " $2 " ("$3 " / " $4" inodes)"}')

    echo "Computing units count: $(becho $thread_count)"
    echo "If your overall CPU usage reaches $(becho $bottleneck_threshold%), your CPU is possibly bottlenecked on a single thread."

    echo "$(uecho 'Resources currently taken by users:') *verified human users are colored **results are subject to slight shifts over runtime, partially due to this very script's running."
    echo -e "$usage_summary" | column -t -s $'\t' -N "$headers"

    echo "$(uecho 'Total CPU usage:') $total_cpu_usage"
    echo "$(uecho 'Total RAM usage:') $total_ram_usage"
    echo "$(uecho 'Total Disk usage:') $total_disk_usage  *For '/' only. Run devs function to see more."  
    # TODO - check if there is a GPU at all, and support AMD (or Intel) drivers (need to detect)
    [ -n "$show_gpu" ] && ( uecho "GPU utilization info:" ; nvidia-smi -q -d MEMORY,COMPUTE,UTILIZATION ) # if flag --gpu is specified    
}

# run bash shell as given user (switching to user through sudo)
function user_prompt () {
    # TODO - check if given user exists
    # TODO - insert users into shell's auto-completion
    sudo su -l "$1" -s /bin/bash
}


# Administration - services
# =========================

# list crontabs of all users
function all_crontabs () {
    local user
    while read user; do
        crontab -u $user -l 2>/dev/null | grep "^[^#*/;]" | awk '{ print "'$user': "$0; }'
    done <<< "$(list_human_users)"
    
    sudo crontab -u root -l 2>/dev/null | grep "^[^#*/;]" | awk '{ print "root: "$0; }'

}

# TODO - improve the code (refactor)
# interactively create a new systemd service (using templates)
# arg 1: (optional) service name
function create_systemd_service () {
    local service_name
    if [ -n "$1" ]; then
        service_name="$1"
    else
        read -p "Choose the name of your service: " service_name  # Read the user's input
    fi
    service_name=${service_name%.service}  # remove the '.service' if it's there
    local file_name="${service_name}.service"
    local service_file="/etc/systemd/system/${file_name}"
    local is_empty
    [ -s "$service_file" ] && is_empty='NON-empty file - CONTENTS WILL BE DELETED' || is_empty='empty file'
    if _prompt_yn "You'll modify as sudoer: $service_file ($is_empty). Are you ready?"; then echo "Creating file..."; else echo "Come back when you have everything you need." && return ; fi
    
    # provide a template
    local initial_str
    _prompt_yn "Need a template?" && read -r -d '' initial_str << EOT
[Unit]
# rewrite this (don't worry about spaces)
Description=<Insert purpose here>
; Before=<what this service should preceed, e.g. "network.target">
; After=<what should run before this service, e.g. "somethingelse.service">

# should dependencies be inherited by unit's After/Before/Conflicts/BindsTo/PartOf/Wants directives?
; DefaultDependencies=yes/no  

[Service]
# you may want a different user.
User=root
; WorkingDirectory=<path to run at, maybe a project-dir>
ExecStart=<command that starts the service>

# no: The service should not be restarted. This is the default value.
# on-success: The service should be restarted when it exits successfully.
# on-failure: The service should be restarted when it exits with a non-zero exit code or when it terminates abnormally.
# on-abnormal: The service should be restarted when it terminates abnormally.
# on-abort: The service should be restarted when it is terminated by a signal.
# always: The service should be restarted regardless of the exit code or termination status.
; Restart=no/on-success/on-failure/on-abnormal/on-abort/always

# simple: The service is a simple service that runs a single command or process. This is the default value.
# forking: The service is a forking service that creates a new process group when it starts. This type of service is typically used for programs that fork and background themselves when they start.
# oneshot: The service is a one-shot service that runs a command or script and then exits. This type of service is typically used for tasks that need to be performed once and then stopped.
# dbus: The service is a D-Bus service that exports objects over the D-Bus message bus. This type of service is typically used for services that communicate over D-Bus.
# notify: The service is a notify service that sends a notification when it is ready. This type of service is typically used for services that need to signal their readiness to other services or clients.
; Type=simple/forking/oneshot/dbus/notify


[Install]
# who should automatically start this service. multi-user.target is common, it's the state in which multiple users can log in
; WantedBy=multi-user.target  
EOT
    # offer template adjustment
    if [ -n "$initial_str" ] && _prompt_yn "Include guiding comments in the template?"; then echo "Leaving in comments."; else initial_str=$(grep -v "^#" <<< "$initial_str") ; fi

    # insert template into the file (create/clear file if necessary)
    sudo sh -c "echo \"$initial_str\" > \"$service_file\""

    # let the user determine the contents of the service
    sudo nano "$service_file"

    if _prompt_yn "We're done. Want me to reload, enable and start the service?"; then
        becho 'reloading systemd...'
        sudo systemctl daemon-reload  # rescan services
    
        becho 'enabling after boot...'
        sudo systemctl enable "$file_name"  # enable after boot
    
        becho 'starting service...'
        sudo systemctl start "$file_name"

        _wait_n_seconds '3'

        becho "Here's its status now:"
        sudo systemctl status "$file_name"
    fi

}

# removes a given service-name from systemd (including the .service file)
function remove_systemd_service () {
    local service_name="$1"
    [ -z "$service_name" ] && errcho "You need to provide (as arg) the service-name to delete" && return 1

    becho "Removing service from Systemd"
    sudo systemctl stop "$service_name"
    sudo systemctl disable "$service_name"
    sudo systemctl daemon-reload  # rescan services

    local systemd_services_folder='/etc/systemd/system'

    becho "Removing .service file"
    sudo rm "$systemd_services_folder/$service_name.service"
    becho "Removing .service.save file"
    sudo rm "$systemd_services_folder/$service_name.service.save"

}


# Administration - processes
# ==========================

# kill processes by substring, with a confirmation prompt that specifies what's being killed
function kill_interactively () {
    # TODO - add display of top-cpu processes to kill - "you didn't specify what to kill, here are the top-10 CPU intensive processes, if you want to kill any of them, input a number or their name"

    [ $# -ge 1 ] || { errcho "You need to provide a substring to find (and later kill) processes with." ; return ; }
    
    local pids=$(pgrep -i "$1")  # get all PIDs
    [ -z "$pids" ] && becho "no processes found" && return 0;
    local pids_commas=$(echo "$pids" | tr '\n' ',' | sed 's/,$//')  # save PIDs with comma-separation (for listing)
    local pids_spaces=$(echo "$pids_commas" | tr ',' ' ')  # save PIDs with space-separation (for killing)
    local proc_info=$(ps -p "$pids_commas" -o pid,ppid,user,%cpu,%mem,stat,start,time,cmd --sort=-%cpu)

    local prompt="$(echo "$proc_info" ; becho -p "The listed processes $(recho will be killed). Are you sure?")"
    if _prompt_yn "$prompt"; then _sudo_if_necessary kill ${pids_spaces} ; else echo "Quitting." && return ; fi

    _wait_n_seconds 2

    pids=$(pgrep -i "$1")  # get all PIDs, again
    [ -z "$pids" ] && becho "Confirmed no new processes with same substring" || errcho "Found live processes with the same name you just eliminated"
}

# Find processes by substring. Print error if given no args ; print everything if given empty string
function find_proc () {
    [ $# -ge 1 ] || { errcho "No substring provided to look through with." ; return ; }

    ps -eo pid,ppid,user,%cpu,%mem,stat,start,time,cmd --sort=-%cpu | awk -v search="$1" 'BEGIN{IGNORECASE=1} NR==1 || $0 ~ search {print}' \
    | color_word --word "$1"  # color the sought term
}



# Administration - env and packages
# =================================

# install from given (deb file's) URL
function install_deb_from_url () {
    local pkg_name=$(echo "$1" | awk -F/ '{print $NF}')  # get the string after last '/'
    local installation_msg="Installed debian (.deb) package: $pkg_name. If you want to remove it, run: 'sudo dpkg -r $pkg_name'"
    wget "$1" && sudo gdebi -n "./$pkg_name" && echo "$installation_msg"  # download and install
    rm "$pkg_name"  # remove .deb file
}

# Permanently append a string to PATH.
# Add directories like "/home/<you>/.local/bin"
function add_to_path () {
    # check if given arg is already in PATH
    if [[ $PATH == *$1* ]]; then
        echo "$1 is already in PATH!"
        return
    fi
    export PATH=$PATH:$1
	# change the line where "PATH=" appears
    sudo sed -i "/PATH=/c\PATH=$PATH" /etc/environment
    printf "From now on:\n`sudo cat /etc/environment`\n"
}

# TODO
# function reinstall() { : 'performs remove and then install'
#     if [] then;
#     sudo apt remove "$1" -y && sudo apt install "$1" -y
#     fi
#     else
#     echo "package $1 isn't even installed"
# }


# Administration - hardware
# =========================

# Find iommu groups that deal with given word. Useful for passing devices onto VMs.
# arg 1: device substring (example: "usb", or "nvidia", or "SATA") (optional; if not specified, you get all IOMMUs)
function iommu_find () {
    local iommu_group_prefix='IOMMU Group '

    # arg 1: accepted files. Example: /sys/kernel/iommu_groups/*/devices/*
    function _stringify_iommu_files () {
        local file
        for file in $1; do
            local iommu_group=$(echo "$file" | awk -F'/' '{print $(NF-2)}')
            local device_num=$(basename "$file")
            local device_string=$(lspci -nns "$device_num" | sed 's/^[[:alnum:]:.]* //')  # get the device description, but drop the initial number
            echo "${iommu_group_prefix}$iommu_group: device $device_num : $device_string"
        done
    }

    local all_iommu_devices=$(_stringify_iommu_files '/sys/kernel/iommu_groups/*/devices/*' | sort -V)

    local lookup="$1"
    if [ -z "$lookup" ]; then
        errcho "You didn't specify a device substring/word to look-up (Example: \"USB\"). So here are all IOMMUs/devices and connected USB peripherals:"
        echo "$all_iommu_devices"
        lsusb
        return 0 
    fi

    # if you reach here, term search was specified
    local group_texts=()
    local iommu_groupnums=$(grep -i "$lookup" <<< "$all_iommu_devices" | sed "s/^${iommu_group_prefix}\([0-9]\+\):.*$/\1/" | sort -V | uniq)
    local num
    for num in $iommu_groupnums; do
        group_texts+=("$(_stringify_iommu_files "/sys/kernel/iommu_groups/$num/devices/*" | sort -V | color_word "$lookup")")
    done

    becho "IOMMU devices:"
    printf "%s\n" "${group_texts[@]}"

    becho "USB peripherals:"
    lsusb | grep -iF --color=auto "$lookup"

    # To add a device by IOMMU device number (xxxx:xx:xx.x), go to VM Manager, and add "PCI Host Device" with the same number 
}


# Disk/device handling
# ====================

# get comprehensive overview of devices/volumes
function devs () {
    # df results (mounted volumes)
    local df_results=$(df -h -x tmpfs --output=source,fstype,itotal,ipcent,size,pcent,file,target)
    local df_title=$(echo "$df_results" | head -n1)
    local df_content=$(echo "$df_results" | tail -n+2 | sort -k1,1)
    df_results=$(echo -e "${df_title}\n${df_content}" | _pad_end_w_spaces)  # reattaching (now the contents are sorted), and ending lines neatly

    # device names (used as identifiers)
    local df_devices=$(echo "$df_content" | awk 'NR>1 {print $1}')
    local lsblk_devices=$(lsblk -o PATH --noheadings | sort)

    # lsblk minus df results
    # ----------------------
    local unmounted_devices=$(comm -23 <(echo "$lsblk_devices") <(echo "$df_devices"))  # devices in lsblk but not df
    local lsblk_unmounted=$(lsblk -d $(paste -sd ' ' <<< "$unmounted_devices") -o PATH,MODE,FSTYPE,SIZE,LABEL,TYPE,PTTYPE,MODEL,STATE --sort PATH) 
    
    # df results + extra data for same entries
    # ----------------------------------------
    local lsblk_complementary_to_df=$(lsblk -d $(paste -sd ' ' <<< "$df_devices") -o MODE,LABEL,TYPE,PTTYPE,MODEL,STATE,PATH --sort PATH)  # same devices as in df, different columns
    # map the extra data in lsblk to "PATH", which is the same as lsblk's "Filesystem"
    declare -A lsblk_hashmap
    local line
    while read -r line; do
        local key="${line##* }"
        local value="${line% *}"
        lsblk_hashmap["$key"]="$value"
    done <<< "$lsblk_complementary_to_df"
    lsblk_hashmap['Filesystem']=${lsblk_hashmap['PATH']}
    
    # place the maps right after the df results
    local df_and_lsblk=()
    while IFS= read -r line || [[ -n "$line" ]]; do
        local dev_name=$(echo $line | awk '{print $1}')
        local modified_line="$line ${lsblk_hashmap[$dev_name]}"
        df_and_lsblk+=("$modified_line")
    done <<< "$df_results"
    
    
    # print results
    becho 'mounted volumes:'  # results from df with extra details on the same entries from lsblk
    local i
    for i in "${df_and_lsblk[@]}"; do echo "$i" ; done

    becho 'non-mounted volumes:'
    echo "$lsblk_unmounted"

    becho 'identifiers and metadata:'
    lsblk -a -o NAME,MOUNTPOINT,LABEL,UUID,PTUUID,PARTUUID,SERIAL,WWN | awk 'NR==1 || ($1 !~ "loop[0-9]")'
}

# TODO - unused, so remove?
# get device name such as "/dev/sda2". You must provide one argument: the UUID of the device.
function _get_dev_name_from_uuid () {
    [ $# -ge 1 ] || { echo "You need to provide UUID as an argument" ; return 1; }
    blkid | grep "UUID=\"$1\"" | awk -F: '{print $1}'
}

# Mounts, and handles mount-dir. Safe to run when unnecessary, it'll just throw an error.
# arg 1: uuid of device
function mount_media_by_uuid () {
    udisksctl mount -b "/dev/disk/by-uuid/$1"  # add -t <mountpoint>  to change mount-location
}

# write a live-usb interactively. Careful: DESTRUCTIVE!!!
function write_iso_to_usb () {
    local found
    local usb_dev_path
    # interactively get user's choice of usb-drive
    while [ -z "$found" ]; do
        becho "USB devices detected:"
        lsblk -o PATH,MODE,FSTYPE,SIZE,MOUNTPOINTS,LABEL,TYPE,PTTYPE,VENDOR,MODEL,STATE,TRAN | awk '{if(NR==1 || $NF=="usb") print}'
        becho "============================================"

        read -p "Choose the USB device to write into by specifying PATH ('/dev/???') of the disk (not partition): " usb_dev_path  # Read the user's input
        # check that reply is not empty, and is in the list of found devices
        if [[ ! "$usb_dev_path" =~ ^[[:space:]]*$ ]] && lsblk -o PATH,TRAN | awk '$2=="usb" {print $1}' | grep -w -q "$usb_dev_path"; then  # match whole word (case sensitive), quietly
            local brand=$(lsblk -d "$usb_dev_path" -o VENDOR,MODEL --noheadings | xargs)  # keep only vendor and model, no title, one space
            local capacity=$(lsblk -d "$usb_dev_path" -o SIZE --noheadings)  # keep only size, no title
            # another check with the user, because this is serious
            _prompt_yn "Are you sure? This will $(recho PERMANENTLY DELETE) the contents of your \"$capacity $brand\" drive." && found='true'
        else
            errcho "Invalid device: \"$usb_dev_path\""
        fi
    done

    # interactively get user's choice of usb-drive
    local iso_file_path
    while [ ! -e "$iso_file_path" ]; do
        read -p "Provide your image file (typically *.iso): " iso_file_path  # Read the user's input
        [ ! -e "$iso_file_path" ] && recho "invalid file: $iso_file_path"
    done

    _prompt_yn "Last time I'll ask. Write live media using \"$iso_file_path\" into drive \"$usb_dev_path\"?" || { recho "Aborting" ; return ; }
    
    sudo dd bs=4M if="$iso_file_path" of="$usb_dev_path" status=progress oflag=sync
}

# Writes data to volume, to check its capacity. Careful: DESTRUCTIVE!!!
function test_drive_volume () {
    if [ -z "$1" ]; then echo "You didn't provide a drive-name (run lsblk if you're not sure. Should be like '/dev/sdg' ). Aborting." && return 1 ; fi
    
    if _prompt_yn "Your data on $1 is about to be destroyed. Are you sure?"; then echo "Running. Don't remove the device."; else echo "Aborting." && return 1 ; fi
    sudo f3probe --destructive --time-ops "$1"
}


# fix device-mountable-as-read-only issue, caused by Windows leaving some garbage on the disk
function prepare_ntfs_for_writable_mount () {
    lsblk -o UUID,NAME,FSTYPE,LABEL | awk 'NR==1 || $3 == "ntfs"'

    local uuid
    read -p "Choose a UUID to fix (with chkdsk) from the above device-list: " uuid  # Read the user's input
    
    lsblk -o UUID,NAME,FSTYPE,LABEL | awk -v uuid="$uuid" 'NR==1 || $1 == uuid'
    if _prompt_yn "Are you sure this is the right device?"; then echo "Running. Don't touch the device until we're done..."; else echo "Quitting." && return ; fi

    # unmount if necessary
    if findmnt -o UUID | grep "$uuid" > /dev/null; then umount -l "/dev/disk/by-uuid/${uuid}"; fi

    # fix ntfs device
    sudo ntfsfix -b "/dev/disk/by-uuid/$uuid"
}




# Filesystem
# ==========

# TODO - if you ever find out how to put this in a table without messing up filenames with spaces, fix this 
# Custom ls, like "ll". Add -S to sort by (non-recursive) size
function lll () {
    becho "Blocks Permissions Hard-Links Owner Group Size Date_Modified Filename"  # headers, not aligned, but still helpful
    ls -tarlushFN --color=always --time-style="+%Y-%m-%d_%T" --group-directories-first "$@"
}

# take ownership of file (add file-name after this command) 
function claim () {
    local file_list=()
    local potential_file file  # iterators
    for potential_file in $@; do [ -e "$potential_file" ] && file_list+=("$potential_file") ; done
    
    becho "files before ownership change:"
    for file in "${file_list[@]}"; do stat -c '%A(=%a) %U:%G %n' "$file" ; done

    _sudo_if_necessary chown $USER:$USER "$@"

    becho "files after ownership change:"
    for file in "${file_list[@]}"; do stat -c '%A(=%a) %U:%G %n' "$file" ; done
}


# case-insensitive lookup on all files in dir (and subdirs).
# -d <dir> (specify lookup start, default is ".") ; -e <expression> (looked-up expression/substring) ; --text_limit <limit> (how long the results may be, default is maximum: 5000) ; --text_limit_short (same as --text_limit 500) ; --text_limit_medium (same as --text_limit 5000) / --text_limit_unlimited (unlimited response length)
function supergrep () {
    [ $# -ge 1 ] || { echo "You must provide at least one argument, for the lookup-expression" ; return ; }
    # we have a text-length limit to skip gibbrish and text-dumps. It's allowed over 4k, since that's the minimum file-path length.
    local text_limit_default='5000' 
    local text_limit="$text_limit_default"
    local dir='.'
    local first_free_arg_is_exp exp verbose  # defaults, and clearing (in case they're set)
    while [[ $# -gt 0 ]]; do
    	case "$1" in
    		'-d'|'--directory')
    			dir="$2"
    			shift 2
    			continue
    		;;
    		'-e'|'--expression')
    			exp="$2"
    			shift 2
    			continue
            ;;
            '-t'|'--text_limit')
                text_limit="$2"
                shift 2
                continue
            ;;
            '-s'|'--text_limit_short')
                text_limit="500"
                shift
                continue
            ;;
            '-m'|'--text_limit_medium')
                text_limit="5000"
                shift
                continue
            ;;
            '-u'|'--text_limit_unlimited')
                text_limit="-1"
                shift
                continue
            ;;
            '-v'|'--verbose')
                verbose='true'
                shift
                continue
            ;;
            '--help')
                echo -e "bashrc function \"${FUNCNAME[0]}\"
Summary: Grep all files and filenames at a location, recursively. Case-insensitive.
example: supergrep 'to do'
example2: supergrep -d /etc/systemd/ -e restart -v -u 
args:
    -d|--directory <dir_path>\t set the search-dir
    -e|--expression <exp>\t set the search term. You can also set it without a flag
    -t|--text_limit <number>\t set the lext-length limit of lines found. Default is $text_limit_default
        -s|--text_limit_short\t set the lext-length limit of lines found to 500. Equivalent to: -t 500
        -m|--text_limit_medium\t set the lext-length limit of lines found to 5000. Equivalent to: -t 5000
        -u|--text_limit_unlimited\t do not set lext-length limit of lines found. Equivalent to: -t -1
    -v|--verbose\t run in debug mode
    --help\t print this message
"
                return
            ;;
    		*)
                if [ -z "$first_arg_used_as_exp" ]; then
                    first_free_arg_is_exp='true'
                    exp=$1
                else
                    errcho "${FUNCNAME[0]} doesn't know how to handle arg: '$1'"
                fi
    			shift
    		;;
    	esac
    done

    [ -z "$exp" ] && echo "No expression specified. Use -e <expression> to set it." && return 1
    
    [ -n "$verbose" ] && becho "running on directory: \"$dir\"  ;  expression: \"$exp\"  ;  including strings up to length: \"$text_limit\""  # print found arguments (if verbose)

    becho "matching filenames:"
    becho "==================="
    _sudo_if_necessary "find \"$dir\" -iname \"*$exp*\"" | color_word --word "$exp"

    becho "matching file contents:"
    becho "======================="
    local all_results=$(_sudo_if_necessary grep -e "$exp" -Inir "$dir" --color=never)  # No colors. Coloring is done at this stage because otherwise it'll add to the string's length
    if [ $(expr "$text_limit" + 0) -gt 0 ]; then  # if there's a limit for result length
        [ -n "$verbose" ] && becho "filtering with maximum result length: $text_limit" 
        all_results=$(echo "$all_results" | awk "length(\$0) <= $text_limit")
    fi
    echo "$all_results" | color_word --word "$exp"  # print with no filtering by length
}


# get local files size and inner-files count
# arg1: dir to explore , -s (optional: sort by size)
function explore () {
    local location=${1:-.}  # use given address, default to current location
    location=$(readlink -f "$location")  # use absolute path (and use no '/' at the end)

    local total_files=0  # Files (recursive) counter. Can technically just recount current dir, but the results might not be cached

    local filenames=$(find "$location" -maxdepth 1 -type f,d,l)  # get files (files, dirs, links) in given dir
    filenames=$(echo "$filenames" | grep -vw "^$location$")  # throw out the given location (exact match from line start to end)

    [ -z "${filenames}" ] && return 1  # nothing to iterate over
    
    local folders files filename
    while IFS= read -r filename; do
        local size=$(du -sh "$filename" | cut -f1)  # determine size (same command for files/folders)
        local inodes=$(du -s --inodes "$filename" | cut -f1)
        local count=$(find "$filename" -type f,l | wc -l)  # count files and links found. It's just '1' for a file, but the code's shorter this way
        total_files=$(($total_files + $count))

        # handle as dir or file
        if [ -d "$filename" ]; then folders+="$size\t$count\t$inodes\t$filename/\n";
        else files+="$size\t$count\t$inodes\t$filename\n";
        fi
    done <<< "$filenames"

    local data="${folders[@]}${files[@]}"    
    [[ "$@" =~ ^"-s"$ ]] && data=$(echo -e "${data}" | sort -h)  # if flag -s specified, sort ; first datum is size, so that's what we sort by
    echo -e "${data}" | column -t -s $'\t' -N $(becho "total_size,file_count,inodes,name")  # separate nicely with tabs
    echo "current dir total files: $total_files"
    echo "current dir total size: $(du -sh "$location" | cut -f1)"
    echo "current dir inodes use: $(du -s --inodes "$location" | cut -f1)"
}

# finds files that shouldnt be executable and chmods them
function revoke_exe_mod () {
    local location=${1:-.}  # use given address, default to current location
    local format=${2:-'txt'}  # use given format, default to txt
    local files=$(find "$location" -type f -name "*.$format")  # get txt (or specified) files recursively
    local file
    while read -r file; do
        # if file is executable
        if [ -x "$file" ]; then
            # revoke exe permission (run as sudo IF necessary)
            _sudo_if_necessary chmod -x "$file" && echo "file no longer executable: $file"
        fi
    done <<< "$files"
}

# Archive files into .tar.7z format. You can specify any file / file-path, the archive would still be saved to current working directory.
# -o/--overwrite (optional: replace old 7z archive instead of adding another one) ; -p/--password <pass> (optional: encrypt with password) ; all the rest are file-names
function archive_tar7z () {
    # anything unspecified as option/flag is file to archive
    local filenames=() overwrite password
    while [[ $# -gt 0 ]]; do
    	case "$1" in
    		'-o'|'--overwrite')
    			overwrite='true'
    			shift
    			continue
    		;;
    		'-p'|'--password')
    			password="$2"
    			shift 2
    			continue
            ;;
    		*)
                filenames+=("$1")
                shift
    		;;
    	esac
    done

    [ -n "$filenames" ] || { errcho "You need to specify files (or folders) to archive" ; return 1; }

    # note: don't try running multiple in async; tar and 7z already run multi-threaded
    local f
    for f in "${filenames[@]}"; do
        # archive without including whole directory leading to the file
        local full_path="$(realpath "$f")"  # get full path
        local folderpath="$(dirname "$full_path")"
        local filename="$(basename "$full_path")"
        local archive_name="${filename}.tar.7z"

        # determine if the archiving will be done with encryption (password-protected)
        local optional_encryption
        if [ -n "$password" ]; then  # entering an empty string as password doesn't (and shouldn't) count as password
            becho "writing $archive_name with password encryption"
            optional_encryption="-p$password"
            archive_name=$(echo "$archive_name" | sed 's/.tar.7z$/_encrypted.tar.7z/')  # add "_encrypted" to file suffix name. You can't mix encrypted and unencrypted, so they shouldn't be named the same way
        fi

        # if similarly-named archive exists (involves overwrite-flag)
        if [ -f "$archive_name" ]; then
            local already_exists_msg=$(recho "archive \"$archive_name\" already exists")
            if [ -n "$overwrite" ]; then 
                echo "$already_exists_msg. Removing it."
                rm "$archive_name"
            else
                echo "$already_exists_msg. Creating archive with current date."
                archive_name=$(echo "$archive_name" | sed "s/.tar.7z$/_$(date +%Y-%m-%d).tar.7z/")  # add "_<today>" to file suffix name to avoid mixing with old archive
                [ -f "$archive_name" ] && rm "$archive_name" && recho "deleted an existing archive with the same name-date"  # if even the dated archive exists, delete it
            fi

        fi
        
        tar -C "$folderpath" -cvzf - "$filename" | 7za a -si "$archive_name" "$optional_encryption"
    done
    
}

# run file that binds mountdirs to folders
# to delete the dirs added to root, 'sudo umount' them first (to solve the "resource busy" problem)
function symlink_mountpoints () {
    # # The sought file would typically include calls to _bindmount_folder, like so:
    # _shortaccess_folder --uuid b25fb935-b252-466f-8e45-63c8e7f62acf \
        # --subfolder "test/cache folder" --mountpoint "/temp_cache" \
        # --subfolder "logfiles" --mountpoint "/logs" \
        # --nomount
    # if file exists, source (run) it
    if [ -f "$SUBDIR_MOUNTS_FILE" ]; then
        source "$SUBDIR_MOUNTS_FILE"

        becho "Done creating shortened accesses (\"mountpoints\"). Now re-sourcing this bashrc file to update the session with them"
        source "$CUSTOM_BASHRC_FILE"
    else 
        errcho "can't find file $SUBDIR_MOUNTS_FILE , exiting."
        return 1
    fi  
}

# link a subfolder within a device (by uuid) to a directory in root
# --uuid <UUID> , --subfolder <dir_in_device> (directory withing the device) , --mountpoint <dir> (short-access path; each in accordance to specified folder) , --nomount (optional: don't mount device if it's unmounted, just exit)
function _shortaccess_folder () {
    local uuid nomount folders=() mountpoints=()
    while [[ $# -gt 0 ]]; do
    	case "$1" in
            '--uuid')
    			uuid+="$2"
    			shift 2
                continue
    		;;
            '--subfolder')
    			folders+=("$2")
    			shift 2
                continue
    		;;
            '--mountpoint')
    			mountpoints+=("$2")
    			shift 2
                continue
    		;;
            '--nomount')
        		nomount='true'
        		shift
                continue
        	;;
            *)
                errcho "${FUNCNAME[0]} doesn't know how to handle arg: '$1'"
    			shift
    		;;
        esac
    done

    
    [ -z "$uuid" ] && { errcho 'You need to specify device-UUID' ; return 1 ; }  # Check that UUID was provided
    [ -z "$folders" ] && { errcho 'You need to specify subfolder(s) within the device' ; return 1 ; }  # Check for provision of device subdir(s)
    [ -z "$mountpoints" ] && { errcho 'You need to specify mountpoint(s)' ; return 1 ; }  # Check for provision of mountpoint(s)
    [ ${#folders[@]} -ne ${#mountpoints[@]} ] && { errcho 'Number of dirs and number of mountpoints must match' ; return 1 ; }  # Check that every folder is mapped to a mountpoint, and vice-versa
    
    lsblk -a -o UUID | tail -n +2 | grep -Fxq "$uuid" || { errcho "UUID \"$uuid\" isn't connected or doesn't exist!" ; return 1 ; }  # Check that UUID is usable
    
    # if device is not mounted, and we're not told to avoid mounting it: mount it
    ! findmnt -S UUID="$uuid" >/dev/null && [ -z "$nomount" ] && mount_media_by_uuid "$uuid" >/dev/null

    local dev_mountpoint=$(udisksctl info -b "/dev/disk/by-uuid/$uuid" | grep MountPoints | awk '{print $2}')  # print mount location
    if [ -z "$dev_mountpoint" ]; then
        # if was supposed to mount
        if [ -z "$nomount" ]; then errcho "Failed to mount device uuid: \"$uuid\"!!!";
        else becho -p "Avoided mounting $(recho unmounted device uuid: "\"$uuid\""), as requested"
        fi
        return 1
    fi

    becho "Device (name label UUID) '$(lsblk -no NAME,LABEL,UUID "/dev/disk/by-uuid/$uuid")' is mounted."  # at this point the device is mounted.

    # iterate on couples (inner-paths , mountpoint) 
    local i
    for i in "${!mountpoints[@]}"; do
        local folder_fullpath="$(readlink -f "$dev_mountpoint/${folders[i]}")"  # get supposed full path based on provided subdir (in a way that prevents possible // instead of / after concatenation)
        local mountpoint="${mountpoints[i]}"
        
        # check subdir validity
        [ -d "$folder_fullpath" ] || { errcho "The subdir \"${folders[i]}\" (full path: \"$folder_fullpath\") doesn't exist as a dir"; continue; }

        # check mountpoint validity
        [[ "$mountpoint" =~ ^/[a-zA-Z0-9_]+$ ]] || { errcho "The mountpoint \"$mountpoint\" doesn't conform to the expected path format"; continue; }
        [[ -e "$mountpoint" && ! -L "$mountpoint" ]] && { errcho "The mountpoint \"$mountpoint\" exists but not as a symlink. I'm not touching that. Skipping."; continue; }
        
        # whether the mountpoint exist or not, create it
        # [ -L "$mountpoint" ] && sudo rm "$mountpoint"
        sudo ln -sfn "$folder_fullpath" "$mountpoint"  # softlink (forced in case exists) with same properties as target. Has to be done as superuser since it's in root-dir
        echo "$(dagecho "created link:") $(ls -alF "$mountpoint")"
            # # create it as mount bind (makes more sense if it's on the same drive)
            # sudo mkdir "$mountpoint"  # create the dir
            # sudo mount --bind "$folder_fullpath" "$mountpoint"  # has to be done as superuser
            # echo "$(dagecho "created bind: \"$mountpoint -> $folder_fullpath"\"). To remove it, run: \"sudo umount $mountpoint && sudo rmdir $mountpoint\""

        # chown/chmod it accordingly - skipped, as we're using symlinks (which leave permissions up to target file)
    done
}



# Media file manipulation
# =======================

# arg 1: media_file
function media_remove_audio () {
    local output="${1%.*}_noaudio.${1##*.}"  # add "_noaudio" before the file's .<format>
    ffmpeg -i "$1" -c copy -an "$output"
}

# usage: -v/--video <video_file>  -a/--audio <audio_file>
function media_merge_audio_video () {
    local video_file audio_file
    while [[ $# -gt 0 ]]; do
    	case "$1" in
    		'-v'|'--video')
    			video_file="$2"
    			shift 2
    			continue
    		;;
    		'-a'|'--audio')
    			audio_file="$2"
    			shift 2
    			continue
            ;;
    		*)
                errcho "${FUNCNAME[0]} doesn't know how to handle arg: '$1'"
                return 1
    		;;
    	esac
    done

    [ -z "$video_file" ] && errcho "no video file specified" && return 1
    [ -z "$audio_file" ] && errcho "no audio file specified" && return 1

    local output="${video_file%.*}_replaced_audio.${video_file##*.}"  # add "_replaced_audio" before the video file's .<format>

    ffmpeg -i "$video_file" -i "$audio_file" -c:v copy -c:a libvorbis "$output"
}

# compare between media files
# all args are media-file paths
function media_compare () {
    local md_results=() i
    for i in "$@"; do local md_results+=("$(media_metadata "$i")"); done
    _side_by_side --lined "${md_results[@]}" 
}

# TODO - create a function that uses youtube-dl and other website downloaders; have it accept any download-link. 


# Artificial Idiocy (the "intelligence" part isn't done in this project. But it's still "A.I.")
# =================

function chatgpt_ask () {
    [ -z "$CREDENTIALS_OPENAI" ] && errcho "no credentials found for ChatGPT"

    curl --request POST 'https://api.openai.com/v1/chat/completions' \
--header "Authorization: Bearer $CREDENTIALS_OPENAI" \
--header 'Content-Type: application/json' \
--data-raw "{\"model\": \"gpt-3.5-turbo\", \"messages\": [{\"role\": \"user\", \"content\": \"$@\"}]}"

    # TODO pretty-print the reply (if they'll allow sending a request without payment)
}


# Virtual Machines
# ================

#TODO - offer to choose a vm by number [1-n]. Need to create a function like y_n one that gets a dicitonary as an argument 
# TODO - offer to add USB (and other?) devices by ID (from displayed list). Filter out devices already in XML.
# interactively launch looking-glass session and VM (if not running). 
function launch_vm_w_lookingglass() {
    local is_vm_chosen vm_name
    while [ -z "$is_vm_chosen" ]
    do
        becho "Choose the name of the VM you want to launch:"
        virsh list --all
        becho "============================================="

        read -p "Enter the name of the VM: " vm_name  # Read the user's input
        if virsh list --all --name | grep -w -q "$vm_name"; then  # match whole word (case sensitive), quietly
            is_vm_chosen='true'
        else
            errcho "Invalid VM name"
        fi
    done

    # look up info within the vm's definitions file
    local xml_file="/etc/libvirt/qemu/${vm_name}.xml"

    # get the shmem name:
    local shmem_name=$(sudo awk -F 'name=' '/shmem/ {gsub("'\''", "", $2); print $2}' "$xml_file" | sed 's/^"\([^"]*\)".*/\1/' | sed 's/>$//')  # extract the string between the quotes, remove the quotes, remove the closing '>'
    local lg_file="/dev/shm/$shmem_name"

    # get the vnc port number from xml
    local portnum=$(sudo grep -oP "<graphics type=[\"']spice[\"'] port=[\"']\K\d+" "$xml_file")  # works for either single or double quotes
    portnum=${portnum:=5900}  # default if empty

    # Show user the parameters and ask for approval (quit if disapproved)
    becho "Please authorize the following. Note: no two running VMs may have the same looking-glass session-file or VNC-port at the same time"
    if _prompt_yn "$(becho "VM:") $vm_name, $(becho "looking-glass_name:") $shmem_name, $(becho "VNC-port:") $portnum. Launch with these parameters?"; then
        echo "Starting..." 
    else 
        echo "Quitting. If the details were off, modify your VM's xml file (easiest through VM Manager, but you can also run: \"virsh edit $vm_name\")" 
        return
    fi

    becho "Making sure os-virtual-drive file's volume is mounted"
    mount_media_by_uuid "$QEMU_VOLUME_UUID"

    becho "Creating looking-glass session file: $lg_file"
    sudo touch "$lg_file" && sudo chown $(whoami):kvm "$lg_file" && sudo chmod 660 "$lg_file"
    [ -f "$lg_file" ] && ls -alF "$lg_file"  # todo - print colored (green?)?
    
    # run the vm (if needed)
    local vm_state=$(virsh domstate "$vm_name")
    if [ "$vm_state" == "running" ]; then
        gecho "$vm_name is already running."
    elif [ "$vm_state" == "shut off" ]; then
        virsh start "$vm_name" && gecho "starting $vm_name"
    elif [ "$vm_state" == "paused" ]; then
        virsh resume "$vm_name" && gecho "resuming $vm_name"
    else
        errcho "Can't handle VM state: $vm_state"
        if [ "$vm_state" == "blocked" ]; then errcho "the VM '$vm_name' is blocked on resource";
        elif [ "$vm_state" == "shutdown" ]; then errcho "$vm_name is still shutting down";
        elif [ "$vm_state" == "crashed" ]; then errcho "the VM '$vm_name' has crashed";
        elif [ "$vm_state" == "pmsuspended" ]; then errcho "the VM '$vm_name' is in a suspended state as a result of power management";
        else errcho "Error: VM state isn't defined (fix this function)"
        fi
        return 1
    fi
    
    # run looking glass client
    # experimental -S : Prevent the screensaver from starting  , win:size=1920x1080 : Initial window size at startup (default is 1024x768)
    becho "Starting looking-glass client"
    "$LOOKING_GLASS_CLIENT" -f "$lg_file" -p $portnum -k -S & disown # -k : enable FPS & UPS display  ; -S : prevent host going to sleep

}


# String handling
# ===============

# useful for drawings or neat concatenating of tables like so: 'paste <(_pad_end_w_spaces "$(df -h)") <(_pad_end_w_spaces "$(df -hi)") <(_pad_end_w_spaces "$(df -hi)")'
# Append spaces to text lines for a rectangular look; i.e. end uniformly on the same column.
# Also works with pipes. Could be problematic for table formatting if color is involved (colors are extra unseen chars)
function _pad_end_w_spaces () {
    text="$1"  # assume that text is provided as an argument
    if [ -z "$text" ] && ! [ -t 0 ]; then text=$(cat); fi  # if no arg given and there's a stream from a pipe, get the stream contents as text
    awk '{hi[NR]=$0; max_len=length($0) > max_len ? length($0) : max_len} END {for (line in hi) { printf "%s%*s\n", hi[line], max_len-length(hi[line]), "" }}' <<< "$text"
}

# pastes text blocks (given as args) side by side
# --lined (optional before texts: separate with line instead of space) , --glued (optional before texts: no delimiter) , --no_padding (optional before texts: no padding)
function _side_by_side () {
    local separator=' ' no_padding
    [ "$1" = "--lined" ] && separator='|' && shift  # get rid of the flag, so it won't disturb us
    [ "$1" = "--glued" ] && separator='' && shift  # get rid of the flag, so it won't disturb us
    [ "$1" = "--no_padding" ] && no_padding='true' && shift  # get rid of the flag, so it won't disturb us

    
    # prepare to add more lines to texts that are too short
    local line_counts=() i
    for i in "$@"; do line_counts+=($(echo "$i" | wc -l)); done  # count the number of lines for each
    local max_lines=$(max "${line_counts[@]}")

    local args=("$@")  # for iteration. can't iterate on the index of $@ - the items start from 1, but the index starts on 0 ("bash") unlike lists that start their index at 1
    local paste_texts=()  # the values that need to be pasted
    local items_to_interpret=()  # will be made into a string that refers to the values; interpreted into a command
    for i in "${!args[@]}"; do  
        local modified_txt_block="${args[i]}"  # actual item
        # add empty lines
        local line_diff=$(( max_lines - line_counts[i] ))  # how many lines are "missing"
        [ $line_diff -gt 0 ] && modified_txt_block+=$(echo -e "\n$(yes " " | head -$line_diff)")  # if text is shorter than max, add newlines (add [diff] 1-line spaces below - need an additional newline before those)
        # pad to allow concatenating without messing up the lines
        [ -z "$no_padding" ] && modified_txt_block=$(_pad_end_w_spaces "$modified_txt_block")
        # add to list that we'll reference in the command
        paste_texts+=("$modified_txt_block")  # data list
        items_to_interpret+=('<(echo "${paste_texts['$i']}")')  # pointers to data
    done
    
    eval "paste -d '$separator' ${items_to_interpret[@]}"
}

# get <arg 1> spaces
function _repeat_space_n_times () {
    local i
    for (( i = 0; i < "$1"; ++i )); do echo -n " "; done
}

# create a block of whitespace
# arg 1: height (number of rows), arg 2: width (number of columns)
function _repeat_whitespace_rows () {
    (($1 <= 0)) && return
    (($2 <= 0)) && return
    
    local whitespace_line=$(_repeat_space_n_times "$2")
    local i
    for (( i=1; i<=$1; i++ )); do
        echo "$whitespace_line"
    done
}

# removes whitespaces from line-starts
function rm_leading_whitespaces () {
    local expression='s/^[[:space:]]*//'
    if ! [ -t 0 ]; then sed "$expression" ;  # modify the data from pipe
    else echo "$@" | sed "$expression";  # or modify the data from args
    fi
}


# Graphical/Visual/Stylizing
# ==========================


# echo in red
function recho () { _colored_echo "<=bold=><=red=>" "$@"; }
# echo in dark red
function darecho () { recho "<=dark=>" "$@" ; }
# echo in green
function gecho () { _colored_echo "<=bold=><=green=>" "$@" ; }
# echo in dark green
function dagecho () { gecho "<=dark=>" "$@" ; }
# echo in blue
function becho () { _colored_echo "<=bold=><=blue=>" "$@" ; }
# echo in cyan
function cecho () { _colored_echo "<=bold=><=cyan=>" "$@" ; }
# echo in yellow
function yecho () { _colored_echo "<=bold=><=yellow=>" "$@" ; }


# underlined echo
function uecho () { _colored_echo "<=bold=><=uline=>" "$@" ; }
# underlined echo in red
function ruecho () { recho "<=uline=>" "$@" ; }
# underlined echo in green
function guecho () { gecho "<=uline=>" "$@" ; }
# underlined echo in blue
function buecho () { becho "<=uline=>" "$@" ; }
# underlined echo in yellow
function yuecho () { yecho "<=uline=>" "$@" ; }


# echo into error output
function errcho () { recho "$@" >&2 ; }

# print string with a similarly-lengthed line
# arg 1: string , arg 2 (optional): line-char (default is '-')
function _underline () {
    local char=${2:-'-'}  # determine which char to repeat in underline
    local input_string_length=${#1}
    
    local line=$(printf "%${input_string_length}s" | tr ' ' "$char")  # Create a line of the specified character with the same length as the input string

    echo "$1"
    echo "$line"
}

# colors a specified substring within given text, like grep without line filtering
# -t/--text <text> (specify text to color, if it's not piped-in) ; -w/--word <word> (substring to color, no option needed if it's the only arg and text is piped-in) ; -c/--color <color-string> (see available colors in "_draw_formatted", default is red)
function color_word () {
    local text word color='<=bold=><=red=>'
    if [ $# -eq 1 ] && ! [ -t 0 ]; then  # only 1 arg + streamed input. Given arg is the word that needs to be colored.
        word="$1"
    else  # "regular" case
        while [[ $# -gt 0 ]]; do
        	case "$1" in
        		'-t'|'--text')
        			text="$2"
        			shift 2
        			continue
        		;;
        		'-w'|'--word')
        			word="$2"
        			shift 2
        			continue
                ;;
                '-c'|'--color')
                    color="$2"
                    shift 2
                    continue
                ;;
        		*)
                    return  # received undefined argument
        		;;
        	esac
        done
    fi

    # If text is not provided via --text, and if standard input (piped data) exists : assign standard input to text
    if [ -z "$text" ] && ! [ -t 0 ]; then text=$(cat); fi

    [ -z "$text" ] && return 1  # no text given
    [ -z "$word" ] && echo "$text" && return # no word

    # insert tags around word, I makes it case-insensitive
    _draw_formatted "$(echo "$text" | sed -e "s/$word/$color&<=reset=>/gI")"
}


# Tag-coloring
# ============

# make given tag persistant
function _tag_persist () {
    echo "<=persist${@}this=>"
}

# TODO - detect if the terminal is bright instead of dark? If it's white, the colored prints should be darker; so you should remove the "\033[1m" prefix
# recolors all lines with specified color
# any early arg: color (see available colors in "_draw_formatted") , any early arg: -p (optional - turn tag to persistant) , any early arg: -n (optional - no coloring, just tagging) , any early arg: -t (optional - just return the tag itself) , last arg: text to color
function _colored_echo () {
    local no_drawing persist tag only_tag
    while [[ $# -gt 0 ]]; do
        if [ "$1" == '-n' ]; then  # just put in the tags, don't draw
            no_drawing='true'
            shift
        elif [ "$1" == '-p' ]; then  # persisting tag
            persist='true'
            shift
        elif [ "$1" == '-t' ]; then  # only return the tag, don't do any text/color-related work
            only_tag='true'
            shift
        elif [[ "$1" =~ ^'<='.+'=>'$ ]]; then  # found color tag to apply
            tag+="$1"
            shift
        else  # regular text - we're done scanning for options
            break
        fi
    done

    [ -z "$tag" ] && errcho "Didn't get a tag to color with, and that's the whole purpose of this function" && return 1  # if no coloring tag picked

    [ -n "$persist" ] && tag=$(_tag_persist "$tag")  # if requested to "upgrade" to persistant tag

    [ -n "$only_tag" ] && echo "$tag" && return  # if requested to only return the tag

    local formatted=$( echo "$@" | while IFS= read -r line; do echo "${tag}${line}<=reset=>"; done )
    if [ -n "$no_drawing" ]; then
        echo "$formatted"
        return
    else
        _draw_formatted "$formatted"  # automatically puts the color reset at the ends of the lines
        return
    fi
}

# comment-colorized echo
# -l (optional: include legend)
function commecho () {
    local bullet_point_color='<=green=>'
    local double_cat_line_color=$(_tag_persist '<=bold=><=blue=>')
    local single_cat_line_color=$(_tag_persist '<=blue=>')
    local plus_line_color=$(_tag_persist '<=bold=><=yellow=>')
    local sharp_comment_color=$(_tag_persist '<=yellow=>')
    local colon_comment_color=$(_tag_persist '<=yellow=>')
    local sharp_documentation_color=$(_tag_persist '<=green=>')
    local double_quotes_color='<=bold=><=red=>'
    local warning_color='<=flicker=><=uline=><=bold=><=red=>'
    # angled_brackets_color='<=italic=>'  # problematic when within a color that's already within persisting color  # TODO - fix (improve the coloring function)
    local reset='<=reset=>'

    while [[ $# -gt 0 ]]; do
        case "$1" in
        	'-l'|'--legend')
                local legend_items=(
                "$(_draw_formatted "${double_cat_line_color}topic")"
                "$(_draw_formatted "${single_cat_line_color}sub-topic")"
                "$(_draw_formatted "${plus_line_color}trick/tip")"
                "$(_draw_formatted "${sharp_comment_color}# comment/explanation")"
                "$(_draw_formatted "${sharp_documentation_color}# documentation")"
                "$(_draw_formatted "${double_quotes_color}\"specifics\"")"
                "$(_draw_formatted "${warning_color}\"WARNING!!\"")"
                # "$(_draw_formatted "${angled_brackets_color}<your-choice>")"
                )
                # Alternatively use this (with the command substitution, so IFS change won't stay) if you want tab-separation: $(IFS=$'\t'; echo "${legend_items[*]}
                # print list separated by comma+spaces into variable, and remove comma and any space after it
                echo -e "Legend: $(printf '%s , ' "${legend_items[@]}" | sed 's/,\s*$//' )"  # with an extra line (that's what the -e is there for), to separate the legend from the data
                shift
        		continue
        	;;
        	*)
                break  # no more options, now it's just data
        	;;
        esac
    done

    local formatted="$@"  # get all of the input
    [ -z "$formatted" ] && formatted=$(cat)  # if text wasn't in args, get it from redirected input (or pipe)
    # formatted=$(echo "$formatted" | sed -E "s/(<[^>]+>)/$angled_brackets_color\1$reset/g")  # recolor within '< >' (user-input). Needs to run first, to not modify the color tags
    formatted=$(echo "$formatted" | sed -E "s/(\"[^\"]*\")/$double_quotes_color\1$reset/g")  # recolor within " " (specifics)
    formatted=$(echo "$formatted" | sed "s/^* /${bullet_point_color}*${reset} /g")  # replace beginning '* ' with a colored asterisk and space  (bullet-points)
    formatted=$(echo "$formatted" | sed "s/^>>.*$/${double_cat_line_color}&/g")  # recolor lines beginning '>>'  (topics)
    formatted=$(echo "$formatted" | sed "s/^>.*$/${single_cat_line_color}&/g")  # recolor lines beginning '>'  (sub-topics)
    formatted=$(echo "$formatted" | sed "s/^+.*$/${plus_line_color}&/g")  # recolor lines beginning '+'  (notes)
    formatted=$(echo "$formatted" | sed "s/  #.*$/${sharp_comment_color}&/g")  # recolor after '  #'  (code-comments)
    formatted=$(echo "$formatted" | sed "s/^# /${sharp_documentation_color}&/g")  # recolor after '# '  (page's documentation)
    formatted=$(echo "$formatted" | sed "s/  :.*$/${colon_comment_color}&/g")  # recolor after '  :'  (item-comments)
    formatted=$(echo "$formatted" | sed "s/[A-Z]\+![!]\+/${warning_color}&/g")  # recolor capitalized words with at least two '!' exclamation marks
    _draw_formatted "$formatted"  # automatically puts the color reset at the ends of the lines
}

# recolors text by replacing color tags with their appropriate color-codes
# arg 1: text
function _draw_formatted () {
    declare -A colors=(
    # less standard colors
    [<=orange=>]='\033[38;5;208m'
    # colors
    [<=black=>]='\033[30m' [<=red=>]='\033[31m' [<=green=>]='\033[32m' [<=yellow=>]='\033[33m' [<=blue=>]='\033[34m' [<=purple=>]='\033[35m' [<=cyan=>]='\033[36m' [<=grey=>]='\033[37m'
    # bright colors (work like regulat when stylized bold)
    [<=b_black=>]='\033[90m' [<=b_red=>]='\033[91m' [<=b_green=>]='\033[92m' [<=b_yellow=>]='\033[93m' [<=b_blue=>]='\033[94m' [<=b_purple=>]='\033[95m' [<=b_cyan=>]='\033[96m' [<=b_grey=>]='\033[97m'
    # highlights / markers (can be switched with text color using 7m). If you want to "hide" text as a solid block of color run the same colors for both (i.e. \033[43m\033[33m)
    [<=h_black=>]='\033[40m' [<=h_red=>]='\033[41m' [<=h_green=>]='\033[42m' [<=h_yellow=>]='\033[43m' [<=h_blue=>]='\033[44m' [<=h_purple=>]='\033[45m' [<=h_cyan=>]='\033[46m' [<=h_grey=>]='\033[47m'
    # bright backgrounds (highlights)
    [<=bh_black=>]='\033[100m' [<=bh_red=>]='\033[101m' [<=bh_green=>]='\033[102m' [<=bh_yellow=>]='\033[103m' [<=bh_blue=>]='\033[104m' [<=bh_purple=>]='\033[105m' [<=bh_cyan=>]='\033[106m' [<=bh_grey=>]='\033[107m'
    # stylizing
    [<=bold=>]='\033[1m' [<=dark=>]='\033[2m' [<=italic=>]='\033[3m' [<=uline=>]='\033[4m' [<=flicker=>]='\033[5m' [<=fast_flicker=>]='\033[6m' [<=switch_fg_bg=>]='\033[7m' [<=hidden=>]='\033[8m' [<=crossed=>]='\033[9m'
    # reset
    [<=bold_reset=>]='\033[22m' [<=italics_reset=>]='\033[23m' [<=reset=>]='\033[0m'
    )

    # basic preparations
    local text_to_draw="$1"
    local reset_key='<=reset=>'

    # apply persistance by tags
    # -------------------------
    # persistence means that a specified color-tag needs to return by default (after other specified colors are reset) for the rest of the line
    local persist_tag_open='<=persist'
    local persist_tag_close='this=>'
    # If there's use of persistence, handle it line-by-line. If not, skip it (save time)
    [[ "$text_to_draw" =~ ($persist_tag_open)(.*)($persist_tag_close) ]] && text_to_draw=$(
        local line
        echo "$text_to_draw" | while IFS= read -r line; do  # read current text line by line (without losing the leading/trailing spaces)
            if [[ "$line" =~ (.*)($persist_tag_open)(.*)($persist_tag_close)(.*) ]]; then  # each line can have up to 1 persisting color-tag
                local part_to_leave_alone="${BASH_REMATCH[1]}"
                local tag_to_persist="${BASH_REMATCH[3]}"  # get the tag that's necessary to persist
                local part_to_modify="${BASH_REMATCH[5]}"
                local modified="$part_to_modify"
                modified="$(echo "$modified" | sed "s/$reset_key/${reset_key}${tag_to_persist}/g")"  # attach the persisting tag after each reset tag
                modified="$(echo "$modified" | sed "s/\x1b\[0m/&$tag_to_persist/g")"  # attach the persisting tag after each previously-translated reset tag (escape)
                echo "${part_to_leave_alone}${tag_to_persist}${modified}"  # we place back the cleaned tag and modified line, skipping the opening/closing tag, they're no longer needed.
            else
                echo "$line"
            fi
        done
    )

    # add resets
    # ----------
    local reset_value="${colors[$reset_key]}"
    local reset_value_escaped=$(printf "%q" "$reset_value")  # for sed. It needs pre-reset string.
    local regex_tag='<=[a-zA-Z_]+=>'
    local regex_ws_tag='<=([0-9]+)WS=>'
    text_to_draw="${text_to_draw//$reset_key/$reset_value}"  # replace reset on its own, because otherwise we'd replace it with 2 consecutive color resets later (still works, but isn't right)
    text_to_draw=$(echo "$text_to_draw" | sed -r "/^($regex_tag)+/!s/($regex_tag)+/$reset_value_escaped&/g")  # put reset before each group of color tags, but not if they're at the start
    text_to_draw=$(echo "$text_to_draw" | sed -r "s/($regex_ws_tag)/$reset_value_escaped\1/g")  # put reset before spaces-insert
    text_to_draw=$(echo "$text_to_draw" | sed -r "/$reset_value_escaped$/!s/$/&$reset_value_escaped/g")  # add resets at the ends of lines, but only if they're missing
    

    # insert whitespaces
    # ------------------
    local repeated_char=' '
    while [[ "$text_to_draw" =~ '<='([0-9]+)'WS=>' ]]; do  # while there's still a whitespace-tag
        local num="${BASH_REMATCH[1]}"
        local numtag="<=${num}WS=>"
        local repeats=$(printf "%${num}s" | tr " " "$repeated_char")  # create a sequence of <num> spaces
        text_to_draw="${text_to_draw//$numtag/$repeats}"
    done

    # swap-in all the colors (replace keys with values)
    # -------------------------------------------------
    local str
    for str in "${!colors[@]}"; do
        text_to_draw="${text_to_draw//$str/${colors[$str]}}"
    done

    echo -e "$text_to_draw"

}

# the best function in this entire collection
function draw_hentai () {
    local HY='<=b_yellow=>'  # Hair Yellow
    local HYD='<=yellow=>'  # Hair Yellow Dark
    local S='<=reset=>'  # skin
    local SD='<=b_red=>'  # Skin Dark
    local EW='<=b_grey=>'  # Eyes white
    local W='<=grey=>'  # teeth White
    local WD=$S  # teeth White Dark
    local WS='<=dark=><=b_grey=>'  # White Shirt
    local WSD='<=b_black=>'  # White Shirt Dark
    local G='<=dark=><=red=>'  # Glove and eyebrows Brown
    local GD='<=b_black=>'  # Glove Brown Dark
    local D='<=dark=><=b_black=>'  # dark
    
    declare -A SPR # whitespaces that'll reset colors in drawing
    local num
    for num in {1..25}; do SPR[$num]="<=${num}WS=>"; done
    declare -A SP # whitespaces. just spaces.
    for num in {1..25}; do SP[$num]="$(_repeat_space_n_times ${num})"; done
    local WS_unconventional='⠀'

    # don't try to peek at the drawing here, go run the command in terminal
    local surprise
    read -r -d '' surprise << EOM
${SPR[17]}$HY⠰⡘⡸⢏$HYD⠼⠋$HY⡀⣱$HYD⢏⣾⣿⣿⣿⣿⣿⣿⣿⣧⠻⣿⣿⣷⣦$HY⡪⡳⠹⣷⣀⣀
${SPR[17]}$HY⢀⣽⣿⡶⣢⢸$HYD⡇⡏⣾⣿⠹⣿⣆⢻⣿⣇⢿⣿⣷⡙⠿⣿⣿⣿⣮$HY⠢⣽⡯⡑⠂
${SPR[17]}$HY⢘⣷⡱$HYD⣾⡟⠊⠧⠈⠟⢿⣧⢙⠻⣇⠙⢿⣎⢛⡻⠿⠦⠐⠩⠭⣭⣷⡜$HY⢷⡌⠄
${SPR[15]}$HY⠢⠴⣾⣛$HYD⢱⣿⡑$S⡀$HYD⡀⠄$S⢸$SD⢧$HYD⠹⠸⠁⣈${SP[1]}⣰$SD⠌⣥$HYD⡈⢙⣿⠻⢛$SD⠭$HYD⠻⣿⡄$HY⡸⣧
${SPR[16]}$HY⠠⢪⣇$HYD${SP[1]}⣇⢳${SP[1]}$S⣇⢻⡄$HYD⠆⡁$EW${SP[2]}$HYD⠁$EW⣀$SD${SP[1]}⢾⣿⣿⣶${SP[1]}⣰⢁⡛⠇$HYD⢿⣿$HY⢸⡇
${SPR[16]}$HY⠁⢸⢻$HYD⡰$S${SP[1]}$G⠈⠐$S⠩⠸⣄${SP[1]}⠢⣀$EW⠃$S⣀⣴⣿⣷⣮$SD⢻⣿⢠⡟⠠⢛⡘$HYD⢸⡏$HY⡞⠤
${SPR[17]}$HY⢀⡌$HYD${SP[1]}⡴⣆$EW⠠$S${SP[1]}⣠⣷⣵⣿⣿⣿⣿⣿⣿⣿⣿$SD⣿⣿⣿⡿⠒⢅$HYD⣴⣿⠃$HY⢎⢩⡄⡀
${SPR[20]}$HYD⠃⠿$S⢸⣿⡇⢙⠿⠛⣻⣿⣿⣿⡿⣿⡇$SD⣿⣿⣿⡇$HYD⠰⣾⣿⣿$HY⢸⠈⠃⠉⠁
${SPR[23]}$S⢿⣿⡶⠬⡾⠿⣛⣛⢛⢰⣿⡇$SD⣿⣿⣿⡇⢧$HYD⡉⠻⢿$HY⠂⢃
${SPR[23]}$S⠈⢻⣿⣆$W⠋⠉$D⣀⣀⠂$S⣾⣿$SD⢸⣿⣿⠛${SP[1]}⠸⠁⠆$HYD⣾⣦$HY⡲⡒⠂
${SPR[25]}$S⠙⢿⣇$W⠘⠻⢕$S⣴⣿⡏$SD⣾⠟⣡⠆⠄${SP[3]}$HYD⠹⠟⠃$HY⢈⠷⡀
${SPR[11]}$G⣀⣀⣠$S⢠⡀${SPR[10]}$S⠈⢻⣟⠫⢍⣰⡿$SD⢐⣥⣾⠟${SP[9]}$HY⢠⠈
${SPR[8]}$G⣠⠠⠴⠦$S⣻⣿⠌$SD⣴${SP[1]}⣐⣺⣿⠷${SPR[7]}$S⠛⠿⠟$SD⣩⣴⣿⠿⠁${SP[10]}$HY⢸⡆
${SPR[6]}$G⣀⡌⢦⡙$S⠰⠿⠟$SD⢁⢡$GD⣾$SD⠸⣿⠏${SPR[8]}$WS⢤⣶⣆$SD⠇⣼⠟⠁${SP[1]}$SD⢀⣀⣀⡤⠤⣤$WSD⣶⣶⠆${SP[2]}$HY⠸⠇
${SPR[5]}$G⣼⢻⡟⣪$S⡘⠿$SD⠉⣸$GD⡿⠘⠋${SPR[9]}$WS⡄⠦⠠⡀$WSD⠹⡄${SP[2]}⠴⣾⠿⠙⠉⠁${SP[1]}⢹⣿⡇
${SPR[3]}$G⣠⣰⣿⠄$SD⠘⣿⠍$GD⢰⢣⡿⠃${SPR[11]}$WS⢇⢠⢀$WSD${SP[2]}⠁⣄${SP[1]}⢀⣰⡀⢀⠤⡆⠠${SP[1]}⠃${SP[2]}⢀⣴⣶⣿⢿⣿⣿⣿⡶⠖⠒⠢
$G⣀⣿⠟$GD⣴⣿⣿⣦⡣⠡${SP[1]}⠛${SPR[9]}$WS⣀⣠⣭⣭⣵⣮⡙⢾⣷⡆$WSD⠐⣿⣷⣾⣿⣿⣗⡤⡴⠐${SP[1]}⣠⣴⣿⣿⣿⣿⡿⠟⠋
$G⣼⡟$GD⣸⣿⣿⠋⠁${SPR[8]}$WS⣀⣬⣶⣾⣿⣿⣿⣿⣿⣿⣿⡿⡊⢋⣉⣬⣬$WSD⡰⣿⣿⡟⠋⢁⣠⣶⣿⣿⣿⣿⣿⣿⠫⠃${SPR[8]}$WSD⣀⣤⣾⣿
${SPR[2]}$GD⠈⠉${SPR[8]}$WS⢀⣴⢇⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠏⢠⣾⣿⣿⣿⣿⣿⣎$WSD⠻⣿⣿⣿⣿⣿⣿⣿⣿⡿⠿⠇${SPR[7]}$WSD⢀⣤⣾⣿⣿⣿⢿
\x59\x4f\x55\x20\x57\x45\x52\x45\x20\x45\x58\x50\x45\x43\x54\x49\x4e\x47\x20\x4c\x45\x57\x44\x53\x2c\x20\x42\x55\x54\x20\x49\x54\x20\x57\x41\x53\x20\x4d\x45\x2c\x20\x44\x49\x4f\x21
EOM

    _draw_formatted "$surprise"
}


# Animation
# =========

# get current row-index of cursor
function _get_cursor_row () {
    echo -en "\033[6n" # send the control sequence to query cursor position
    read -sdR CURPOS # read cursor position from input buffer

    # Extract the row number from the cursor position
    echo "$CURPOS" | sed -rn 's/^.*\[(.*)\;.*$/\1/p'
}


# wait <arg 1> seconds, print a dot for each second passed.
function _wait_n_seconds () {
    printf "Waiting $1 seconds"
    local i
    for ((i=0; i<$1; i++))
    do
        printf "."  # Print a dot and flush the output to ensure that it is printed immediately
        sleep 1
    done

    printf "\n" # Print a newline after the dots
}


# Provide command as args; it'll run async, while ascii animations would play until the command's thread closes.
# Example: _spinning_wait_for_task sleep 10
function _spinning_wait_for_task () {
    local cmd=("$@")
    "${cmd[@]}" &  # Run the command in the background
    local pid=$!  # Get the PID of the background process
    local chars=('\' '|' '/' '-')
    local i_char=0
    while [ -d /proc/"$pid" ]; do
        i_char=$(( (i_char+1) % 4 ))
        tput cuu1  # go up 1 line
        printf "\r%s Running: %s\n" "${chars[$i_char]}" "${cmd[*]}"  # drops 1 line in case this is the last iteration - let the waited process print in a new line.
        sleep 0.15
    done
}

# short "LET'S GO" animation. -v : verbose (debugging)
function animate_lets_go () {
    # Define the animation frames as an array of strings
    local frame1="
⠀⢀⣤⡤⣄⠀
⣴⢿⢿⢳⢛⠂
⠿⣘⢱⣦⡤⠃
⣦⣿⡏⠉⢢⠀
⠈⣷⣞⣟⡅⠀
"
    local frame2="
⠀⣠⣴⠖⣦⠀
⣾⢻⠻⠻⠩⡁
⠻⣮⣸⣿⠶⠁
⣶⣟⠀⢀⣵⣦
⠛⠁⠉⠁⠙⠁
"

    local banner="
    ####      *########  ##########  ##  #######*      #########   ,####n###  
   ,###       ##r          a##     ##n ###/         ,####         ####    ###)
   ###       #######(     ###         /#####,      ,###/  o####  ####     ####
  ##b       *###         ###             d####     ####    *### .###,    #### 
 ######### ,########    ###          #######/      #####_####/   ####_#####   
"

    # there are spaces here, in case your IDE doesn't show you that easily

    # draw runner "spreading" the banner by having it revealed behind him, than runner "disappears" into an invisible wall
    # how it's done:
    # runner is "pushed" by an ever-extending banner from 1 to full length
    # once banner is full length, runner is "pushed" by an extra invisible window of spaces
    # the invisible wall appears after the [full width of the banner + invisible window] , so that the window would keep pushing the runner past it 

    # ----------- Define sprites, and terminal limits -----------
    local is_verbose
    [[ "$@" =~ ^"-v"$ ]] && is_verbose='true'

    local terminal_width=$(tput cols)
    local terminal_height=$(tput lines)
    local banner_width=$(sed -n '2p' <<< "$banner" | wc -c)  # width of banner, going by 2nd line
    local runner_width=$(sed -n '2p' <<< "$frame1" | wc -c)  # width of runner, going by 2nd line of the first frame
    local sprite_height=$(($(echo "$banner" | wc -l)-1))  # same for all sprites involved

    local runner_frames=("$frame1" "$frame2")
    local runner_frames_count="${#runner_frames[@]}"

    # check that the screen is wide enough
    local necessary_terminal_width=$((banner_width + runner_width))
    if ((necessary_terminal_width > terminal_width)); then errcho "Cancelled animation-playing; your terminal needs to be wider." ; return 1 ; fi
    # check that the screen is high enough
    local necessary_terminal_height=$sprite_height
    if ((necessary_terminal_height > terminal_height)); then errcho "Cancelled animation-playing; your terminal needs to be taller." ; return 1 ; fi
    # make sure that there's vertical space for the ascii animation
    if [ -n "$is_verbose" ]; then
        clear  # make more room for the extra prints
    else
        # make the necessary room needed for the animation
        local el
        for ((el=1; el<=$necessary_terminal_height; el++)); do echo ; done  # put new lines below
        tput cuu $necessary_terminal_height  # go back up, to make future use of added lines
    fi


    # ----------- Define iteration variables -----------
    local progress_speed=3  # positions moved in each iteration (minimum 1)
    local total_run=$terminal_width  # $(( banner_width + window_width ))  # the total run distance (not drawing beyond that). Runner starts fading at $((total_run - runner_width))
    local iter_time=0.035  # iteration time in seconds
    local min_key_input_time=0.003  # minimum time to listen to user input

    local exit_key  # save the pressed key that stopped the animation

    # ----------- Animation iteration -----------
   
    echo -ne "\033[s"  # Save cursor position

    # arg 1: n (width to reveal) , arg 2: text-block to partially reveal
    function _reveal_first_n_cols () {
        [ "$1" -le 0 ] && return  # negative or 0 width wanted. Return nothing.
        local max_width=$(sed -n '2p' <<< "$2" | wc -c)  # width of sprite, going by 2nd line
        
        if [ "$1" -lt "$max_width" ]; then echo "$2" | awk '{print substr($0, 1, n)}' n=$1;  # partially reveal the text
        else echo "$2";  # revealing-width is too big, just echo back everything
        fi
    }

    # d is total distance progressed
    local d runner_i
    for ((d=1, runner_i=0; d<=$total_run; d+="$progress_speed" , runner_i++ , runner_i%=runner_frames_count)); do
        local time_start=$(date +%s.%N)

        local window_dist=$((d - banner_width))  # extra distance of runner past banner, minimum is 0 (starts counting up once banner is full)
        local runner_width_still_visible=$((total_run - d))  # how much of the runner gets drawn (drawn fully until reaching the wall).

        local banner_sprite=$(_reveal_first_n_cols "$d" "$banner")
        local extra_dist_sprite=$(_repeat_whitespace_rows "$sprite_height" "$window_dist")
        local cut_back_runner_sprite=$(_reveal_first_n_cols "$runner_width_still_visible" "${runner_frames[$runner_i]}")  # runner disappears into an invisible wall, by drawing less of it as it runs further away
        _side_by_side --glued --no_padding "$(gecho "$banner_sprite")" "$extra_dist_sprite" "$cut_back_runner_sprite"
        
        [ -n "$is_verbose" ] || echo -ne "\033[u"  # Restore cursor position (but not if you're debugging - you need to see each frame)

        # TODO - shorten iteration time (optimize)
        # wait for the rest of the iteration
        local time_remaining=$( echo "$time_start + $iter_time - $(date +%s.%N)" | bc )
        local key_press_wait=$(max "$time_remaining" "$min_key_input_time")
        read -t "$key_press_wait" -N 1 exit_key && break

        [ -n "$is_verbose" ] && echo "banner_width: $banner_width , runner_width: $runner_width , total_run: $total_run"
        [ -n "$is_verbose" ] && echo "iteration took $( echo "$(date +%s.%N) - $time_start" | bc )'s , key_press_wait: ${key_press_wait}s , distance-window width: $window_dist , distance ran: $d , distance remaining: $runner_width_still_visible"
        
    done

    # dim the banner (and progress the cursor) by pasting over it at-once
    echo -ne "\033[u"  # Restore cursor position
    local banner_final=$(dagecho "$banner")  # recolored banner
    local space_window_final=$( _repeat_whitespace_rows "$sprite_height" $(($total_run - $banner_width)) )
    _side_by_side "$banner_final" "$space_window_final"
    if [ -z "$exit_key" ]; then  # if the user didn't terminate manually; there's time to do more animations
        # draw over again
        echo -ne "\033[u"  # Restore cursor position
        local erase_final=$( _repeat_whitespace_rows "$sprite_height" "$total_run" )  # TODO - replace with the ascii title of tmux window, if provided
        echo -e "$erase_final" | pv -qL 200  # erase line by line
        echo -ne "\033[u"  # Restore cursor position  # TODO - make this conditional; only if used only whitespaces (deleted the banner), go back.
    fi

}



## Finishing touches (parsing this file and announcing that we're done to user)
#################################################################################

if [ "$IS_FIRST_SOURCING" = true ]; then
    # create CUSTOM_ALIASES_MAP and CUSTOM_FUNCTIONS_MAP
    CUSTOM_ALIASES="$(_unique_in_first "$(_alias_names)" "$CUSTOM_ALIASES_INITIAL")" # keep list of (only) aliases that were added between now and the start of the file
    eval $(_hashmap_this_var 'CUSTOM_ALIASES')  # create hashmap: CUSTOM_FUNCTIONS_MAP
    CUSTOM_FUNCTIONS="$(_unique_in_first "$(_function_names)" "$CUSTOM_FUNCTIONS_INITIAL")"  # keep list of (only) functions that were added between now and the start of the file
    eval $(_hashmap_this_var 'CUSTOM_FUNCTIONS')  # create hashmap: CUSTOM_FUNCTIONS_MAP

    # source commands that call scripts in other languages
    [ -f "$SCRIPTS_BASHRC_FILE" ] && source "$SCRIPTS_BASHRC_FILE"  # if the file for it exists, source bashrc functions that bring over to the terminal various external scripts
fi

if [[ $EUID -ne 0 ]]; then   # don't output messages if user is root (sudo running)
    echo "$(gecho "Finished loading") \"$CUSTOM_BASHRC_FILE\" for: \"`readlink -f $0`\". To view added commands, run: $(becho remindme)"  # announce done
    [ -f "$TESTS_FILE" ] && source "$TESTS_FILE"  # run the tests file if it exists and we're not in sudo mode
fi

#  TODO - put as a top pane in tmux window. Needs to be in a different pane because I can't find a way to make it play without interrupting key input or disrupting it and keeping the first char in the input.
# if running in a visible terminal, and not as root
# if [ -t 1 ] && [ "$IS_USER_ROOT" = false ]; then  
#    animate_lets_go
# fi


