#!/bin/bash

# This file calls script files in another location (relative to own location) in definitions that makes them accessible as terminal commands

SCRIPTS_PATH="$CUSTOM_BASHRC_FOLDER/unlimited_script_works"  # name of the scripts folder within this project. Change it if you want, just be aware this could break.

# TODO - remove? Consider if useful. Entire removal requires deletion of related file.
# alias _scripts_loaded_comfirmation='_py_confirm_loaded'  # a call to a script added in just to confirm that the rest of the scripts are reached right 

# Reloads script-files into bash-calls. No need to manually call this, it's done automatically
# --declare_commands (create aliases/functions to call scripts) , --output_commands (list found files and their appropriate calls)


# get command name that runs the script/program-file ; arg1: the file (or main file)
function get_cmd_name () {
    local filename="$(basename "$scr_file")"
    local extension=$([[ "$filename" = *.* ]] && echo "${filename##*.}" || echo 'generic' )  # gets file-type, or default if there's no dot.
    echo "$extension ${filename%.*}" | awk '{ print (substr($2,1,1) == "_") ? "_"$1$2 : $1"_"$2 }'  # keep the file name but not the ending suffix. use ext as prefix, and make sure it's separated from the filename and that it keeps the leading "_" if it exists
 }

function _reload_scriptfiles () {
    local scr_file
    while IFS= read -r scr_file; do
        eval "function $(get_cmd_name "$scr_file") () { "$scr_file" \"\$@\"; }"
    done <<< "$(find "$SCRIPTS_PATH" -type f)" 
}
_reload_scriptfiles


# used by "remindme" - lists this file's introduced aliases and functions
function _list_script_calls () {
    echo '# ---------- EXTERNAL (sourced non-bash) ----------'
    
    local scr_file
    while IFS= read -r scr_file; do
        local documentation="$(
            if [[ "$scr_file" == *.py ]]; then  sed -n '/"""/, /"""/{ /"""/! { /"""/! {p; q}}}' "$scr_file";  # get the documentation between 2 """ strings
            else  grep -n -m 1 -v '^#' "$scr_file" | cut -d ':' -f 1 | head -n $(($(cat) - 1)) "$scr_file";  # default (no extension) - get consecutive comments starting with '#' from top of file
            fi
        )"
        # unify multiple lines and sanitize
        [ -n "$documentation" ] && documentation="$( echo "$documentation" | paste -s -d ' ' | sed 's/^#[[:space:]]*//' )"
        echo "$(get_cmd_name "$scr_file")  # $documentation"
    done <<< "$(find "$SCRIPTS_PATH" -type f)" 
}


