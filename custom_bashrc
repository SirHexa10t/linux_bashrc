#!/bin/bash


#---------------------------------------------------------------------------------------------
#----CUSTOM-----------------------------------------------------------------------------------
#---------------------------------------------------------------------------------------------


# Add everything here (see note below) to own user's .bashrc file (or in /etc/bash.bashrc if you want it to be global)
# Then reset your terminal or source (shortcut: .) the relevant .bashrc file:
#   . /etc/bash.bashrc
#   . ~/.bashrc

# (note) It's more modular (and arguably easier) to just save this file somewhere and refer to it from bashrc.
# To do that, just paste the following 2 lines (uncommented) at the end of your bashrc. Make sure the filename's correct of-course.
#   CUSTOM_BASHRC_FILE="$HOME/custom_bashrc"
#   if [ -e "$CUSTOM_BASHRC_FILE" ]; then source "$CUSTOM_BASHRC_FILE"; fi

# To apply your bashrc to sudo as well, edit the file: /etc/sudoers , and put the following line in it (without the comment):
# Defaults        env_keep += "BASH_FUNC_*"


# aliases work as "command (re)placements", i.e. they'll replace words that are commands but not args


# My settings
#################################################################################
QEMU_VOLUME_UUID='A80899A4089971D4'
LOOKING_GLASS_CLIENT="/usr/local/bin/looking-glass-client"

HISTTIMEFORMAT="%Y-%m-%d %T  "  # makes "history" command display the time the command ran at

# My binds
#################################################################################
# "\C-" is CTRL, "\e" (or "\M-") is alt. Shift might not be supported, but if it is: "\S-" is Shift (and maybe also backslash and capitalize, like this for Shift-X: "\X").
# Flag -x is "execute".
# A personal rule is that things get executed instead of written explicitly only if the user shouldn't care about the command used (i.e. it always makes sense to use just the shortcut)

# before adding a bind, check whether it's already taken, by running "bind -p". You'd generally be overwriting existing binds, but some of them such as CTRL+M cause problems when you overwrite
# To define it only if the shortcut doesn't exist, run a command like this:   if ! bind -q "\C-w"; then bind '"\C-w": "exit\n"'; fi

# Bash terminal related 
# =====================

# CTRL+H : basically "help"
bind -x '"\C-h": "remindme"$\r$\n'

# ALT+N : refresh bash terminal
bind '"\en": "exec bash\n"'  # print this, so the user can rerun this easily for function tests

# CTRL+W : close terminal. Just like in web-browsers
bind '"\C-w": "exit\n"'

# CTRL+SHIFT+I : get system info
# bind -x '"\C-\I": "echo something"$\r$\n'  # TODO


# Custom environment 
# ==================

# CTRL+X : (let's pretend X is for X-Server...) arrange monitors when the nvidia settings won't keep them arranged
bind -x '"\C-x": "arrange_monitors"$\r$\n'


# My keyword shortcuts
#################################################################################

# Basic functionalitiy override !
# ===============================

# the space at the end makes bash check the next word as well
alias sudo='sudo '

# same trick as in sudo
alias man='man '

# rsync copy instead of cp - recursive by default and shows progress percentage
alias cp='rsync -ah --info=progress2'

# replace apt with nala. Same thing but prettier
alias apt='nala'


# Common
# ======

# ----- Lookups / Getting-info

# like "ll" but better - all files, newest at bottom (add -S to sort by (non-recursive) size), neat/readable. Headers:  'size(blocks), modifiers, hardlinks_count, user, group, size, date-modified, name'
alias lll='ls -tarlushFN --color=always --time-style=long-iso --group-directories-first'

# just shorter grep, case insensitive (i), and no regex involved (F)
alias g='grep -iF --color=auto'

# take ownership of file (add file-name after this command)
alias claim='sudo chown $USER:$USER'

# grepped history
alias hg='history | grep -iF --color=auto'

# reset terminal (includs bashrc reload)
alias anew='exec bash'

# Show current network connections to the server
alias ipview="netstat -anpl | grep :80 | awk {'print \$5'} | cut -d\":\" -f1 | sort | uniq -c | sort -n | sed -e 's/^ *//' -e 's/ *\$//'"

# get own IP
alias whatsmyip="becho 'My private IPs:'; echo \"$(ip addr show | grep inet | grep -v inet6 | awk '{print $2}' | cut -d/ -f1)\" && becho 'My IPv4:' ; dig @resolver4.opendns.com myip.opendns.com +short "

# Get basic hardware and system list
alias sysinfo_short='echo "For simpler neat hardware specs, run \"neofetch\" or \"screenfetch\""; inxi -bD'

# Get comprehensive system/specs details
alias sysinfo_full='inxi -FxxzJy90'

# TODO - merge df -i with lsblk to get inodes
# join <(df -h | tail -n+2 | sort -k1,1) <(lsblk -o PATH,SIZE,TYPE | tail -n+2 | sort -k1,1) -1 1 -2 1
# join <(df -h | tail -n+2 | sort -k1,1) <(lsblk -o PATH,SIZE,TYPE | tail -n+2 | sort -k1,1) -1 1 -2 1 | awk '{print $1, $3, $4, $6}'


# Service/Application handling
# ============================

# run docker desktop
alias run_docker_desktop='systemctl --user start docker-desktop'

# TODO - define "sudocker" - run docker desktop as sudo so that it'll find all containers


# System management
# =================

# upgrade your system.
alias updatengrade='sudo apt update && sudo apt-get full-upgrade -y && sudo apt-get autoremove -y'

# rebuild boot parameters using GRUB
alias rebuild_boot='sudo update-grub'

# rebuild RAMFS to apply changes like in modprobe (blacklisting services)
alias rebuild_ramfs='sudo update-initramfs -u'


# Cheatsheets
# =================

# TODO - command grep. "command_like <expression>"

# One of several "help"/"manual" kind of reminders, to help the user get such info without opening the bashrc files.
alias remindme='echo "Find various cheatsheets by typing commands that start with \"howdoi\" or list bashrc options with command \"list_cmds\""'
# Synonymous to "remindme", one of several.
alias what_commands='remindme'
# Synonymous to "remindme", one of several. P.S. it's mispelled intentionally; in case you don't get it.
alias i_forgor='remindme'

# Reminders for linux system tools and command options
alias howdoi_linux='echo "
>> Packages
* sudo apt install/remove/purge <package>  # package install/remove/remove-including-configs
* sudo gdebi -n <package.deb>  # probably the best way there is to install a .deb file (the -n is for \"no prompt\")
* sudo dpkg -r <package>  # remove a package installed from a .deb file
* sudo dpkg --purge <package>  # purge a package installed from a .deb file
* dpkg-query --list <package>  # print info related to installed package (autocompletes the name), works for all installations including from .deb
* apt list  # list all packages in followed repositories
*   apt list --installed  # list installed packages
*   dpkg -l  # show all installed packages in table format
>> Messing around with the system itself
* reboot  # reboots the system (gracefully)
* sudo systemctl start sshd  # start ssh service for external access
* udisksctl mount --block-device=/dev/<device-name>  # Mount a device the way nemo would. No need for mkdir (and nemo can dismount it right), no harm in calling while unnecessary, automatically uses LABEL to mount at /media/<username>/
*   udisksctl mount --block-device=/dev/<device-name> 2> /dev/null
>> configurations
* config-file: /etc/default/grub  :  boot configurations
* config-file: /etc/modprobe.d/blacklist.conf  :  blacklist modules, such as firmware
* visudo  # edit the /etc/sudoers file (only if you know what you are doing)
* crontab -e  # edit routine-scheduled tasks
>> Some nice tools/commands you could need often
* tmux  # terminal session/pane-manager - see more in the tmux cheatsheet
* wget <url>  # download files
* curl  :  communicate through HTTP(S)/(S)FTP/SCP - make any request (but if you just want to download something, you should probably use wget)
* netstat  # get network related info (such as port usage and active connections)
* sudo nvidia-xconfig  # create new xorg config, used by nvidia driver
>> logs (to tail a logfile in real-time run: \"tail -f <logfile>\", or to get last 100 lines: \"tail -100 <logfile>\" )
* log-file: /var/log/boot.log  :  System boot log
* log-file: /var/log/dmesg  :  log for kernel ring buffer
*   dmesg -k | grep -E \"warn|error\"  # the command dmesg displays kernel logs buffer
* log-file: /var/log/kern.log  :  log for kernel ring buffer
"'

#TODO - add a 1-line add-user command (with no prompts needed), with/without superuser privileges
# Reminders for user/groups management
alias howdoi_users='echo "
* groups <username>  # display the groups of a user
* usermod -aG <groupA,groupB,groupC> <username>  # add user to group(s). You can even add to group sudo.
* getent group  # list all groups and their user-members
"'

# Reminders for the basic gimmicks of bash
alias howdoi_bash_terminal='echo "
* man <command>  # read the manual of the command
* help  # list built-in Bash commands
* sudo !!  # rerun last command with sudo permissions
* add \"& disown\" after a command to have it run in its own thread so that it wont stop when the terminal closes
* add \"2> /dev/null\" after a command to throw away warning/error messages it might bring up
"'

# Reminders for the basic gimmicks of bash
alias howdoi_bash_terminal_tools='echo "
* htop  # show real-time processes/resource-usage
* diff <file1> <file2>  # get the text difference between 2 files
"'

# common media file operations
alias howdoi_media_and_docs='echo "
* pdftk <file1> <file2> <file3> cat output <merged_name.pdf>  # create a unified pdf file 
* xournal <pdf_filepath>  # edit a pdf file with option to add signatures
* ffmpeg -i <input.mp4> -c copy -an <output.mp4>  # get a video copy without the audio
"'

# Reminders for microsoft-format handling tools
alias howdoi_microsoft='echo "
* lnkinfo <lnk-file>  # display link info
* dos2unix <file>  # convert files from windows to unix encoding
* sudo ntfsfix <device> -v  # run check-disk on NTFS device
* ldmtool  #  Read dynamic disks by running \"sudo ldmtool create all\", and then mounting with \"mount -t ntfs /dev/mapper/<volume_name>\"
"'

# Reminders for android-related tools
alias howdoi_android='echo "
* scrcpy  # run daemon that casts the connected Android device screen onto a window, and shares the clicks within it back to the Android device
* scrcpy -r <filename.mp4>  # save a video recording of your connected android device activity (needs USB-Debug and File-Transfer mode)
"'

# Reminders for vm tools and command options (mostly stuff you can't do through Virtual Machine Manager)
alias howdoi_vm='echo "
* systemctl restart libvirtd  # restart the libvirt daemon vm-manager
* virsh start <name>  # start VM
* virsh domrename <old_name> <new_name>  # rename vm
* virsh edit <name>  # modify the xml of a VM (you can do that in Virtual Machine Manager instead)
* sudo virt-sparsify --in-place -v <diskimg.qcow2>  # compress vm disk file
* virsh list --all  # show VM list
* virsh snapshot-create-as --domain <VM-NAME> --name <SNAPSHOT-NAME>  # create snapshot for a vm (has to be turned off)
* virsh snapshot-list --domain <VM-NAME>  # list snapshots of vm
* virsh snapshot-info/snapshot-revert/snapshot-delete --domain <VM-NAME> --snapshotname <SNAPSHOT-NAME>  # detail/go_back_to/delete snapshot
* qemu-img create -f qcow2 -F qcow2 -b <path_to_src_disk.qcow2> <path_to_output_disk.qcow2>  # snapshot a single disk
"'

# Reminders for docker
alias howdoi_docker='echo "
>> view (might need to run sudo to find all)
* docker ps -a  # list ALL containers
* docker images -a  # list all images
* docker volume ls  # list all volumes
* sudo docker inspect <container_name_or_id>  # view container details 
>> managing container states
* docker-compose -f <yml_file> up  # Start a conteiner using a yaml/yml file. Use -d to make it run in the background
>> removal
* docker system prune -a  # remove all images/containers/volumes/networks. The flag -a also remove unused images
* docker rmi <image(s)>  # remove images ; to remove all images:   docker rmi $(docker images -a -q)
* docker rm <container_id(s)_or_name(s)>  # remove container(s) ; to force-remofe, add -f ; to remove all stopped containers:   docker rm $(docker ps -a -f status=exited -f status=created -q)
* docker volume rm <volume_name(s)>  # remove volume(s)
* docker run --rm <image_name>  # run an image and remove its container when it exits
"'

# Reminders for docker
alias howdoi_network='echo "
>> Own network info
* ip addr  # display own networking interfaces
* sudo netstat -tulpn  # display active network connections and filter by port number
>> Seeking addresses
* dig \"amazon.com\" +short  # resolve dns address (or addresses, in case content-distribution-networks are involved)
* ping google.com  # ping address
>> Firewall and incoming requests
* UFW config-file: /etc/ufw/ufw.conf  :  to monitor incoming requests, set in it: LOGLEVEL=debug , then run \"sudo ufw reload\" (no-interruption reset; if it wont work run: \"sudo service ufw restart\"), and then \"sudo tail -f /var/log/ufw.log\" to monitor
* ufw allow 21115:21119/tcp  # change firewall rules (by ports or src address) - in this case, allow ports 21115 to 21119 (including) on tcp
* sudo tcpdump -i any -n  # capture traffic on all networks for all ports
* sudo tcpdump -i [interface] -n \"src host [external_IP] and dst port [dst_port]\"  # detailed monitoring
*   detailed monitoring example 1:  sudo tcpdump -i enp5s0 -n \"dst port 21118\"
*   detailed monitoring example 2:  sudo tcpdump -i any -n \"tcp and (dst port 21115 or dst port 21116 or dst port 21117 or dst port 21118 or dst port 21119)\"
*   detailed monitoring example 3:  sudo tcpdump -i any src 46.120.97.16 -nn -c 20  # -nn shows ip addresses and port-num without resolving hostname, -c stops capturing after 20 packets
"'



# Reminders for the basics of systemd
alias howdoi_systemd='echo "
* /etc/systemd/system/  :   add/remove .service files here
* sudo systemctl daemon-reload  # rescan and reload service files
* sudo systemctl <start/stop/restart/status> <myservice>.service  # manage the state of the service or check its running-status
* sudo systemctl <enable/disable> example.service  # allow/disallow service to run after boot
* journalctl -u <service_name.service>  # check the logs of a systemd service. Can also specify how to view them; example:   journalctl -u ssh --since \"1 hour ago\" --until now -f
"'


# Reminders for the basic gimmicks of tmux terminal
alias howdoi_tmux='echo "tmux offers split-panes and sessions for terminals.
>> Good for managing a server:
+tmux terminals persist even after disconnection. They keep running until restart the server or send a closure command.
+tmux windows can be named, listed and looked up.
+tmux can accomodate multiple users on the same terminal simultanously; good for assistance/collaboration and for doing jobs that need a \"lock\" (having a channel where certain jobs run, so people would know if someone elses job is underway and should be allowed to finish first)
>> Quick explanation: tmux has sessions. Each session can have various windows, each window (has a number and name) is a \"screen\" thats visible at the moment and has vertically/horizontally added panes 
+For simplicity you can just have a SINGLE SESSION and manage all your windows there. Its easier to navigate windows, thanks to the green bar listing them at the bottom.
+If a window has only need for a SINGLE TERMINAL (lets say the window is called \"grub_config\"), you can keep it simple and avoid adding extra panes. Add panes to multi-faceted things, like a project which has code, git-management, assets, runtime area etc.
> Sessions:
* tmux  # create a new tmux session
* CTRL+B, D  : leave (detach) current session
* tmux ls  # view all existing tmux sessions (+ info about creation date and number of windows)
* tmux rename-session -t <0/1/2/3/.../past_name> <name>  # rename session (using number/name from \"tmux ls\")
* tmux attach -t <0/1/2/3/.../name>  # connect (attach) to an existing tmux session (using number/name from \"tmux ls\")
* tmux kill-session -t <0/1/2/3/.../name>  # kill specified session
> Windows:
* CTRL+B, <0/1/2/3/...>  : go to window number
* CTRL+B, C  :  create a new window
* CTRL+B, ,  :  rename current window
> Panes:
* CTRL+B, %  :  create a new pane to the right
* CTRL+B, \"  :  create a new pane to the bottom
* CTRL+B, <left/right/up/down>  :  move focus to other pane
* exit  # close pane. If last pane, close window.
TODO - create a script thatll establish tmux workspaces when logging into your user (so youd have things ready for debugging or coding and such)
TODO - create functions that run these commands interactively (like listing, then letting the user pick a number, then go there...)
"'

# Reminders for some neat time-saving GUI tricks
alias howdoi_shortcut='echo "
* Terminal CTRL+L : clear screen
* Built-in Nemo [space] :  select (click) a file/folder, and press [space] to get a summary/preview; press again to close
* Custom Gnome-Nemo CTRL+SHIT+T :  open Terminal at current Nemo location
* Built-in Gnome CTRL+ALT+T :  open Terminal
* Built-in Gnome(?) CTRL+ALT+[backspace] :  log out of current session (resets your GUI)
* Built-in Debian(?) CTRL+ALT+F1 :  enter TTY mode (terminal without anything graphic to lock/interrupt you)
* Built-in Debian(?) CTRL+ALT+F7 :  exit TTY mode
* Evded installation LCTRL+RCTRL  :  switch mouse and keyboard (and maybe other things) between guest/host. Wont work if you gave the VM your USB device directly.
"'


# function aliases (alternate names)
# ==================================


# server administration
# =====================

# list users that have password access
alias list_users="awk -F: '\$3 >= 1000 && \$1 != \"nobody\" {print \$1}' /etc/passwd"


# Custom
# ======

alias arrange_monitors='nvidia-settings --load-config-only && nvidia-settings --assign CurrentMetaMode="HDMI-0: nvidia-auto-select +1920+1080, DP-0: nvidia-auto-select +1920+0, DP-2: nvidia-auto-select +3840+1080, DP-4: 1920x1080_240 +0+1080"'


# Legacy
# ======

# # Aliases for safe and forced reboots
# alias rebootsafe='sudo shutdown -r now'
# alias rebootforce='sudo shutdown -r -n now'






# My functions
#################################################################################

# TODO - a "checksum" function that gets both file to checksum and the checksum-result file, determines which is which, runs the appropriate checksum on the file and compares with the result file; prints the match result 

# Common commands - just for the use of other functions
# =====================================================

function _sudo_if_necessary () {
    [ $# -ge 1 ] || { echo "WTF are you expecting me to sudo? Give me a command-string as argument" ; return ; }
    eval "$1" 2>/dev/null || eval "sudo $1"
}

function _count_lines () {
    echo "$1" | wc -l
}

# useful for drawings or neat concatenating of tables like so: 'paste <(_pad_end_w_spaces "$(df -h)") <(_pad_end_w_spaces "$(df -hi)") <(_pad_end_w_spaces "$(df -hi)")'
# add spaces to the end of lines so that the block of text would be a rectangle; i.e. end uniformly on the same column. Use like so:  _pad_end_w_spaces "$(lsblk)"
function _pad_end_w_spaces() {
    awk '{hi[NR]=$0; max_len=length($0) > max_len ? length($0) : max_len} END {for (line in hi) { printf "%s%*s\n", hi[line], max_len-length(hi[line]), "" }}' <<< "$1"
}

# get device name such as "/dev/sda2". You must provide one argument: the UUID of the device.
function _get_dev_name_from_uuid () {
    [ $# -ge 1 ] || { echo "You need to provide UUID as an argument" ; return ; }
    blkid | grep "UUID=\"$1\"" | awk -F: '{print $1}'
}



# adds y/n prompt. Call like this:  if prompt_yn "are you sure you want to do that?"; then echo "alright..."; else echo "then lets call it off" && return ; fi
function _prompt_yn() {   
    response=""
    # keep prompting the user until they provide a valid response
    while [ "$response" != "y" ] && [ "$response" != "n" ]; do
        # prompt the user for a yes/no response
        read -p "$1 [Y/n] " response
        case "$response" in
            y|Y ) return 0 ;;  # if the response is "y", return a boolean value indicating success
            n|N ) return 1 ;;  # if the response is "n", return a boolean value indicating failure
            *) echo "just type y or n" ;;  # if the response is anything else, print an error message and continue prompting
        esac
    done
}

# wait $1 seconds, print a dot for each second passed.
function _wait_n_seconds () {
  printf "Waiting $1 seconds"
  for ((i=0; i<$1; i++))
  do
    printf "."  # Print a dot and flush the output to ensure that it is printed immediately
    sleep 1
  done
  
  printf "\n" # Print a newline after the dots
}





# Basic functionalities override !
# ================================

# TODO - do about the same for chmod and chown - print the directory while grepping the specified file
# add a print of local files after changing directory
function cd () {
    builtin cd "$@" && \
        ls -AF --color=always --group-directories-first 
}

# make mkdir more "reasonable" with a flag that is always nice to have
function mkdir () {
    [[ $* == *-p* ]] && extra_flag="" || extra_flag="-p"  # if flag not present, store it in var 
    /usr/bin/mkdir "$extra_flag" "$@"
}


# Maintenance and Update Operations
# =================================

function install_deb_from_url () {
    pkg_name=$(echo "$1" | awk -F/ '{print $NF}')  # get the string after last '/'
    installation_msg="Installed debian (.deb) package: $pkg_name. If you want to remove it, run: 'sudo dpkg -r $pkg_name'"
    wget "$1" && sudo gdebi -n "./$pkg_name" && echo "$installation_msg"  # download and install
    rm "$pkg_name"  # remove .deb file
}

function add_to_path () {
    # check if given arg is already in PATH
    if [[ $PATH == *$1* ]]; then
        echo "$1 is already in PATH!"
        return
    fi
    export PATH=$PATH:$1
	# change the line where "PATH=" appears
    sudo sed -i "/PATH=/c\PATH=$PATH" /etc/environment
    printf "From now on:\n`sudo cat /etc/environment`\n"
}

# don't worry about calling this when the device is already mounted, it won't do harm.
function mount_media_by_uuid () {
    device="$( _get_dev_name_from_uuid $@ )"
    udisksctl mount --block-device="$device"
}

function all_crontabs () {
    cat /etc/passwd | awk -F: '{ print $1; }' \
    | while read user; do
            crontab -u $user -l 2>/dev/null | grep "^[^#*/;]" | awk '{
                    print "'$user': "$0;
            }';
    done
    
    sudo crontab -u root -l 2>/dev/null | grep "^[^#*/;]" | awk '{ print "root: "$0; }';

}


# finds files that shouldnt be executable and chmods them
function revoke_exe_mod () {
    location=${1:-.}  # use given address, default to current location
    format=${2:-'txt'}  # use given format, default to txt
    files=$(find "$location" -type f -name "*.$format")  # get txt (or specified) files recursively
    while read -r file; do
        # if file is executable
        if [ -x "$file" ]; then
            # revoke exe permission (run as sudo IF necessary)
            _sudo_if_necessary "chmod -x \"$file\"" && echo "file no longer executable: $file"
        fi
    done <<< "$files"
}


# ----- Microsoft handling 

# fix mount as read-only issue caused by Windows leaving some garbage on the disk
function prepare_ntfs_for_writable_mount () {
    lsblk -o UUID,NAME,FSTYPE,LABEL | awk 'NR==1 || $3 == "ntfs"'

    read -p "Choose a UUID to fix (with chkdsk) from the above device-list: " uuid  # Read the user's input
    
    lsblk -o UUID,NAME,FSTYPE,LABEL | awk -v uuid="$uuid" 'NR==1 || $1 == uuid'
    if _prompt_yn "Are you sure this is the right device?"; then echo "Running. Don't touch the device until we're done..."; else echo "Quitting." && return ; fi

    # unmount if necessary
    if findmnt -o UUID | grep "$uuid" > /dev/null; then umount -l "/dev/disk/by-uuid/${uuid}"; fi

    # fix ntfs device
    sudo ntfsfix -b "/dev/disk/by-uuid/$uuid"
}


# TODO
# function reinstall() { : 'performs remove and then install'
#     if [] then;
#     sudo apt remove "$1" -y && sudo apt install "$1" -y
#     fi
#     else
#     echo "package $1 isn't even installed"
# }


# Debug and Check Operations
# ==========================

# Writes data to volume, to check its capacity. Careful not to give this function the wrong path!!!
function check_drive_volume () {
    if [ -z "$1" ]; then echo "You didn't provide a drive-name (run lsblk if you're not sure. Should be like '/dev/sdg' ). Aborting." && return 1 ; fi
    
    # TODO - use local function for y/n
    read -p "Your data on $1 is about to be destroyed. Are you sure? (y/n)?" choice
    case "$choice" in 
        y|Y ) echo "yes. starting...";;
        n|N ) echo "no... aborting." && return 1;;
        * ) echo "just type y or n";;
    esac
    sudo f3probe --destructive --time-ops "$1"
}



# Info: Stats
# ===========

# get comprehensive overview of devices/volumes
function devs() {
    # df results (mounted volumes)
    df_results=$(df -h -x tmpfs --output=source,fstype,itotal,ipcent,size,pcent,file,target)
    df_title=$(echo "$df_results" | head -n1)
    df_content=$(echo "$df_results" | tail -n+2 | sort -k1,1)
    df_results=$(echo -e "${df_title}\n${df_content}")  # reattaching (now the contents are sorted)

    # device names (used as identifiers)
    df_devices=$(echo "$df_content" | awk 'NR>1 {print $1}')
    lsblk_devices=$(lsblk -o PATH | tail -n+2 | sort)

    # lsblk minus df results
    # ----------------------
    unmounted_devices=$(comm -23 <(echo "$lsblk_devices") <(echo "$df_devices"))  # devices in lsblk but not df
    lsblk_unmounted=$(lsblk -d $(paste -sd ' ' <<< "$unmounted_devices") -o PATH,MODE,FSTYPE,SIZE,LABEL,TYPE,PTTYPE,MODEL,STATE --sort PATH) 
    
    # df results + extra data for same entries
    # ----------------------------------------
    lsblk_complementary_to_df=$(lsblk -d $(paste -sd ' ' <<< "$df_devices") -o MODE,LABEL,TYPE,PTTYPE,MODEL,STATE,PATH --sort PATH)  # same devices as in df, different columns
    # map the extra data in lsblk to "PATH", which is the same as lsblk's "Filesystem"
    declare -A lsblk_hashmap
    while read -r line; do
        key="${line##* }"
        value="${line% *}"
        lsblk_hashmap["$key"]="$value"
    done <<< "$lsblk_complementary_to_df"
    lsblk_hashmap['Filesystem']=${lsblk_hashmap['PATH']}
    
    # place the maps right after the df results
    df_results=$(_pad_end_w_spaces "$df_results")  # prepare to add the extra columns by making the lines end at the same char-column
    df_and_lsblk=()
    while IFS= read -r line || [[ -n "$line" ]]; do
        dev_name=$(echo $line | awk '{print $1}')
        modified_line="$line ${lsblk_hashmap[$dev_name]}"
        df_and_lsblk+=("$modified_line")
    done <<< "$df_results"
    
    
    # print results
    becho 'mounted volumes:'  # results from df with extra details on the same entries from lsblk
    for i in "${df_and_lsblk[@]}"; do echo "$i" ; done

    becho 'non-mounted volumes:'
    echo "$lsblk_unmounted"

    becho 'identifiers and metadata:'
    lsblk -a -o NAME,MOUNTPOINT,LABEL,UUID,PTUUID,PARTUUID,SERIAL | awk 'NR==1 || ($1 !~ "loop[0-9]")'
}


# TODO - check / refactor
# get a list of users and their resource-usage stats
function all_active_users () {
    #!/bin/bash
    cpu_count=$(lscpu | grep "^CPU(s):" | awk '{print4s 
     $2}')
    printf "# CPUs count(threads, not cores): $cpu_count \n"
    printf "# Possibly bottlenecking on a single thread when a user's CPU reaches %0.3f %% \n" $((100/"$cpu_count"))
    printf "\t\tUSER\t%%_CPU_USED\t%%_RAM_USED\n"
    ps axo user:20,pid,pcpu,pmem | awk '
        {cpuarr[$1]+=$3 ; memarr[$1]+=$4} 
        # get all users CPU and RAM
        END {for (i in memarr) print i, cpuarr[i], memarr[i]}' | sort -k2 -nr \
        | while read name cpu ram shell rest ; do
            if [ -d "/home/$name" ]; then   # only keep  "human" users
                 printf "\r%20s \t%4f \t%10f\n" $name $cpu $ram
            fi
        done
}


function network_search () {
    if [ -z "$1" ]; then echo "You didn't provide anything to filter by. Aborting." && return 1 ; fi
    
    if [[ $1 =~ ^[0-9]+$ ]]; then  # numerical - filter as a port number
        sudo netstat -tulpn | grep ":$1"
    else  # non-numerical, look-up as a substring
        sudo netstat | grep "$1"
    fi
}

# Reports all local files size and inner-files count. Sortable by size with "-s"
function explore () {
    location=${1:-.}  # use given address, default to current location
    location=$(readlink -f "$location")  # use absolute path (and use no '/' at the end)

    folders=""
    files=""
    total_files=0  # Files (recursive) counter. Can technically just recount current dir, but the results might not be cached

    filenames=$(find "$location" -maxdepth 1 -type f,d,l)  # get files (files, dirs, links) in given dir
    filenames=$(echo "$filenames" | grep -vw "^$location$")  # throw out the given location (exact match from line start to end)

    [ -z "${filenames}" ] && return 1  # nothing to iterate over

    while IFS= read -r filename; do
        size=$(du -sh "$filename" | cut -f1)  # determine size (same command for files/folders)
        inodes=$(du -s --inodes "$filename" | cut -f1)
        count=$(find "$filename" -type f,l | wc -l)  # count files and links found. It's just '1' for a file, but the code's shorter this way
        total_files=$(($total_files + $count))

        # handle as dir or file
        if [ -d "$filename" ]; then folders+="$size\t$count\t$inodes\t$filename/\n";
        else files+="$size\t$count\t$inodes\t$filename\n";
        fi
    done <<< "$filenames"

    headers=$(becho "total_size\tfile_count\tinodes\tname")
    data="${folders[@]}${files[@]}"    
    [[ " $* " =~ " -s " ]] && data=$(echo -e "${data}" | sort -h)  # if flag -s specified, sort ; first datum is size, so that's what we sort by
    echo -e "${headers}\n${data}" | column -t -s $'\t'  # separate nicely with tabs
    echo "current dir total files: $total_files"
    echo "current dir total size: $(du -sh "$location" | cut -f1)"
    echo "current dir inodes use: $(du -s --inodes "$location" | cut -f1)"
}


# Info: Lookup
# ============

# case-insensitive lookup on all files in dir (and subdirs). -d: dir (default is ".") , -e: expression , --allow_text_dumps (optional). or just put <expression> to look locally
function supergrep () {
    [ $# -ge 1 ] || { echo "You must provide at least one argument, for the lookup-expression" ; return ; }
    # we have a text-length limit to skip gibbrish and text-dumps. It's allowed over 4k, since that's the minimum file-path length.
    text_limit_default='5000'
    first_free_arg_is_exp=''
    dir='.' ; exp=''; text_limit="$text_limit_default"; verbose=''  # defaults, and clearing (in case they're set)
    while [[ $# -gt 0 ]]; do
    	case "$1" in
    		'-d'|'--directory')
    			dir="$2"
    			shift 2
    			continue
    		;;
    		'-e'|'--expression')
    			exp="$2"
    			shift 2
    			continue
            ;;
            '-t'|'--text_limit')
                text_limit="$2"
                shift 2
                continue
            ;;
            '-s'|'--text_limit_short')
                text_limit="500"
                shift
                continue
            ;;
            '-m'|'--text_limit_medium')
                text_limit="5000"
                shift
                continue
            ;;
            '-u'|'--text_limit_unlimited')
                text_limit="-1"
                shift
                continue
            ;;
            '-v'|'--verbose')
                verbose='true'
                shift
                continue
            ;;
            '--help')
                echo -e "bashrc function \"${FUNCNAME[0]}\"
Summary: Grep all files and filenames at a location, recursively. Case-insensitive.
example: supergrep 'to do'
example2: supergrep -d /etc/systemd/ -e restart -v -u 
args:
    -d|--directory <dir_path>\t set the search-dir
    -e|--expression <exp>\t set the search term. You can also set it without a flag
    -t|--text_limit <number>\t set the lext-length limit of lines found. Default is $text_limit_default
        -s|--text_limit_short\t set the lext-length limit of lines found to 500. Equivalent to: -t 500
        -m|--text_limit_medium\t set the lext-length limit of lines found to 5000. Equivalent to: -t 5000
        -u|--text_limit_unlimited\t do not set lext-length limit of lines found. Equivalent to: -t -1
    -v|--verbose\t run in debug mode
    --help\t print this message
"
                return
            ;;
    		*)
                if [ -z "$first_arg_used_as_exp" ]; then
                    first_free_arg_is_exp='true'
                    exp=$1
                else
                    echo "I don't know how to handle $1"
                fi
    			shift
    		;;
    	esac
    done

    [ -z "$exp" ] && echo "No expression specified. Use -e <expression> to set it." && return 1
    
    [ -n "$verbose" ] && becho "running on directory: $dir  ;  expression: $exp  ;  including strings up to length: $text_limit"  # print found arguments (if verbose)

    recolor_grep="grep -iF --color=always \"$exp\""  # appent this grep just to color the output... Sorry, I'm bad at bash T_T

    becho "matching filenames:"
    becho "==================="
    _sudo_if_necessary "find \"$dir\" -iname \"*$exp*\"" | eval "$recolor_grep"

    becho "matching file contents:"
    becho "======================="
    all_results=$(_sudo_if_necessary "grep -e \"$exp\" -Inir \"$dir\" --color=never")  # No colors. Coloring is done at this stage because otherwise it'll add to the string's length
    #TODO - simplify. Save results, if-awk, echo with eval recolor
    if [ $(expr "$text_limit" + 0) -gt 0 ]; then
        [ -n "$verbose" ] && becho "filtering with maximum result length: $text_limit" 
        echo "$all_results" | awk "length(\$0) <= $text_limit" | eval "$recolor_grep"
    else
        echo "$all_results" | eval "$recolor_grep"  # print with no filtering by length
    fi
}



# Interactive launchers/creators
# ==============================

#TODO - offer to choose a vm by number [1-n]. Need to create a function like y_n one that gets a dicitonary as an argument 
function launch_vm_w_lookingglass() {
    valid=0
    while [ $valid -eq 0 ]
    do
        vm_names=$(virsh list --all --name)
        becho "Choose the name of the VM you want to launch:"
        virsh list --all
        becho "============================================"

        read -p "Enter the name of the VM: " vm_name  # Read the user's input
        if echo $(virsh list --all --name) | grep -w -q "$vm_name"; then  # match whole word (case sensitive), quietly
            valid=1
        else
            recho "Invalid VM name"
        fi
    done

    # look up info within the vm's definitions file
    xml_file="/etc/libvirt/qemu/${vm_name}.xml"

    # get the shmem name:
    shmem_name=$(sudo awk -F 'name=' '/shmem/ {gsub("'\''", "", $2); print $2}' "$xml_file" | sed 's/^"\([^"]*\)".*/\1/' | sed 's/>$//')  # extract the string between the quotes, remove the quotes, remove the closing '>'
    lg_file="/dev/shm/$shmem_name"

    # get the vnc port number from xml
    portnum=$(sudo grep -oP "<graphics type=[\"']spice[\"'] port=[\"']\K\d+" "$xml_file")  # works for either single or double quotes
    portnum=${portnum:=5900}  # default if empty

    # Show user the parameters and ask for approval (quit if disapproved)
    becho "Please authorize the following. Note: no two running VMs may have the same looking-glass session-file or VNC-port at the same time"
    if _prompt_yn "VM: $vm_name, looking-glass_name: $shmem_name, VNC-port: $portnum. Launch with these parameters?"; then echo "Starting..."; else echo "Quitting. If the details were off, modify your VM's xml file (easiest through VM Manager)" && return ; fi

    becho "Making sure os-virtual-drive file's volume is mounted"
    mount_media_by_uuid "$QEMU_VOLUME_UUID"

    becho "Creating looking-glass session file: $lg_file"
    sudo touch "$lg_file" && sudo chown $(whoami):kvm "$lg_file" && sudo chmod 660 "$lg_file"
    [ -f "$lg_file" ] && ls -alF "$lg_file"  # todo - print colored (green?)?
    
    # run the vm (if needed)
    vm_state=$(virsh domstate "$vm_name")
    if [ "$vm_state" == "running" ]; then
        gecho "$vm_name is already running."
    elif [ "$vm_state" == "shut off" ]; then
        virsh start "$vm_name" && gecho "starting $vm_name"
    elif [ "$vm_state" == "paused" ]; then
        virsh resume "$vm_name" && gecho "resuming $vm_name"
    else
        recho "Can't handle VM state: $vm_state"
        if [ "$vm_state" == "blocked" ]; then recho "the VM '$vm_name' is blocked on resource";
        elif [ "$vm_state" == "shutdown" ]; then recho "$vm_name is still shutting down";
        elif [ "$vm_state" == "crashed" ]; then recho "the VM '$vm_name' has crashed";
        elif [ "$vm_state" == "pmsuspended" ]; then recho "the VM '$vm_name' is in a suspended state as a result of power management";
        else recho "Error: VM state isn't defined (fix this function)"
        fi
        return 1
    fi
    
    # run looking glass client
    # experimental -S : Prevent the screensaver from starting  , win:size=1920x1080 : Initial window size at startup (default is 1024x768)
    becho "Starting looking-glass client"
    "$LOOKING_GLASS_CLIENT" -f "$lg_file" -p $portnum -k -S & disown # -k : enable FPS & UPS display  ; -S : prevent host going to sleep

}

function create_systemd_service () {
    read -p "Choose the name of your service: " service_name  # Read the user's input
    service_name=${service_name%.service}  # remove the '.service' if it's there
    file_name="${service_name}.service"
    service_file="/etc/systemd/system/${file_name}"
    [ -s "$service_file" ] && is_empty='NON-empty file - CONTENTS WILL BE DELETED' || is_empty='empty file'
    if _prompt_yn "You'll modify as sudoer: $service_file ($is_empty). Are you ready?"; then echo "Creating file..."; else echo "Come back when you have everything you need." && return ; fi
    
    # provide a template
    if _prompt_yn "Need a template?"; then
        read -r -d '' initial_str << EOT
[Unit]
# rewrite this (don't worry about spaces)
Description=<Insert purpose here>
; Before=<what this service should preceed, e.g. "network.target">
; After=<what should run before this service, e.g. "somethingelse.service">

# should dependencies be inherited by unit's After/Before/Conflicts/BindsTo/PartOf/Wants directives?
; DefaultDependencies=yes/no  

[Service]
# you may want a different user.
User=root
; WorkingDirectory=<path to run at, maybe a project-dir>
ExecStart=<command that starts the service>

# no: The service should not be restarted. This is the default value.
# on-success: The service should be restarted when it exits successfully.
# on-failure: The service should be restarted when it exits with a non-zero exit code or when it terminates abnormally.
# on-abnormal: The service should be restarted when it terminates abnormally.
# on-abort: The service should be restarted when it is terminated by a signal.
# always: The service should be restarted regardless of the exit code or termination status.
; Restart=no/on-success/on-failure/on-abnormal/on-abort/always

# simple: The service is a simple service that runs a single command or process. This is the default value.
# forking: The service is a forking service that creates a new process group when it starts. This type of service is typically used for programs that fork and background themselves when they start.
# oneshot: The service is a one-shot service that runs a command or script and then exits. This type of service is typically used for tasks that need to be performed once and then stopped.
# dbus: The service is a D-Bus service that exports objects over the D-Bus message bus. This type of service is typically used for services that communicate over D-Bus.
# notify: The service is a notify service that sends a notification when it is ready. This type of service is typically used for services that need to signal their readiness to other services or clients.
; Type=simple/forking/oneshot/dbus/notify


[Install]
# who should automatically start this service. multi-user.target is common, it's the state in which multiple users can log in
; WantedBy=multi-user.target  
EOT
    # offer template adjustment
    if _prompt_yn "Include guiding comments in the template?"; then echo "Leaving in comments."; else initial_str=$(grep -v "^#" <<< "$initial_str") ; fi
    else 
        initial_str='';
    fi

    # insert template into the file (create/clear file if necessary)
    sudo sh -c "echo \"$initial_str\" > \"$service_file\""

    # let the user determine the contents of the service
    sudo nano "$service_file"

    if _prompt_yn "We're done. Want me to rescan, run and enable the service after boot?"; then
        echo 'reloading systemd...'
        sudo systemctl daemon-reload
    
        echo 'enabling after boot...'
        sudo systemctl enable "$file_name"

        echo 'starting service...'
        sudo systemctl start "$file_name"

        _wait_n_seconds '3'

        echo "Here's its status now:"
        sudo systemctl status "$file_name"
    fi

}


# Visuals
# =======
# TODO - detect if the terminal is bright instead of dark? If it's white, the colored prints should be darker; so you should remove the "\033[1m" prefix
# echo in red
function recho () {
    # echo "$(tput setaf 1)${@}$(tput sgr0)"
	echo -e "\033[1m\033[31m${@}\033[0m"
}
# echo in green
function gecho () {
    # echo "$(tput setaf 2)${@}$(tput sgr0)"
	echo -e "\033[1m\033[32m${@}\033[0m"
}
# echo in blue
function becho () {
	# echo "$(tput setaf 4)${@}$(tput sgr0)"
    echo -e "\033[1m\033[34m${@}\033[0m"
}
# echo in yellow
function yecho () {
	# echo "$(tput setaf 3)${@}$(tput sgr0)"
    echo -e "\033[1m\033[33m${@}\033[0m"
}

function _draw_formatted () {
    : 'runs printf with a specific assortment of color names'
    # the char before the ';' is 0:regular , 1: bold, 3: italic, 2: dark, 4:underline, 5: slow-blink, 6: fast-blink, 7: reverse, 8: hide, 9: cross-out
    # the tens-digit before the 'm' is 3:regular , 1: bold, 4:background, 9: bright, 10: bright background
    # the singles-digit before the 'm' is 0:Black, 1:Red, 2:Green, 3:Yellow, 4:Blue, 5:Purple, 6:Cyan, 7:White
    # https://stackoverflow.com/questions/5947742/how-to-change-the-output-color-of-echo-in-linux
    declare -A colors=(
    # regular
    [_Black_]='\033[0;30m' [_Red_]='\033[0;31m' [_Green_]='\033[0;32m' [_Yellow_]='\033[0;33m' [_Blue_]='\033[0;34m' [_Purple_]='\033[0;35m' [_Cyan_]='\033[0;36m' [_White_]='\033[0;37m'
    # bold
    [_BBlack_]='\033[1;30m' [_BRed_]='\033[1;31m' [_BGreen_]='\033[1;32m' [_BYellow_]='\033[1;33m' [_BBlue_]='\033[1;34m' [_BPurple_]='\033[1;35m' [_BCyan_]='\033[1;36m' [_BWhite_]='\033[1;37m'
    # intense
    [_IBlack_]='\033[0;90m' [_IRed_]='\033[0;91m' [_IGreen_]='\033[0;92m' [_IYellow_]='\033[0;93m' [_IBlue_]='\033[0;94m' [_IPurple_]='\033[0;95m' [_ICyan_]='\033[0;96m' [_IWhite_]='\033[0;97m'
    # bold intense
    [_BIBlack_]='\033[1;90m' [_BIRed_]='\033[1;91m' [_BIGreen_]='\033[1;92m' [_BIYellow_]='\033[1;93m' [_BIBlue_]='\033[1;94m' [_BIPurple_]='\033[1;95m' [_BICyan_]='\033[1;96m' [_BIWhite_]='\033[1;97m'
    # dark
    [_DBIBlack_]='\033[2;90m' [_DRed_]='\033[2;31m' [_DYellow_]='\033[2;33m' [_DBIWhite_]='\033[2;97m'
    )
    _NC_='\033[0;0m'  # no color (reset)
    # _WS_='O'  # '⠀'  # whitespace - accepting with number for repetition: _WS_, _WS1_, _WS2_, _WS3_, ...

    # TODO replace with number of spaces. This is how it'd be done in python:
    # match "--\d+--"
    # get group 1
    # replace with 
    # with f"--{int(group1) * n}--"

    # And this is theoretically how it'd be done directly in Bash:
    # sed -i 's/--\([0-9]\+\)--/\1/g' file.txt
    # doesn't work; tested:
    # mystr="this is a string with--10--a need for--3--space"
    # sed 's/--\([0-9]\+\)--/\1/g' <<< "$mystr"

    # technically if it worked, it should be saved like so:
    # mystr=$(sed exp <<< mystr)

#sed -r "s/_WS([0-9]+)_/$(printf '%*s' \"\1\")/" <<< wwwwwwww_WS2_aaaaaaaaaaa

    # replace key-names with coloring-values within the text
    text_to_draw=$1
    text_to_draw="${text_to_draw//_NC_/$_NC_}"  # replace no-color on its own, because otherwise we'd replace it with 2 consecutive color resets (still works, but isn't right)
    for str in "${!colors[@]}"; do
        text_to_draw="${text_to_draw//$str/${_NC_}${colors[$str]}}"
    done

    printf "$text_to_draw"

}

# TODO - make a drawing convention that adds in spaces
function draw_hentai () {
    HY='_IYellow_'  # Hair Yellow
    HYD='_Yellow_'  # Hair Yellow Dark
    S='_NC_'  # skin
    SD='_Red_'  # Skin Dark
    EW='_IWhite_'  # Eyes white
    W='_White_' # $IWhite  # teeth White
    WD=$S  # $White  # teeth White Dark
    WS='_DBIWhite_'  # White Shirt
    WSD='_DBIBlack_'  # White Shirt Dark
    G='_DRed_'  # Glove and eyebrows Brown
    GD='_DBIBlack_'  # Glove Brown Dark
    D='_DBIBlack_'  # dark
    NC='_NC_'

    # don't try to peek at the drawing here, go run the command in terminal
    read -r -d '' surprise << EOM
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀$HY⠰⡘⡸⢏$HYD⠼⠋$HY⡀⣱$HYD⢏⣾⣿⣿⣿⣿⣿⣿⣿⣧⠻⣿⣿⣷⣦$HY⡪⡳⠹⣷⣀⣀$NC⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀$HY⢀⣽⣿⡶⣢⢸$HYD⡇⡏⣾⣿⠹⣿⣆⢻⣿⣇⢿⣿⣷⡙⠿⣿⣿⣿⣮$HY⠢⣽⡯⡑⠂$NC⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀$HY⢘⣷⡱$HYD⣾⡟⠊⠧⠈⠟⢿⣧⢙⠻⣇⠙⢿⣎⢛⡻⠿⠦⠐⠩⠭⣭⣷⡜$HY⢷⡌⠄$NC⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀$HY⠢⠴⣾⣛$HYD⢱⣿⡑$S⡀$HYD⡀⠄$S⢸$SD⢧$HYD⠹⠸⠁⣈⠀⣰$SD⠌⣥$HYD⡈⢙⣿⠻⢛$SD⠭$HYD⠻⣿⡄$HY⡸⣧$NC⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀$HY⠠⢪⣇$HYD⠀⣇⢳⠀$S⣇⢻⡄$HYD⠆⡁$EW⠀⠀$HYD⠁$EW⣀$SD⠀⢾⣿⣿⣶⠀⣰⢁⡛⠇$HYD⢿⣿$HY⢸⡇$NC⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀$HY⠁⢸⢻$HYD⡰$S⠀$G⠈⠐$S⠩⠸⣄⠀⠢⣀$EW⠃$S⣀⣴⣿⣷⣮$SD⢻⣿⢠⡟⠠⢛⡘$HYD⢸⡏$HY⡞⠤$NC⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀$HY⢀⡌$HYD⠀⡴⣆$EW⠠$S⠀⣠⣷⣵⣿⣿⣿⣿⣿⣿⣿⣿$SD⣿⣿⣿⡿⠒⢅$HYD⣴⣿⠃$HY⢎⢩⡄⡀$NC⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀$HYD⠃⠿$S⢸⣿⡇⢙⠿⠛⣻⣿⣿⣿⡿⣿⡇$SD⣿⣿⣿⡇$HYD⠰⣾⣿⣿$HY⢸⠈⠃⠉⠁$NC⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀$S⢿⣿⡶⠬⡾⠿⣛⣛⢛⢰⣿⡇$SD⣿⣿⣿⡇⢧$HYD⡉⠻⢿$HY⠂⢃$NC⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀$S⠈⢻⣿⣆$W⠋⠉$D⣀⣀⠂$WD$S⣾⣿$SD⢸⣿⣿⠛⠀⠸⠁⠆$HYD⣾⣦$HY⡲⡒⠂$NC⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀$S⠙⢿⣇$W⠘⠻⢕$S⣴⣿⡏$SD⣾⠟⣡⠆⠄⠀⠀⠀$HYD⠹⠟⠃$HY⢈⠷⡀$NC⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀$G⣀⣀⣠$S⢠⡀$NC⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀$S⠈⢻⣟⠫⢍⣰⡿$SD⢐⣥⣾⠟⠀⠀⠀⠀⠀⠀⠀⠀⠀$HY⢠⠈$NC⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀$G⣠⠠⠴⠦$S⣻⣿⠌$SD⣴⠀⣐⣺⣿⠷$NC⠀⠀⠀⠀⠀⠀⠀$S⠛⠿⠟$SD⣩⣴⣿⠿⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀$HY⢸⡆$NC⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀$G⣀⡌⢦⡙$S⠰⠿⠟$SD⢁⢡$GD⣾$SD⠸⣿⠏$NC⠀⠀⠀⠀⠀⠀⠀⠀$WS⢤⣶⣆$SD⠇⣼⠟⠁⠀$SD⢀⣀⣀⡤⠤⣤$WSD⣶⣶⠆⠀⠀$HY⠸⠇$NC⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀$G⣼⢻⡟⣪$S⡘$SD⠿⠉$SD⣸$GD⡿⠘⠋$NC⠀⠀⠀⠀⠀⠀⠀⠀⠀$WS⡄⠦⠠⡀$WSD⠹⡄⠀⠀⠴⣾⠿⠙⠉⠁⠀⢹⣿⡇$NC⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀$G⣠⣰⣿⠄$SD⠘⣿⠍$GD⢰⢣⡿⠃$NC⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀$WS⢇⢠⢀$WSD⠀⠀⠁⣄⠀⢀⣰⡀⢀⠤⡆⠠⠀⠃⠀⠀⢀⣴⣶⣿⢿⣿⣿⣿⡶⠖⠒⠢$NC⠀⠀⠀⠀
$G⣀⣿⠟$GD⣴⣿⣿⣦⡣⠡⠀⠛$NC⠀⠀⠀⠀⠀⠀⠀⠀⠀$WS⣀⣠⣭⣭⣵⣮⡙⢾⣷⡆$WSD⠐⣿⣷⣾⣿⣿⣗⡤⡴⠐⠀⣠⣴⣿⣿⣿⣿⡿⠟⠋$NC⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
$G⣼⡟$GD⣸⣿⣿⠋⠁$NC⠀⠀⠀⠀⠀⠀⠀⠀$WS⣀⣬⣶⣾⣿⣿⣿⣿⣿⣿⣿⡿⡊⢋⣉⣬⣬$WSD⡰⣿⣿⡟⠋⢁⣠⣶⣿⣿⣿⣿⣿⣿⠫⠃$NC⠀⠀⠀⠀⠀⠀⠀⠀$WSD⣀⣤⣾⣿$NC
⠀⠀$GD⠈⠉$NC⠀⠀⠀⠀⠀⠀⠀⠀$WS⢀⣴⢇⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠏⢠⣾⣿⣿⣿⣿⣿⣎$WSD⠻⣿⣿⣿⣿⣿⣿⣿⣿⡿⠿⠇$NC⠀⠀⠀⠀⠀⠀⠀$WSD⢀⣤⣾⣿⣿⣿⢿$NC
_NC_\x59\x4f\x55\x20\x57\x45\x52\x45\x20\x45\x58\x50\x45\x43\x54\x49\x4e\x47\x20\x4c\x45\x57\x44\x53\x2c\x20\x42\x55\x54\x20\x49\x54\x20\x57\x41\x53\x20\x4d\x45\x2c\x20\x44\x49\x4f\x21
EOM

    _draw_formatted "$surprise\n"
}

# # https://stackoverflow.com/questions/23577516/how-to-replace-all-matches-with-an-incrementing-number-in-bash
# draw_hentai
# num=5
# # printf "%${num}s" |sed 's/ /FOO /g'
# # yes FOO | head -"${num}"
# repeat=echo 'aaaa'

# # repeat=`seq "$num" | sed "c abc"`

# echo "$repreat"



# TODO investigate this coloring method
# red=$(tput setaf 1)  # Set the text color to red
# normal=$(tput sgr0)  # Reset the text color to the default
# echo "${red}This text is red${normal}"  # Print the text in red
# Black: tput setaf 0
# Red: tput setaf 1
# Green: tput setaf 2
# Yellow: tput setaf 3
# Blue: tput setaf 4
# Magenta: tput setaf 5
# Cyan: tput setaf 6
# White: tput setaf 7



echo "Finished loading \"$(readlink -f -- "$BASH_SOURCE")\" for: \"`readlink -f $0`\""

